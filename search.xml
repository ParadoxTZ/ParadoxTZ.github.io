<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    
    
    
    
    <entry>
      <title>数据结构基础FDS</title>
      <link href="/2026/02/24/FDS/"/>
      <url>/2026/02/24/FDS/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="FDS"><a href="#FDS" class="headerlink" title="FDS"></a>FDS</h2><ul><li>公众号版本：</li></ul><a class="btn-beautify center" href="https://mp.weixin.qq.com/s/TXiznrF1Xp9Qlu0wQJ8Oyg" title="Click"><i class="far fa-hand-point-right"></i><span>Click</span></a><ul><li>网页PDF版本：</li></ul><p><a href="\myfile\FDS.pdf" target="_blank">FDS笔记</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 大二 </tag>
            
            <tag> ACEE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB面向对象编程</title>
      <link href="/2026/02/24/MATLAB%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2026/02/24/MATLAB%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>下面这是一个类<code>class</code>：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% ClassName.m</span></span><br><span class="line"><span class="keyword">classdef</span> className &lt; handle</span><br><span class="line"><span class="keyword">properties</span> <span class="comment">% 属性 block</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">methods</span>   <span class="comment">% 方法 block</span></span><br><span class="line">   ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>下面以创建一个二维点的案例作为示例，其中<code>Point2D</code>是一个类，<code>p1</code>和<code>p2</code>是对象</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Point2D.m</span></span><br><span class="line"><span class="keyword">classdef</span> Point2D &lt; handle</span><br><span class="line"><span class="keyword">properties</span></span><br><span class="line">x = <span class="number">0.0</span>; <span class="comment">% 默认值，可没有，如y</span></span><br><span class="line">y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span> = <span class="title">Point2D</span><span class="params">(x0,y0)</span> % 构造类型函数</span></span><br><span class="line">obj.x = x0;</span><br><span class="line">obj.y = y0;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalize</span><span class="params">(obj)</span>     % 归一化方法类函数</span></span><br><span class="line">r = <span class="built_in">sqrt</span>(obj.x^<span class="number">2</span> + obj.y^<span class="number">2</span>);</span><br><span class="line">obj.x = obj.x/r;</span><br><span class="line">obj/y = obj.y/r;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里的<code>Point2D</code>不是普通的函数，是一个类的构造函数<code>Constructor</code>，可以用以下方法创建对象：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p1 = Point2D(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">p2 = Point2D(<span class="number">2.5</span>,<span class="number">4.0</span>);</span><br></pre></td></tr></table></figure><h2 id="类的属性、方法及其分类"><a href="#类的属性、方法及其分类" class="headerlink" title="类的属性、方法及其分类"></a>类的属性、方法及其分类</h2><p>用下面一段代码（仍然以<code>Point2D</code>为例说明）</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">classdef</span> Point2D &lt; handle</span><br><span class="line"><span class="keyword">properties</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">properties</span>(Constant)   <span class="comment">% 常量属性</span></span><br><span class="line">R = <span class="built_in">pi</span>/<span class="number">180</span>;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">properties</span>(Dependent)  <span class="comment">% 非独立属性</span></span><br><span class="line">r <span class="comment">% 不占用存储空间，可以通过p1.r调用</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">properties</span>(Hidden)    <span class="comment">% 隐藏属性</span></span><br><span class="line">var <span class="comment">% 不会显示，开发、交互时有用</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">result</span> = <span class="title">get</span>.<span class="title">r</span><span class="params">(obj)</span></span></span><br><span class="line">result = <span class="built_in">sqrt</span>(obj.x^<span class="number">2</span> + obj.y^<span class="number">2</span>); <span class="comment">% 通过get方法进行调用计算</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">normalize(obj); <span class="comment">% 仅提供声明，可在外部独立文件中编程</span></span><br><span class="line">           <span class="comment">% 需要创建名为@Point2D的文件夹，把这些都丢进去</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在定义方法时，<code>obj</code>必须作为成员方法的参数之一，说明传递给该成员方法的参数是一个对象。当然你可以使用任何其他单词，这里使用<code>obj</code>是为了和C++语言中的<code>this</code>以及Python中的<code>self</code>进行区分</p><p>虽然方法也可以通过函数调用，如<code>normalize(p1)</code>，但还是更推荐使用点调用，即<code>p1.normalize()</code>。</p><h2 id="类的构造函数"><a href="#类的构造函数" class="headerlink" title="类的构造函数"></a>类的构造函数</h2><p>构造函数Constructor是一种特殊的成员方法，比如上文的<code>p1 = Point2D(1,1);</code>：</p><ul><li>其<strong>名字与类名相同</strong></li><li>类定义中至多只能有1个构造函数</li><li>其返回值必须只能是新创建的对象</li><li>这是唯一一个创建新对象的方法</li></ul><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% 提供多种输入参数数目的方法</span></span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span> = <span class="title">Point2D</span><span class="params">(x0,y0)</span></span></span><br><span class="line"><span class="keyword">if</span> nargin==<span class="number">0</span> <span class="comment">% 输入参数数量</span></span><br><span class="line">obj.x = <span class="number">0</span>; obj.y = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">elseif</span> nargin==<span class="number">2</span></span><br><span class="line">obj.x=x0; obj.y=y0;</span><br><span class="line"><span class="keyword">elseif</span> nargin==<span class="number">1</span></span><br><span class="line">obj.x=x0;obj.y=x0;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">error(<span class="string">&#x27;wrong input&#x27;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>如果没有创建构造函数，MATLAB后台会自动创建一个空函数用于构造。该函数没有输入。</p><h2 id="类的关系：继承、组合、聚集"><a href="#类的关系：继承、组合、聚集" class="headerlink" title="类的关系：继承、组合、聚集"></a>类的关系：继承、组合、聚集</h2><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>在逻辑上，继承即为泛化关系，表示B是A的“一种”(a kind of)，是父子、基类-派生类的关系。子类是父类的特殊类型，具有父类的全部属性，比如父类是电机，具有定子、转子、气隙这些属性，子类可以是永磁同步电机，额外具有永磁体属性。如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">% Point3D.m</span></span><br><span class="line"><span class="keyword">classdef</span> Point3D &lt; Point2D</span><br><span class="line"><span class="keyword">properties</span></span><br><span class="line">z</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span> = <span class="title">Point3D</span><span class="params">(x0,y0,z0)</span>;</span></span><br><span class="line">obj = obj@Point2D(x0,y0); <span class="comment">% 用@表示调用父类，子类必须先调用父类</span></span><br><span class="line">obj.z = z0;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span><span class="params">(obj)</span>;</span></span><br><span class="line">print@Point2D(obj); <span class="comment">% 调用同名方法：函数名@父类类名(obj，其它参数)</span></span><br><span class="line"><span class="built_in">disp</span>([<span class="string">&#x27;z=&#x27;</span>,num2str(obj.z)]);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>继承中子类可以得到父类的全部属性，但是不能为了让B的功能更多而盲目地对A和B使用继承，否则将造成混乱。另一种逻辑关系是组合，比如人脸和五官之间的关系。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">classdef</span> Mouse &lt; handle</span><br><span class="line"><span class="comment">% ...</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">... <span class="comment">% Other Classes in other Matlab Files</span></span><br><span class="line"><span class="keyword">classdef</span> Face &lt; handle <span class="comment">% 使用handle而非多重继承：Mouse&amp;Eye&amp;Nose</span></span><br><span class="line"><span class="keyword">properties</span></span><br><span class="line">mouse</span><br><span class="line">... <span class="comment">% Others Like eye/nose/ear</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">obj</span>=<span class="title">Face</span><span class="params">()</span></span></span><br><span class="line">obj.mouse = Mouse();</span><br><span class="line">... <span class="comment">% Others Like Eye/Nose/Ear</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="聚集"><a href="#聚集" class="headerlink" title="聚集"></a>聚集</h3><p>聚集跟组合的关系类似，但聚集更加<strong>松散</strong>。部分结构不依赖于整体存在，比如自行车的车轮可以先被定义（制造），然后再装到自行车上面去。这意味着<strong>子对象可以被独立创建</strong>。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% Bike.m</span></span><br><span class="line"><span class="keyword">classdef</span> Bike &lt; handle</span><br><span class="line"><span class="keyword">properties</span></span><br><span class="line">frontWheel</span><br><span class="line">rearWheel</span><br><span class="line">seat</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% Scripts</span></span><br><span class="line">frontWheelObj = Wheel();  <span class="comment">% 独立存在</span></span><br><span class="line">rearWheelObj = Wheel();</span><br><span class="line">seatObj = Seat();</span><br><span class="line">...</span><br><span class="line">myBike = Bike();</span><br><span class="line">myBike.frontWheel = frontWheelObj; <span class="comment">% 聚集关系</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="Handle类的set和get方法"><a href="#Handle类的set和get方法" class="headerlink" title="Handle类的set和get方法"></a>Handle类的set和get方法</h2><h3 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h3><p>set方法为对象 属性的幅值提供了一个中间层，在对象A的外部，任何对属性a（A.a）的幅值都需要经过<code>set.a</code>这个中间层，通常用来检测赋值是否合理，如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">classdef</span> Point_Quadrant1 &lt; handle</span><br><span class="line"><span class="keyword">properties</span></span><br><span class="line">x</span><br><span class="line">y</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>.<span class="title">x</span><span class="params">(obj,valx)</span></span></span><br><span class="line"><span class="keyword">if</span> (valx&lt;<span class="number">0</span>)</span><br><span class="line">error(<span class="string">&#x27;Not in First Quadrant&#x27;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">obj.x = valx;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">set</span>.<span class="title">y</span><span class="params">(obj,valy)</span> </span></span><br><span class="line"><span class="comment">% ...略</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>get方法已经在上面介绍过了，是一种对成员属性查询的中间层。可以理解为get和set的调用正好相反：</p><ul><li><code>set</code>是对某个值进行设置，因此写为：<code>obj.a = val</code></li><li><code>get</code>是对某个值进行调用，因此写为：<code>val = obj.a</code></li></ul><p>进阶用法暂时不讲了</p><h2 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h2><p>跟前面属性的非独立、常量、隐藏属性类型，<strong>属性和方法</strong>都可以加上权限设置：<code>methods(Access = private/protected/public)</code></p><p>在OOP中，<code>public</code>类应该尽量少用，这和面向对象的封装是矛盾的</p><p>此外，<code>Access</code>还可以细分为<code>GetAccess</code>和<code>SetAccess</code>，表示读取权限和设置权限</p><p>此外，还可以通过更加细节的设置，指定某个类的访问权限，比如：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% BankAccount.m</span></span><br><span class="line"><span class="keyword">classdef</span> BankAccount &lt; handle</span><br><span class="line"><span class="keyword">properties</span>(SetAccess = &#123;?BankTeller,?Paradox&#125;) <span class="comment">% 只允许BankTeller、Paradox、类内部的方法访问</span></span><br><span class="line">balance <span class="comment">% 允许银行柜员修改账户余额的数值</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deposit</span><span class="params">(obj,val)</span></span></span><br><span class="line">obj.balance = obj.balance+val; <span class="comment">% 存钱，类内部的成员方法可以访问</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% BankTeller.m</span></span><br><span class="line"><span class="keyword">classdef</span> BankTeller &lt; handle</span><br><span class="line"><span class="keyword">methods</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deposit</span><span class="params">(obj,acc,val)</span></span></span><br><span class="line">acc.balance = acc.balance+val; <span class="comment">% 因为具有访问权限，所以可以直接修改</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% Scripts</span></span><br><span class="line">myCard = BankAccount();</span><br><span class="line">myCard.deposit(<span class="number">500</span>); <span class="comment">% 存500块钱，允许</span></span><br><span class="line">myCard.balance = myCard.balance+<span class="number">500</span>; <span class="comment">% 妄图直接修改账户余额，报错！</span></span><br><span class="line">xiaoE = BankTeller();</span><br><span class="line">xiaoE.deposit(myCard,<span class="number">500</span>); <span class="comment">% 银行柜员小E给你的卡增加了500块钱，允许</span></span><br></pre></td></tr></table></figure><h1 id="句柄类和实体值类"><a href="#句柄类和实体值类" class="headerlink" title="句柄类和实体值类"></a>句柄类和实体值类</h1><h2 id="定义与区别"><a href="#定义与区别" class="headerlink" title="定义与区别"></a>定义与区别</h2><p>以下只是鄙人粗浅的理解：</p><ul><li>可以认为句柄类对象（Handle）是MATLAB传参的一种高级手段，有点类似于C的指针。MATLAB会在内存中开出一块空间，用于存放这个变量的具体数值，而在该对象中仅留下一个地址，指向该数据存放的位置。</li><li><code>value</code>类适合比较简单的数据，其原理就是很单纯的数值传递，且对对象的处理主要不是为了改变原有的数值，而是为了获得新的事物</li><li><code>handle</code>类适合希望这些数据在各个方法、函数之间迅捷传递，不需要被局部复制，所有对象共享属性（改一个就能改掉所有）的时候。</li><li>他俩操作的区别主要就是有没有在<code>classdef</code>里面加上<code>&lt; handle</code></li></ul><h2 id="类的析构函数-Destructor"><a href="#类的析构函数-Destructor" class="headerlink" title="类的析构函数 Destructor"></a>类的析构函数 Destructor</h2><p>看不懂喵</p>]]></content>
      
      
      <categories>
          
          <category> 软件教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（研）交流电机调速理论-杨家强</title>
      <link href="/2026/02/24/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E8%B0%83%E9%80%9F%E7%90%86%E8%AE%BA/"/>
      <url>/2026/02/24/%E4%BA%A4%E6%B5%81%E7%94%B5%E6%9C%BA%E8%B0%83%E9%80%9F%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>与《现代运动控制策略》和《电机控制》中重合的部分请参考他们各自的网页。</p><h1 id="调压调速与电磁转差离合器调速"><a href="#调压调速与电磁转差离合器调速" class="headerlink" title="调压调速与电磁转差离合器调速"></a>调压调速与电磁转差离合器调速</h1><ul><li>分类：<ul><li>转差功率<strong>消耗型</strong>：<ul><li>转差功率全部转化成热能而被消耗掉</li><li>特点：系统的效率低，结构简单</li><li>调压调速、绕线式异步 电动机转子串电阻调速、电磁转差离合器调速系</li></ul></li><li>转差功率<strong>回馈型</strong>：<ul><li>转差功率的少部分被消耗掉，大部分通过变流装置回馈给电网或者转化为机械能予以利用</li><li>特点：效率高</li><li>串级调速属</li></ul></li><li>转差功率<strong>不变型</strong>：<ul><li>调速过程中，转差功率基本不变</li><li>特点：效率最高</li><li>变极调速、变频调速</li></ul></li></ul></li></ul><h2 id="调压调速"><a href="#调压调速" class="headerlink" title="调压调速"></a>调压调速</h2><script type="math/tex; mode=display">T_e=\frac{3pU_1^2R_2'/s}{\omega_1[(R_1+R_2'/s)^2+\omega_1(L_1+L_2')^2]}</script><p><img src="/image/电机学16.png" alt=""></p><p>关于三相调压的方式，可以参考<a href="https://zju-paradox.top/2024/04/18/电力电子技术/#调压电路">电力电子技术 | Paradox’s Website</a>，主要看三相调压，大概看看就行。比如需要满足：</p><ol><li>三相电路中至少要有一相的正向晶闸管与另一相的反向晶闸管同时导通</li><li>采用宽脉冲或双窄脉冲触发电路</li><li>U、V、W三相电路中正、反向晶闸管的触发信号相位互差120°，同相中反并联的两个正、反向晶闸管的触发脉冲相位互差180°</li></ol><p>对于普通电机，调速范围是很小的。但是对于高转子电阻电机，可以将调速范围扩的很大。但与之对应的，开环特性会很软。</p><p><img src="/image/电机学15.jpg" alt=""></p><p>上面这张图我应该已经拿出来说过非常多次了，真的很好用。由此，电机的效率直接在一定程度上认为是：$\eta\approx 1-s$</p><ul><li>恒转矩负载：有$T_e=T_L$不变，因$f_1$不变，故电磁功率$P_2$也不变。随着转速的降低，转差功率$sP_2$增大，效率降低。</li><li><strong>恒功率</strong>（风机泵类）负载：有$T_e=T_L=Kn^2$，$T_e、P_2$随转速以平方速率下降，尽管低速时s增大，但总的转差功率$sP_2$下降，损耗变小。</li></ul><h3 id="起动"><a href="#起动" class="headerlink" title="起动"></a>起动</h3><ul><li><p>要求：</p><ul><li>足够大的、平稳的起动转矩</li><li>尽可能小的起动电流</li><li>起动过程中的损耗要小</li></ul></li><li><p>限流起动：主要是用在轻载起动，起动时难以知道起动压降，时间长</p></li><li>斜坡电压起动：电压由小到大斜坡线性上升，是无级降压起动，主要用在重载起动</li><li>用在重载起动：将电动机的起动转矩由小到大线性上升，起动平滑柔性好， 对拖动系统有更好的保护，延长拖动系统的使用寿命，同时降低电机起动时对电网的冲击</li></ul><h2 id="电磁转差离合器调速"><a href="#电磁转差离合器调速" class="headerlink" title="电磁转差离合器调速"></a>电磁转差离合器调速</h2><p>电磁转差离合器调速系统是由笼型异步电动机、电磁转差离合器以及控制装置组合而成。它本身并不是一个电动机，它只是一种传递功率的装置。原动机照常转，从动机变转速。</p><p><img src="/image/jldj01.png" alt=""></p><p><u>原动机拖动电枢恒速定向旋转</u>，电枢切割脉动磁场，电枢中感生电动势并产生涡流。产生的电枢反应磁场带动有齿槽的永磁体一同旋转。<strong>从动轴的转速n取决于励磁电流的大小</strong>：</p><script type="math/tex; mode=display">n=n_1-K\frac{T_e}{I_f^4}</script><h1 id="绕线异步电机双馈（串级）调速"><a href="#绕线异步电机双馈（串级）调速" class="headerlink" title="绕线异步电机双馈（串级）调速"></a>绕线异步电机双馈（串级）调速</h1><h2 id="异步电机转子附加电动势"><a href="#异步电机转子附加电动势" class="headerlink" title="异步电机转子附加电动势"></a>异步电机转子附加电动势</h2><p>在转子绕组回路中引入一个可控的交流附加电动势$E_{add}$，与转子电动势$E_r$有相同的频率。此时转子相电流：</p><script type="math/tex; mode=display">I_r=\frac{sE_{r0}\pm E_{add}}{\sqrt{R_r^2+(sX_{r0}^2)}}</script><p>当附加电动势$E_{add}$与转子电动势$E_r$同向时，电流瞬时增大，达到转速增大的新平衡。反向同理。</p><h2 id="双馈调速的五种工况"><a href="#双馈调速的五种工况" class="headerlink" title="双馈调速的五种工况"></a>双馈调速的五种工况</h2><p>由于转子侧串入附加电动势极性和大小的不同，s和Pm都可正可负，因而可以有多种运行工况。</p><p><img src="/image/jldj02.png" alt=""></p><p>其实看懂上面四张图基本就行了，<strong>上面几种工况都是正转情况下的</strong>。</p><p>yjq多的一种工况是<strong>位能性恒转矩负载的反转制动</strong>（重物下放），此时转差频率$s&gt;1$，电机吸收功率和电网输送到电机的功率全都馈送到电网。</p><p>md这b写的PPT和讲的课真是依托勾石</p><h2 id="亚同步速电动状态下的串级调速系统"><a href="#亚同步速电动状态下的串级调速系统" class="headerlink" title="亚同步速电动状态下的串级调速系统"></a>亚同步速电动状态下的串级调速系统</h2><p><img src="/image/jldj03.png" alt=""></p><ul><li>转子侧接入一个三相不控整流器，将交流转差功率$f_2=sf_1$转换为直流形式，由电源侧设置的三相有源逆变桥所提供的直流逆变电动势吸收转差功率，并转化为电网频率$f_1$电流返回电网</li><li>该系统的速度调节是通过改变有源逆变器中移相角β以改变直流回路电压Uβ的大小，从而改变与其相联系的异步电动机转子附加电动势$E_f$，以达到调节电机转速的目的</li></ul><script type="math/tex; mode=display">sE_{d0}-\Delta U_M=U_{d0}\rightarrow +I_dR_e\rightarrow U_{\beta}=2.34U_s\cos\beta+\Delta U_s</script><h2 id="机械特性"><a href="#机械特性" class="headerlink" title="机械特性"></a>机械特性</h2><p><img src="/image/jldj04.png" alt=""></p><p>串级调速时，异步电动机转子回路虽然不需要串入调速 电阻，但由于其转子回路中接入了串级调速装置，实际上相当于在电动机转子回路中接入了一定数量的等效电阻和电抗。由于转子回路电阻的影响，异步电动机<strong>串级调速时的机械特性比其固有特性要软</strong>。</p><h1 id="变频调速与脉宽调制"><a href="#变频调速与脉宽调制" class="headerlink" title="变频调速与脉宽调制"></a>变频调速与脉宽调制</h1><h2 id="变频调速"><a href="#变频调速" class="headerlink" title="变频调速"></a>变频调速</h2><h3 id="PWM整流-逆变"><a href="#PWM整流-逆变" class="headerlink" title="PWM整流-逆变"></a>PWM整流-逆变</h3><p>没啥好写的</p><h3 id="谐振软开关"><a href="#谐振软开关" class="headerlink" title="谐振软开关"></a>谐振软开关</h3><div class="table-container"><table><thead><tr><th><img src="/image/jldj05.png" alt=""></th><th><img src="/image/jldj06.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>逆变器的功率开关器件应安 排在$u_C$过零时刻（$t_4-t_0$）进行 开关状态切换，实现零电压软开关操作</p><h2 id="脉宽调制"><a href="#脉宽调制" class="headerlink" title="脉宽调制"></a>脉宽调制</h2><h3 id="SPWM"><a href="#SPWM" class="headerlink" title="SPWM"></a>SPWM</h3><p>计算<strong>正弦调制波</strong>与高频<strong>三角载波</strong>的”交点“，从而求出相应的<strong>占空比</strong>$D$，生成SPWM波</p><p>设三角载波的幅值为1，则正弦调制波的幅值$U_{rm}=M$，即$sine = M\sin(\omega t)$</p><ol><li>自然采样：计算交点：$D=\frac12(1+\frac M2(\sin\omega t_1+\sin\omega t_2))$</li><li>对称规则采样：在三角载波的峰值或谷值计算一次正弦信号的幅值：$D=\frac12(1+M\sin\omega t_0)$</li><li>不对称规则采样：在三角载波的峰值和谷值分别计算正弦信号的幅值：$D=\frac12(1+\frac M2(\sin\omega t_1+\sin\omega t_2))$</li></ol><h3 id="制定谐波消去"><a href="#制定谐波消去" class="headerlink" title="制定谐波消去"></a>制定谐波消去</h3><p>令：</p><script type="math/tex; mode=display">U_{km}=\frac{2U_s}{k\pi}\left[ 1+2\sum(-1)^i\cos k\alpha_i \right]=0</script><h3 id="双PWM变换器"><a href="#双PWM变换器" class="headerlink" title="双PWM变换器"></a>双PWM变换器</h3><p>其实就是并网逆变器控制。优点：</p><ul><li>功率可以双向流动</li><li>输入电流正弦而且谐波含量少</li><li>功率因数可调，可运行在单位功率因数下</li><li>在输入电网电压固定的情况下直流母线电压可以调节， 且直流母线电压抗负载扰动的稳定性好</li><li>对PWM整流器的有效控制可以使直流储能用的电解电容容量有所降低。</li></ul><p>控制方式参考<a href="https://zju-paradox.top/2025/11/02/现代运动控制策略/#并网逆变器网侧pwm控制">现代运动控制策略-孙丹 | Paradox’s Website</a></p><h1 id="开关磁阻电机"><a href="#开关磁阻电机" class="headerlink" title="开关磁阻电机"></a>开关磁阻电机</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>磁通总是沿磁阻最小（磁导最大）的路径闭合</p><p><img src="/image/jldj07.png" alt=""></p><p>一般而言，定子齿数比转子齿数更多，有：$Z_s=2m=Z_r+2$，转速$n=\frac{60f}{N_r}$</p><h2 id="结构设计"><a href="#结构设计" class="headerlink" title="结构设计"></a>结构设计</h2><h3 id="功率变换器-具有最少数量主开关器件的功率变换器"><a href="#功率变换器-具有最少数量主开关器件的功率变换器" class="headerlink" title="功率变换器 - 具有最少数量主开关器件的功率变换器"></a>功率变换器 - 具有最少数量主开关器件的功率变换器</h3><p><img src="/image/jldj08.png" alt=""></p><p>可以接到功率变换器的绕组<strong>最多相数为上、下桥臂主开关数</strong> $n_U\times n_L$</p><p>Va和Vb导通时，A相绕组通电；Va和Vb关断时，绕组通过$V<em>{Da}$、$V</em>{Db}$和$V_{D1}$续流</p><ul><li><p>保留了桥式电路的全部优点，但每相主开关器件少于两个；</p></li><li><p><strong>增加电动机相数从而减小转矩脉动</strong>而又<strong>不增加功率变换器成本</strong>。</p></li><li><p>主开关器件额定电压&gt;Us</p></li></ul><p><strong>其他功率变换电路的优缺点比较</strong>（放图片绝对不是因为我懒得抄了，绝对不是…）</p><p><img src="/image/jldj09.png" alt=""></p><h2 id="运行方式"><a href="#运行方式" class="headerlink" title="运行方式"></a>运行方式</h2><p>同样的，开关磁阻电机的电感（互感）也是随转子角度而变化的函数，但不同的是这是梯形波。</p><script type="math/tex; mode=display">U=iR+L\frac{\text di}{\text dt}+i\frac{\partial L}{\partial \theta}\omega</script><p>不是，我tm看不懂啊</p><h2 id="控制方式"><a href="#控制方式" class="headerlink" title="控制方式"></a>控制方式</h2><h3 id="角度位置控制APC-高速"><a href="#角度位置控制APC-高速" class="headerlink" title="角度位置控制APC - 高速"></a>角度位置控制APC - 高速</h3><p>加于相绕组两端的电压大小不变的情况下，通过调节SRM电动机的主开关器件的开通角 $\theta<em>{on}$ 和关断角 $\theta</em>{off}$ 的值，来实现转矩和速度的调节。可以简单的理解为，两个角度之间的差值 $\theta<em>{on}-\theta</em>{off}$ ，越大，功率变换器的电压作用时间越长，电机的相电流越大。</p><p>尤其是当电机<strong>转速较高</strong>，旋转电动势较大，电机绕组电流相对较小时，最宜采用此种控制方式。</p><h3 id="电流斩波控制CCC-低速"><a href="#电流斩波控制CCC-低速" class="headerlink" title="电流斩波控制CCC - 低速"></a>电流斩波控制CCC - 低速</h3><p>在SRM电动机起动、中低速运行时，电压不变，旋转电动势引起的压降小，电感上升期的时间长，而<strong>di/dt的值却相当大</strong>。</p><p> 为避免过大的电流脉冲峰值超过功率开关元件和电机允许的最大电流，通常会采用电流斩波的控制方式来<strong>限制电流大小</strong>。 一 般在低速运行时，将使电机的开通角 $\theta<em>{on}$ 和关断角 $\theta</em>{off}$ 保持不变， 而主要<strong>靠控制斩波电流$T_i$的大小来调节电流的峰值</strong>，从而起到调 节电动机转矩和转速的目的</p><p>斩波电流的波形有一点像电流滞环</p><h3 id="宽范围调速SRD"><a href="#宽范围调速SRD" class="headerlink" title="宽范围调速SRD"></a>宽范围调速SRD</h3><p>混合</p><p><img src="/image/jldj10.png" alt=""></p><h2 id="噪声与振动抑制"><a href="#噪声与振动抑制" class="headerlink" title="噪声与振动抑制"></a>噪声与振动抑制</h2><p>由于开关磁阻电机的定转子双凸极结构及特殊的供电方式，为了提高电机输出功率密度，开关磁阻电机常运行在<strong>深度磁饱和状态</strong>，转矩是转子位置和绕组电流的非线性函数，在采用传统的<u>矩形脉冲供电</u>模式下，电机<strong>转矩脉动明显</strong>，<strong>运行噪声也较大</strong>，这在转轴惯量小、转速低时尤为严重。</p><p>爬爬爬</p><h1 id="大功率交流电机调速"><a href="#大功率交流电机调速" class="headerlink" title="大功率交流电机调速"></a>大功率交流电机调速</h1><h2 id="大容量电机的调速方法"><a href="#大容量电机的调速方法" class="headerlink" title="大容量电机的调速方法"></a>大容量电机的调速方法</h2><p>矛盾点：交流电机调速一般采用<strong>变频</strong>，而大容量、高电压的电机不好变频</p><h3 id="高-低-高结构"><a href="#高-低-高结构" class="headerlink" title="高-低-高结构"></a>高-低-高结构</h3><ul><li>先把高压降下来，在低压段变频，变完再升回去</li><li>降压变压器 - 整流变压器（变频） - 升压变压器（可采用多重化技术）</li><li>实际上是低压变频器，难度小，变频器成本↓</li><li>2个变压器，体积↑、损耗↑ 、效率↓</li></ul><h3 id="多管串联的两电平变换电路"><a href="#多管串联的两电平变换电路" class="headerlink" title="多管串联的两电平变换电路"></a>多管串联的两电平变换电路</h3><ul><li>可拓展为多电平：<ul><li>传统两电平逆变器的输出电压只有 +Vdc 和 –Vdc 两个电平；</li><li>多电平逆变器通过<strong>增加中间电平（如0、±Vdc/2、±Vdc/3…）</strong>，使输出波形更接近正弦波，从而<strong>降低谐波含量</strong>、<strong>减小dv/dt</strong>、<strong>提高输出质量</strong></li></ul></li><li>每个功率器件承受的电压减半，但电流不变</li></ul><h3 id="多电平电压型逆变器"><a href="#多电平电压型逆变器" class="headerlink" title="多电平电压型逆变器"></a>多电平电压型逆变器</h3><h3 id="单元串联多电平PWM电压源型逆变器（交直交）"><a href="#单元串联多电平PWM电压源型逆变器（交直交）" class="headerlink" title="单元串联多电平PWM电压源型逆变器（交直交）"></a>单元串联多电平PWM电压源型逆变器（交直交）</h3><p><img src="/image/jldj11.png" alt=""></p><ul><li><p><strong>单元串联结构</strong></p><ul><li><p>由<strong>多个H桥逆变单元串联</strong>而成，每个单元有<strong>独立的直流电源（或电容）</strong></p></li><li><p>每个H桥都能输出 +Vdc、0、–Vdc 三种电平。例如：</p><ul><li>串联两个H桥 → 输出电平数 = 2×2+1 = 5电平</li><li>串联三个H桥 → 输出电平数 = 2×3+1 = 7电平</li></ul></li></ul></li><li><p><strong>移相变压器</strong></p><ul><li>在工业场合（如6kV、10kV电机驱动）时，不可能准备很多独立的直流电源</li><li>移相变压器可以从<strong>同一输入电网</strong>获取多个<strong>电气隔离且相位错开的低压直流电源</strong>。</li><li>延边三角形 → 次级相位<strong>超前或滞后一定角度</strong>（取决于接线方式）</li></ul></li><li><p><strong>为什么要移相</strong></p><ul><li>每一组逆变单元都会产生一个由矩形波拟合成的<strong>“伪正弦信号”</strong>，谐波含量丰富</li><li>如果有多组整流单元，并且各组的输入电压<strong>相位不同</strong>，那么这些整流电流的<strong>谐波会相互抵消</strong></li></ul></li></ul><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">电网（高压交流） </span><br><span class="line">   ↓</span><br><span class="line">移相变压器（多组次级绕组）</span><br><span class="line">   ↓</span><br><span class="line">多个低压整流单元（交→直）</span><br><span class="line">   ↓</span><br><span class="line">多个H桥逆变单元（直→交，PWM控制）</span><br><span class="line">   ↓</span><br><span class="line">多单元输出电压串联叠加</span><br><span class="line">   ↓</span><br><span class="line">电机（高压交流输出）</span><br></pre></td></tr></table></figure><p>移相变压器的二次绕组在绕制时，采用延边三角形，相互间差某一相位角。移相变压器将输入交流电变为低压交流电</p><h2 id="大功率多相变频调速系统"><a href="#大功率多相变频调速系统" class="headerlink" title="大功率多相变频调速系统"></a>大功率多相变频调速系统</h2><ul><li>重点在电机的<strong>多相</strong><ul><li>可实现低压大功率，特别适合应用于低压供电场合。</li><li>随着相数增多，电机<strong>转矩脉动幅值减少</strong>，振动和噪声减少，低速性能得到改善。</li><li>由于<strong>冗余特性</strong>，多相驱动系统可在故障情况下实现<strong>容错运行</strong>，显著增加了系统的可靠性。</li><li>多相电机的另一个重要特性是具有多自由度，<strong>提高功率密度和增大转矩输出</strong>。</li></ul></li></ul><p><img src="/image/jldj12.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 研究生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（研）动力与电气工程工业应用综述</title>
      <link href="/2026/02/24/%E5%8A%A8%E5%8A%9B%E4%B8%8E%E7%94%B5%E6%B0%94%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%B8%9A%E5%BA%94%E7%94%A8%E7%BB%BC%E8%BF%B0/"/>
      <url>/2026/02/24/%E5%8A%A8%E5%8A%9B%E4%B8%8E%E7%94%B5%E6%B0%94%E5%B7%A5%E7%A8%8B%E5%B7%A5%E4%B8%9A%E5%BA%94%E7%94%A8%E7%BB%BC%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="复习资料"><a href="#复习资料" class="headerlink" title="复习资料"></a>复习资料</h1><p>由AI整理PPT内容而成，本人做了整合和删改，放了历年题</p><p>如果有序号是跳的，比如1之后是3，说明2是在介绍企业or历史这种傻逼东西 </p><p><strong>可能会有谬误or一楼，注意甄别，正确性概不负责，建议对照PPT</strong></p><p><a href="\myfile\复习提纲_电控.docx" target="_blank">电控</a></p><p><a href="\myfile\复习提纲_电自.docx" target="_blank">电自</a></p><p><a href="\myfile\复习提纲_电力电子.docx" target="_blank">电力电子</a></p><p><a href="\myfile\复习提纲_双控.docx" target="_blank">双控</a></p><h1 id="25-26冬-回忆卷"><a href="#25-26冬-回忆卷" class="headerlink" title="25-26冬 回忆卷"></a>25-26冬 回忆卷</h1><p>一共8题，一题20分，取得分最高的5题。 </p><p><strong>电控</strong> </p><ol><li><p>稀土稀有吗？我国主要分布在哪两个地方？轻重稀土分别在哪多？稀土除了永磁体之外有什么应用？钐钴永磁的两种配比？铷铁硼永磁和钐钴永磁在剩磁、矫顽力、耐高温、成本方面的优劣？ </p><p>（历年卷原题，知识点碎而杂，评价为送分） </p></li><li><p>高速SPMSM电机中碳纤维作为转子保护套有什么优点？传统高温铝合金材料作为保护套有什么缺点？ </p><p>（今年新增内容，考题不算特别偏，碳纤维在电机领域的应用） </p></li></ol><p><strong>电自</strong> </p><ol><li><p>光伏电池的等效电路图，伏安特性曲线图。 </p><p>（画两个图直接给20分，评价为送分题） </p></li><li><p>电力电子技术在发电和输电领域的应用。 </p><p>（历年题小改，注意是发电和输电领域。就是不知道写一个给几分。基本送分） </p></li></ol><p><strong>电力电子</strong> </p><ol><li><p>画出户用光储PCS的两种架构，包含开关、电网、变换器等元件。并说明各个元件的作用。 </p><p>（光储的内容很多PPT都有讲，我已经搞混了，不知道这个是哪章的） </p></li><li><p>画出一种数据中心供电架构，包含从10kV AC中压到1.8V DC供给GPU的全过程、AC-AC/AC-DC/DC-DC（PDU不用画出）。并说明各个结构的作用。 </p><p>（数据中心供电，画结构图，整体不算超纲但需要记忆量较大） </p></li></ol><p><strong>双控</strong> </p><ol><li><p>视觉生产力落地过程中会遇到哪些挑战？从你熟悉的工业应用领域出发，这些挑战会如何影响产业？ </p><p>（2024年原题套皮，今年又考，我的提纲中有完整回答） </p></li><li><p>视觉解析力的五个维度分别是什么？他们的内涵？分析产业应用？ </p><p>（VIVO的端侧影像算法，考这个我的评价是sml，我一个字没写，所以题目印象不深可能略有出入） </p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 研究生 </tag>
            
            <tag> 课程资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双足机器人课程笔记</title>
      <link href="/2026/02/24/%E5%8F%8C%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
      <url>/2026/02/24/%E5%8F%8C%E8%B6%B3%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Articulated-robots（关节型机器人）"><a href="#Articulated-robots（关节型机器人）" class="headerlink" title="Articulated robots（关节型机器人）"></a>Articulated robots（关节型机器人）</h1><h2 id="Mechanisms（机构）"><a href="#Mechanisms（机构）" class="headerlink" title="Mechanisms（机构）"></a>Mechanisms（机构）</h2><ul><li><p>Def：A system of 2 or more linked machine parts with kinematic pairs（运动副）</p><ul><li>运动副的元素：点、线、面</li><li>分类：<ul><li>按压强：高副（点、线）、低副（面）</li><li>按自由度：平面副、空间副</li></ul></li><li>机器人机械臂基本都是平面转动副</li></ul></li><li><p>自由度（Degree of Freedom，DoF）</p><ul><li>机器人的自由度认为是可被独立驱动器的数目</li><li>n：可以动的零部件数目（结构数）</li><li>L：低副数目</li><li>H：高副数目</li><li>$DoF = 3n-2L-H$</li></ul></li></ul><h2 id="Robot-Manipulators（机械臂）"><a href="#Robot-Manipulators（机械臂）" class="headerlink" title="Robot Manipulators（机械臂）"></a>Robot Manipulators（机械臂）</h2><ul><li>Def： A sequence of rigid bodies ~（没抄完）</li></ul><h1 id="Rotation-Geometry（旋转几何体）"><a href="#Rotation-Geometry（旋转几何体）" class="headerlink" title="Rotation Geometry（旋转几何体）"></a>Rotation Geometry（旋转几何体）</h1><h2 id="Position-amp-Orientation"><a href="#Position-amp-Orientation" class="headerlink" title="Position &amp; Orientation"></a>Position &amp; Orientation</h2><ul><li>Coordinate Frame（坐标系）变换的推导</li></ul><script type="math/tex; mode=display">\begin{gather*}对一个矢量r，在不同坐标系下的表达分别为：\\\begin{cases}^0r=X\dot I+Y\dot J+Z\dot K\\^1r=x\dot i+y\dot j+z\dot k\end{cases}\\根据点积的几何意义，可以写出三条表达式：\\\begin{cases}X=\dot I\cdot \dot r=\dot I\cdot \dot {r^1}=\dot I\cdot x\dot i+\dot I\cdot y\dot j+\dot I\cdot z\dot k\\Y=...\\Z=...\end{cases}\\得：^0r=\begin{bmatrix}X\\Y\\Z\end{bmatrix}= \,^0R_1\begin{bmatrix}x\\y\\z\end{bmatrix}=\,^0R_1\,^1r\\且：^0R_1=\,^1R_0^{(-1)}=\,^1R_0^T(即：旋转矩阵の逆=转置)\\^0R_1(1到0)=\begin{bmatrix}Ii&Ij&Ik\\Ji&Jj&Jk\\Ki&Kj&Kk\end{bmatrix}=\begin{bmatrix}i在OXYZ的向量&y在OXYZ的向量&z在OXYZ的向量\end{bmatrix}\triangleq \begin{bmatrix}n&s&a\end{bmatrix}\\约束：|n|=|s|=|a|=1;\,\,l_1\times l_2=l_3(三条);\\因此还剩下三个自由度，正好对应旋转矩阵\\举个例子，1坐标系绕0坐标系z轴逆时针转动，旋转矩阵为：\\^0R_1=\begin{bmatrix}cos&sin&0\\-sin&cos&0\\0&0&1\end{bmatrix}\end{gather*}</script><ul><li><strong>多考虑几何意义，在手算的时候不需要手撕公式，直接看坐标系1三个轴在坐标系0中的坐标，搞成列向量的形式拼在一起就是旋转矩阵。</strong></li><li>两次旋转的两种不同方式：</li></ul><ol><li><p>绕0系某坐标轴转动为1系，1系再绕0系某轴转动为2系：$^0R<em>2=R</em>{(1)}R_{(2)}$</p></li><li><p>绕0系某坐标轴转动为1系，绕1系(自身)某轴转动为2系：$^0R_2=\,^0R_1\,^1R_2$</p></li></ol><ul><li>结论：<strong>绕父坐标系(世界坐标系)旋转，左乘新矩阵；绕自身旋转，右乘新矩阵。</strong></li></ul><h2 id="Representation-of-Orientation"><a href="#Representation-of-Orientation" class="headerlink" title="Representation of Orientation"></a>Representation of Orientation</h2><h3 id="固定角描述法"><a href="#固定角描述法" class="headerlink" title="固定角描述法"></a>固定角描述法</h3><ul><li><strong>RPY Angels</strong>（RPY固定角描述法）：先X，再Y，再Z，全部都默认<strong>绕世界坐标系</strong>转动。<ul><li>R：Roll横滚；P：Pitch俯仰；Y：Yaw侧航。</li><li>$^0R_1=R_Z\,R_Y\,R_X$</li></ul></li></ul><h3 id="欧拉角描述法"><a href="#欧拉角描述法" class="headerlink" title="欧拉角描述法"></a>欧拉角描述法</h3><ul><li><strong>Zxz Eular Angles</strong>：先Z，再x，再z。<ul><li>Z：Precession进动；x：Nutation章动；z：Spin自旋。</li><li>$^0R_1=R_Z\,R_x\,R_z$</li></ul></li><li><strong>RPY Eular Angels</strong>：先X，再y，再z。</li></ul><h2 id="Triple-Angels"><a href="#Triple-Angels" class="headerlink" title="Triple-Angels"></a>Triple-Angels</h2><ul><li>ABC（CBA）Type：$\beta\in(-\frac{\pi}2,\frac{\pi}2)$</li><li>ABA Type：$\beta\in(0,\pi)$</li></ul><p>在$\beta\ne\pm\frac{\pi}2$时的<strong>RPY Angle下的转换公式</strong>：</p><script type="math/tex; mode=display">\beta=-arcsin(r_{31});\gamma=arctan2(r_{32},r_{33});\alpha=arctan2(r_{21},r_{11} )</script><p>在$\beta\ne0 、\pi$时的Eular <strong>Zxz</strong> Angle下的转换公式：</p><script type="math/tex; mode=display">\beta=arccos(r_{33});\alpha=arctan2(r_{13},-r_{23});\gamma=arctan2(r_{32},r_{33})</script><p>为了更好的完成后续内容，<strong>请不要让你的机器人出现$\beta=\pm\frac{\pi}2$的奇异性现象</strong>，否则将无法确认$\alpha,\gamma$的值。</p><p>其中，arctan2是双变量反正切函数，跟arctan基本一样，只是多规定了一下象限，能直接帮你判断象限和具体角度，一般用于编程。</p><h1 id="Forward-Kinematics（正运动学）"><a href="#Forward-Kinematics（正运动学）" class="headerlink" title="Forward Kinematics（正运动学）"></a>Forward Kinematics（正运动学）</h1><h2 id="Position-amp-Orientation-1"><a href="#Position-amp-Orientation-1" class="headerlink" title="Position &amp; Orientation"></a>Position &amp; Orientation</h2><p>旋转矩阵+偏移矢量：$^0r={}^0R_1{}^1r+{}^0d$</p><p><strong>旋转矩阵（非齐次式） ——&gt; 转移矩阵（齐次式）：</strong></p><script type="math/tex; mode=display">\begin{gather*}\begin{bmatrix}{}^0r\\1\end{bmatrix}=\begin{bmatrix}{}^0R_1&{}^0d\\0_{1\times3}&1\end{bmatrix}\begin{bmatrix}{}^1r\\1\end{bmatrix}={}^0T_1\begin{bmatrix}{}^1r\\1\end{bmatrix}\end{gather*}</script><p>其中：</p><script type="math/tex; mode=display">\begin{gather*}^0d=d_{3\times1}=\begin{bmatrix}d_x\\d_y\\d_z\end{bmatrix}\end{gather*}</script><p>同样满足链式法则：$^0T_2={}^0T_1\cdot{}^1T_2$（<strong>绕自身坐标系右乘，绕世界坐标系左乘</strong>）</p><p>但是，与旋转矩阵不同的是，$^0T_1^{-1}={}^1T_0\ne{}^0T_1^T$</p><h2 id="Denavit-Hartenberg-Method"><a href="#Denavit-Hartenberg-Method" class="headerlink" title="Denavit-Hartenberg Method"></a>Denavit-Hartenberg Method</h2><p>一种用于描述几乎所有机械臂运行工作方式的方法理论：find T between link i and link i-1for relative motions given (rotation and geometries of machanical parts，旋转和几何尺寸)</p><ul><li>D-H Parameters：<ol><li>建立坐标系：将 link i 绕着 link i-1 旋转的转轴定义为Z~i~轴，将 link i-1 指向 link i 的方向定义为X轴（$x <em> i=\pm(z </em> {i-1}\times z <em> i)/||z </em> {i <em> 1}\times z </em> i||$）</li><li><strong>连杆偏距d：</strong>前后两个X轴在Z~i-1~轴上的距离。<strong>旋转角$\alpha$：</strong>z~i-1~和z~i~轴的夹角（z~i-1~绕着x~i~旋转）。<strong>连杆长度a：</strong>z~i-1~经过旋转角后（与z~i~平行）与z~i~的距离。<strong>关节角$\theta$:</strong>前后两个X轴，绕Z~i-1~旋转的夹角（可变）。（按照顺序一个一个变换）（如果X/Z轴共线的话，那么d/a长度就是0）</li></ol></li></ul><p><img src="/image/双足01.png" alt=""></p><h2 id="Transformation-Matrix"><a href="#Transformation-Matrix" class="headerlink" title="Transformation Matrix"></a>Transformation Matrix</h2><script type="math/tex; mode=display">\begin{gather*}^{i-1}T_i=\begin{bmatrix}c\theta_i&-c\alpha_is\theta_i&s\theta_is\alpha_i&a_ic\theta_i\\s\theta_i&c\alpha_ic\theta_i&-s\alpha_ic\theta_i&a_is\theta_i\\0&s\alpha_i&c\alpha_i&d_i\\0&0&0&1\end{bmatrix}\end{gather*}</script><p>注：同一个量平移和旋转可交换，两个旋转不可交换</p><h1 id="Inverse-Kinematics（逆运动学）"><a href="#Inverse-Kinematics（逆运动学）" class="headerlink" title="Inverse Kinematics（逆运动学）"></a>Inverse Kinematics（逆运动学）</h1><h2 id="Inverse-Kinematics"><a href="#Inverse-Kinematics" class="headerlink" title="Inverse Kinematics"></a>Inverse Kinematics</h2><p>已知末端点的位姿，求解各个关节角的旋转角度。可能存在两个问题：1）可能没有解析解（但是一般的工程师不会有那么NT给自己设计没有解析解的机械臂）；2）可能有奇异性，即非单一解。</p><p>已知：$^0R_6$和$^0d_6$</p><script type="math/tex; mode=display">\begin{gather*}^0T_6(数据)=\,^0T_3(参数)\,^3T_6(待求)\\^0d_6(数据)=\,^0d_3(参数)+\,^0R_3(参数+待求)\,^3r_6(参数)\Rightarrow\,^0R_3(\theta_{1,2,3})\\^3R_6(待求)=\,^0R_3^T(上面求出来了)\,^0R_6(已知数据)\Rightarrow\,^3R_6(\theta_{4,5,6})\end{gather*}</script><p>最终要求的参数：所有$\theta$角。</p><h1 id="Trajectory-Planning（轨迹规划）"><a href="#Trajectory-Planning（轨迹规划）" class="headerlink" title="Trajectory Planning（轨迹规划）"></a>Trajectory Planning（轨迹规划）</h1><ul><li><p><strong>路径规划：</strong></p><ul><li><p>路径表示关节空间或操作空间中的点或位置，操纵者在执行指定的运动时必须遵循这些点。</p></li><li><p>路径规划的任务是找到一种可行的方法，将起始位置和姿势连接到目标位置和姿势。</p></li><li><p>路径是对运动的纯几何描述，不回答机器人关节如何移动到目标角度的问题。</p></li></ul></li><li><p><strong>轨迹规划：</strong></p><ul><li>轨迹是指定定时定律的路径，例如根据每个点的速度和（或）加速度。</li><li>轨迹规划的任务是生成变量的时间序列，这些变量描述末端执行器相对于所施加的约束随时间的位置和方向</li></ul></li></ul><h2 id="Planning-in-joint-space（关节空间）"><a href="#Planning-in-joint-space（关节空间）" class="headerlink" title="Planning in joint space（关节空间）"></a>Planning in joint space（关节空间）</h2><ul><li><strong>使用三阶多项式：</strong>（常用）</li></ul><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231105100035078.png" alt="image-20231105100035078" style="zoom:50%;" /></p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231105100059282.png" alt="image-20231105100059282" style="zoom:50%;" /></p><ul><li>如果使用五阶多项式，其结果为：（推导略，因为六个自由度，因此最多五阶）</li></ul><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231105100546757.png" alt="image-20231105100546757" style="zoom:50%;" /></p><p>可以参考Ex 5-2 </p><h2 id="Trapezoidal-Velocity-Trajectory（梯形速度轨迹）"><a href="#Trapezoidal-Velocity-Trajectory（梯形速度轨迹）" class="headerlink" title="Trapezoidal Velocity Trajectory（梯形速度轨迹）"></a>Trapezoidal Velocity Trajectory（梯形速度轨迹）</h2><ul><li>通过设置特定的速度和加速度边界，可以用几个低阶多项式代替高阶多项式轨迹。</li><li><p>时间最优轨迹是让关节在所有约束条件下以最大速度工作。</p></li><li><p>从t0-t1-t2-tf，分别是匀加速、匀速（max speed）和匀减速</p></li></ul><p>求解过程看PPT，这里提供结果：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231105102817386.png" alt="image-20231105102817386" style="zoom:50%;" /></p><h2 id="Planning-in-Operational-Space（笛卡尔坐标系）"><a href="#Planning-in-Operational-Space（笛卡尔坐标系）" class="headerlink" title="Planning in Operational Space（笛卡尔坐标系）"></a>Planning in Operational Space（笛卡尔坐标系）</h2><ul><li>考虑到直接运动学引入的非线性效应，关节空间中的规划导致末端执行器的运动不容易预测。</li><li>笛卡尔轨迹规划是规划最自然的应用。只要希望末端执行器运动在操作空间中遵循几何指定的路径，就有必要直接在同一空间中规划轨迹执行。</li><li>规划可以通过插值一系列规定的路径点来完成，也可以通过以准时的方式生成分析运动基元和相对轨迹来完成。</li><li>在这两种情况下，通过反向运动学算法实时利用由操作空间变量获得的值的时间序列来获得关节空间变量的相应值序列。</li></ul><h1 id="Different-Kinematics（微分运动学）"><a href="#Different-Kinematics（微分运动学）" class="headerlink" title="Different Kinematics（微分运动学）"></a>Different Kinematics（微分运动学）</h1><h2 id="Representation-of-Angular-Velocity"><a href="#Representation-of-Angular-Velocity" class="headerlink" title="Representation of Angular Velocity"></a>Representation of Angular Velocity</h2><ul><li>把微分运算转化为代数运算</li></ul><script type="math/tex; mode=display">\begin{gather*}v=\dot p=\omega\times p=\begin{bmatrix}0&-\omega_z&\omega_y\\\omega_z&0&-\omega_x\\-\omega_y&\omega_x&0\end{bmatrix}\begin{bmatrix}p_x\\p_y\\p_z\end{bmatrix}\end{gather*}</script><p>把这个ω的矩阵叫做S(ω)，根据一堆推导，反正最终有：</p><script type="math/tex; mode=display">(记\,^0p=R\,^1p)\,\,\,\,S(\omega)=\dot RR^T\,;\,\dot R=S(\omega)R\,;\,\dot RS(\omega)R^T=S(R\omega)</script><ul><li>在XYZ固定角表示法中，ω与三个旋转角的关系：</li></ul><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231112101055578.png" alt="image-20231112101055578" style="zoom:67%;" /></p><ul><li>罗德里德斯公式：</li></ul><h2 id="Forward-Velocity-Kinematics"><a href="#Forward-Velocity-Kinematics" class="headerlink" title="Forward Velocity Kinematics"></a>Forward Velocity Kinematics</h2><p>已知第i-1个连杆的状态，求第i个连杆的角速度和线速度</p><script type="math/tex; mode=display">\begin{gather*}\omega_i=\omega_{i-1}+\omega_{i}^{i-1}=\omega_{i-1}+R_{i-1}\,^{i-1}\omega_i^{i-1}\\v_i=v_{i-1}+v_i^{i-1}+\omega_i\times r_i^{i-1}\end{gather*}</script><ul><li>直线移动关节和旋转关节，都可以做相应的简化，最后用$\sigma_i$把他们统一起来（$\sigma_i=1\,or\,0$）：<ul><li>旋转关节$\sigma_i=0$，直线移动关节$\sigma_i=1$：</li></ul></li></ul><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231112102304853.png" alt="image-20231112102304853" style="zoom: 67%;" /></p><ul><li>然后他就做了一个我看不懂但是看上去很神奇的操作：</li></ul><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231112103221110.png" alt="image-20231112103221110" style="zoom:67%;" /></p><h2 id="Jacobian-Matrix"><a href="#Jacobian-Matrix" class="headerlink" title="Jacobian Matrix"></a>Jacobian Matrix</h2><p>（雅克比矩阵的含义大致就是全微分的偏导矩阵）：微分运动学给出了关节速度与相应末端执行器的线性和角速度之间的映射，该映射由一个矩阵描述，该矩阵称为几何雅可比，取决于操纵器配置。</p><script type="math/tex; mode=display">\begin{gather*}X=[x,y,z,\alpha,\beta,\gamma]^T=\dot T(q)=\begin{bmatrix}T_1(x,y,z,\alpha,\beta,\gamma)\\\dots\\T_6(x,y,z,\alpha,\beta,\gamma)\end{bmatrix}\Rightarrow\dot X=\frac{\partial T(q)}{\partial q}\dot q\end{gather*}</script><p>将其一分为二：</p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231112105236736.png" alt="image-20231112105236736" style="zoom:50%;" /></p><ul><li>反正经历了一堆推导，得到：$J<em>{Di}=\overline{\sigma_i}z</em>{i-1}\times(p<em>i-p</em>{i-1})+\sigma<em>iz</em>{i-1}$，$J<em>{Ri}=\overline{\sigma_i}z</em>{i-1}$</li></ul><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231112105627770.png" alt="image-20231112105627770" style="zoom:67%;" /></p><p><img src="C:\Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20231112105748901.png" alt="image-20231112105748901" style="zoom:50%;" /></p><h2 id="Kinematic-Singularites（奇点）"><a href="#Kinematic-Singularites（奇点）" class="headerlink" title="Kinematic Singularites（奇点）"></a>Kinematic Singularites（奇点）</h2><h2 id="Inverse-Velocity-Kinematics"><a href="#Inverse-Velocity-Kinematics" class="headerlink" title="Inverse Velocity Kinematics"></a>Inverse Velocity Kinematics</h2><p>​        利用齐次逆变换矩阵的导数导出上述运动学问题，最终会成为需要求解向量代数方程的首要问题，而向量代数方程不是系统的。因此，上述运动学基本上是通过雅可比矩阵求解的。</p><h1 id="电机驱动"><a href="#电机驱动" class="headerlink" title="电机驱动"></a>电机驱动</h1><ul><li>现在常用的电机调速原理：PWM调制<ul><li>动力源直接给电机供电，串联高速开关S，将供电的连续电流离散化。当开关频率极高（远高于电机响应速度时），可以忽略其对稳定性的影响</li></ul></li></ul><p>等效电压：$U_d=DU$</p><p>减速器，传感器，电机</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> ACEE </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于Git和gitee的协同开发</title>
      <link href="/2026/02/24/%E5%9F%BA%E4%BA%8EGit%E5%92%8Cgitee%E7%9A%84%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91/"/>
      <url>/2026/02/24/%E5%9F%BA%E4%BA%8EGit%E5%92%8Cgitee%E7%9A%84%E5%8D%8F%E5%90%8C%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="下载与安装"><a href="#下载与安装" class="headerlink" title="下载与安装"></a>下载与安装</h1><p>​    翻墙，进入Git官网下载对应版本并安装，需要同Vscode下载在同一台电脑上。安装完成后于桌面右键→Git Bash Here，若成功打开命令窗口则环境配置成功。</p><p>​    Git 是一个分布式的代码托管工具，其<strong>工作流程</strong>如下：</p><p><img src="\image\git1.png" alt=""></p><p>其中：</p><ol><li>Working Directory (工作区)：我们编辑与变动的代码文件，都在工作区下；</li><li>Stating Area (缓存区)：代码有变动的时候，我们可以把每次变动后的代码，提交到 git 缓存区。让 git 记录代码的变动；</li><li>Respository (仓库)：在 git 缓存区的代码，都可以提交到 git 仓库进行托管。从图中可以看到，本地的仓库（一般指PC）可以将代码提交到远程的仓库（一般指 git 服务器，如github和国内的gitee）。</li></ol><p><strong>一般工作流程：</strong>本地配置Git仓库→编写代码→提交到本地仓库（一般指PC）→提交到远端仓库（此处以gitee为例）→从远端仓库下载最新的代码→循环</p><ul><li>本文中，<strong>第二章的内容主要用于让读者产生一个对git的全工作流程有一个简单的认识，通过bash对git的操作，从零开始新建test项目加深对齐理解。在第三章中主要介绍如何通过VSCode和gitee管理git项目，是一种比较常用的项目管理和协作方式</strong>。</li><li>跳过第二章的内容不会对第三章和后续使用产生较大的影响（在了解过前文所述的工作流程的基础上），但若时间充裕可以尝试一下新建项目的流程。</li></ul><h1 id="从零开始新建项目全流程"><a href="#从零开始新建项目全流程" class="headerlink" title="从零开始新建项目全流程"></a>从零开始新建项目全流程</h1><p><strong>以下内容建议使用新的test来进行尝试，不要第一次上手就在成型的库里操作，以免打乱文件</strong></p><h2 id="Git初始化与建立远端连接"><a href="#Git初始化与建立远端连接" class="headerlink" title="Git初始化与建立远端连接"></a>Git初始化与建立远端连接</h2><p>​    在PC工作区新建一个文件夹用于存放该项目的所有代码，在文件夹内执行右键→Git Bash Here进入Git命令窗口。输入<code>git.init</code>。观察到工作区内新增隐藏文件夹<code>.git</code>。</p><p>​    命令窗口输入以下代码进行基本配置。本地账户可以任意设置，与远端关系不大。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;&lt;myUserName&gt;&quot;</span>   // &lt;&gt;内表示自行命名</span><br><span class="line">git config --global user.email <span class="string">&quot;&lt;xxxx@qq.com&gt;&quot;</span> // 可以是其他邮箱</span><br></pre></td></tr></table></figure><p>​    此时已经完成Git的初始化和基本配置，下面开始建立远端仓库连接。在网页端打开gitee并登录（注册），在右上角的“+”中选择新建仓库，并命名为<code>test1</code>。方便起见，这里都采用HTTPS的方式进行连接（SSH连接需要额外配置）。</p><p>​    复制该仓库的HTTPS地址，比如<code>https://gitee.com/akribis/test1.git</code>。在命令窗口中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://gitee.com/akribis/test1.git</span><br></pre></td></tr></table></figure><p>​    若没有报错，则认为远端连接建立完成。</p><h2 id="缓存、提交与推送"><a href="#缓存、提交与推送" class="headerlink" title="缓存、提交与推送"></a>缓存、提交与推送</h2><p>​    代码上传的过程共分为三步——缓存、提交与推送，分别是代码（文件）经历本地工作区、缓冲区、本地仓库、远端仓库的过程。</p><ol><li><p><strong>缓存add（本地工作区→缓冲区）</strong></p><p>​    在本地工作区新建一个文件（以<code>README.md</code>和<code>test1.m</code>为例），或者在本地工作区中对某个文件的内容进行了改动，需要在命令窗口进行如下操作（两种方法任选其一）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// method 1</span><br><span class="line">git add README.md</span><br><span class="line">git add test1.m</span><br><span class="line">// method 2</span><br><span class="line">git add .</span><br></pre></td></tr></table></figure><p>​    其中，<code>git add .</code>表示缓存所有内容，无需一个个操作。</p></li><li><p><strong>提交commit（缓冲区→本地仓库）</strong></p><p>​    缓冲区仅用于记录更改，真正的托管需要在本地仓库中完成，操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;&lt;first commit test&gt;&quot;</span></span><br></pre></td></tr></table></figure><p>​    其中<code>&lt;&gt;</code>的内容表示版本说明，本次更新增加、删减了哪些内容</p></li><li><p><strong>推送push（本地仓库→远端仓库）</strong></p><p>​    在建立过于远端仓库的连接的基础上，可以通过以下代码进行推送（同步）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push -u origin master // 将本地当前的master分支提交远端master</span><br></pre></td></tr></table></figure><p>​    如果未在git上登录远端仓库gitee，会自动弹出gitee的登录框，输入gitee账号的账户与密码登录即可。可以在gitee上的仓库中看到，里面多了<code>README.md</code>和<code>test1.m</code>两个文件。</p></li></ol><h2 id="远端同步与分支"><a href="#远端同步与分支" class="headerlink" title="远端同步与分支"></a>远端同步与分支</h2><p>​    在其他同事更改完各自的代码并上传后，你需要更新你的本地仓库，这个将远端仓库的代码下载到本地的过程称之为<strong>同步</strong>，代码为<code>pull</code>。示例如下：</p><p>​    在远端仓库gitee中新建一个<strong>分支</strong>，命名为<code>Develop</code>，选择从<code>master</code>中创建。分支的意义是不同开发人员对同一个项目在不同内容方向上独立工作，互不干扰。每个分支都从主分支上克隆，多个开发人员基于不同分支并行开发（在分支上进行测试以确保代码无误），完成后再合并到主分支（这一步由管理员进行）。</p><p>​    回到同步，你可以在gitee上对新的Develop分支进行内容的修改，比如打开<code>README.md</code>输入一段随机字符串。这时这些修改在你的本地仓库PC上是未发生的（这一点可以通过在命令窗口中输入<code>git branch</code>得到，此时应该只有<code>master</code>分支），因此需要同步。在命令窗口中输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>​    此时会显示<code>Already up to data</code>（或者可能是其他的内容），而明明远端仓库要更加新一点。这是因为两端分支不同步导致的。你需要在PC上新建<code>develop</code>分支，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout develop</span><br></pre></td></tr></table></figure><p>​    <code>git checkout</code>是切换分支的命令，这个时候（在之前已经执行过<code>pull</code>的基础上）它会自动帮你创建一个新分支<code>develop</code>并且和远端仓库关联（可以通过<code>git branch</code>命令验证）。如果希望验证该关联性，可以新建一个文件，再执行一边缓存、提交和推送的完整过程，观察gitee上是否有正确地更新。</p><p>​    如何在本地观察当前分支呢？在工作区中打开命令窗口并使用<code>git branch</code>可以看到当前分支。此时使用<code>git checkout</code>命令则可以切换到另一个分支当中。如果两个分支中的文件不同，你会惊人的发现你的工作区（即文件夹中）的文件变了，如图：</p><p><img src="\image\git2.png" alt=""></p><p>​    这里你也许已经发现使用命令窗口进行git配置非常麻烦：不可视化、文件管理仍然混乱、容易进到别的分支当中去而不自知。</p><p>​    <strong>以上内容主要是为了了解、熟悉Git的原理和操作，下面来讲解如何在VSCode中进行使用和同步。</strong></p><h1 id="基于VSCode的同步"><a href="#基于VSCode的同步" class="headerlink" title="基于VSCode的同步"></a>基于VSCode的同步</h1><h2 id="创建VSCode与gitee的连接"><a href="#创建VSCode与gitee的连接" class="headerlink" title="创建VSCode与gitee的连接"></a>创建VSCode与gitee的连接</h2><p>​    VSCode在安装时默认会带有git管理的插件，图标是用曲线连接的三个点，可以通过<code>Ctrl Shift G</code>调出来。点击“初始化仓库”即可自动创建git，相当于<code>git init</code>。</p><p>​    通过下图图示操作添加远程库，在上方的URL框中输入gitee项目的链接（以<code>.git</code>结尾的URL），命名就是前文最早在<code>git config</code>中的命名，没有很深的含义。</p><p><img src="\image\git4.png" alt=""></p><p>​    如下图所示，进行个人分支的选择和拷贝。可以直接在gitee网站上新建分支（最好是以自己的名字或分支功能命名），然后直接在这里选择“远程分支”；当然也可以在这里直接新建分支，然后把原分支的内容拷贝过来。这里以前者为例：</p><p><img src="\image\git5.png" alt=""></p><p>​    <strong>以后，左下角的这个标识就是你当前更改、上传、同步的分支。请时刻确保你更改的是自己的分支内容。</strong></p><h2 id="缓存、提交与推送-1"><a href="#缓存、提交与推送-1" class="headerlink" title="缓存、提交与推送"></a>缓存、提交与推送</h2><p>​    还记得git的工作逻辑吗？缓存、提交与推送。这里一一演示。</p><ul><li><strong>缓存：本地工作区→缓冲区</strong></li></ul><p>​    图标右下角的“3”是指本次一共经过了三次修改，其中M/U/D分别表示修改/新建和删除。本地工作区和缓冲区就对应图中的“更改”和“暂存的更改”——所以缓冲区的本质就是暂存。<strong>这一步可以直接通过点击“更改”栏右边的“+”完成。</strong></p><p><img src="\image\git6.png" alt=""></p><ul><li><strong>提交：缓冲区→本地仓库</strong></li></ul><p>​    提交的英文是Commit，这一步一个非常关键的步骤就是需要在提交的时候同时上传“提交说明”，来简述这次提交干了些什么事情。单击提交之后，VSCode会自动生成一个提交说明的文件，自动生成了本次提交的修改内容，需要在第一行中进行一些简单的说明。写完后点击右上角的“√”进行提交。</p><p><img src="\image\git7.png" alt=""></p><ul><li><strong>推送：本地仓库→远端仓库</strong></li></ul><p>​    推送的操作可以直接点击同步（这个命名不好，同步应该是从远端下载）或者右键…选择推送。可以在gitee上看到新的推送内容（在对应的分支中）。</p><p><img src="\image\git8.png" alt=""></p><h2 id="远端同步"><a href="#远端同步" class="headerlink" title="远端同步"></a>远端同步</h2><p>​    有的时候，需要将你的代码更新为远端仓库中的版本。比如主支、主函数中更新了某些影响开发的重要内容（即存在改动A），而你上一次的开发尚未完成（即存在改动B），你显然希望同时保留两个修改：</p><ol><li><p>假设现在你的本地仓库和远端仓库是一致的（当然好像不一致也没什么关系）</p></li><li><p>当你的远端仓库落后于主支时，会出现如下合并按钮：选择同步代码中的丢弃提交，这样你的远端仓库就会变成和主支一样（仅有更改A），如下：</p><p><img src="\image\git9.png" alt=""></p></li><li><p>为了保险起见，在第一次操作时可以为你的本地仓库创建一个copy</p></li><li><p>在VSCode上直接选择拉取（Pull），这样就能直接把远端仓库中的内容同步到本地。他会<strong>自动帮你兼容更改A和B</strong>：当A和B在不同文件中，或者同一个文件中的不同行、段落中时同时保留，当更改A和B在同一行时会产生冲突，VSCode会要求你主动选择保留哪一个。这个自动兼容又好又不好，hh。</p></li></ol><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>​    当你的某一段开发完成之后，需要将其丢到主支上。但是为了不影响其他人的开发并且保证准确性，一般来讲要求先把你的程序丢到一个Test分支中，当测试通过之后再合并到主支main。这个test分支一般由测试工程师管理（啊是的，这就是为什么开发和测试天天吵架的原因，因为测试是合并到main的最后一道保障，要是出了什么问题都得他担着）。</p><p>​    合并需要你先把代码推送到远端仓库中（参考上面的缓存、提交和推送），然后打开gitee，在你自己的分支中<strong>创建<code>Pull Request</code>，选择从自己的仓库同步到<code>test</code>分支中</strong>，输入一点说明，等待leader通过即可。</p>]]></content>
      
      
      <categories>
          
          <category> 软件教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大三（秋冬）课程总结</title>
      <link href="/2026/02/24/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
      <url>/2026/02/24/%E5%A4%A7%E4%B8%89%E4%B8%8A%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="课程总结"><a href="#课程总结" class="headerlink" title="课程总结"></a>课程总结</h1><h2 id="微机原理与应用"><a href="#微机原理与应用" class="headerlink" title="微机原理与应用"></a>微机原理与应用</h2><p>​        说实话，这门课的教学大纲太离谱了。这门课有闫老师和徐习东老师两个教学班，但是两个班上课的内容千差万别。一些基础知识是重合的，但是一些补充知识（闫老师班好像教了ECAN等内容，徐习东老师教了汇编）、实验课程内容、教学方式和上课顺序等等都完全不一样。这里由于我上的是徐习东老师班的微机，所以只能讲一讲徐习东老师班的感受。</p><p>​        他上课给人最大的印象就是喜欢对着一张原理图叭叭十几分钟，然后他的PPT上面就是零散地几个标题和内容，如果不听他讲课就完全无法理解；但是他讲课又很慢，很想让人睡觉玩手机，特别喜欢举一些奇怪的、生活化的例子来“帮助”我们理解。</p><p>​        如果除去他让人难以理解的讲课，他人还是挺好的，整体难度比较简单（是的，这两个班的教学难度也完全不一样）。实验课的任务都比较轻松，上课也会简单过一遍下一次实验课的代码，一个学期也只有三个实验报告。实验考试是允许使用以前自己使用过的代码的，而实验考试的内容也就是把平时实验的任务稍微改改格式（一般都是八段数码管显示时钟+非常简单的键盘响应），一般三、五分钟就能做完。听说闫老师班的实验考试就比较难了。</p><p>​        徐习东老师班的这门课比较难的可能就是一个大作业，我们是要求写中断向量表的定义、涉及到的函数等等，共3000字。想了想这个东西我还是不发出来了，不然肯定会被抄。在最后一节实验课上完之后，临近期末考的时候，徐习东老师才会开始讲CPU和汇编，这三四节课的内容反而是考试的重点，非常离谱。这部分的笔记我都放在“微机原理课外知识补充”里面了。</p><h3 id="复习资料"><a href="#复习资料" class="headerlink" title="复习资料"></a>复习资料</h3><ul><li><p>以下的资料大部分来自98，请尊重原作者的知识版权</p><ul><li><p><a href="\myfile\《微机原理与应用》思考题.pdf" target="_blank">《微机原理与应用》思考题</a></p></li><li><p><a href="\myfile\21-22.pdf" target="_blank">21-22年回忆卷</a></p></li><li><p><a href="\myfile\21-22答案纠错版.pdf" target="_blank">21-22回忆卷答案（我写的）</a></p></li><li><p><a href="\myfile\DSP2812清华版复习资料.doc" target="_blank">DSP2812思考题</a></p></li></ul></li><li><p>考试的内容不难，题型如下</p></li></ul><ol><li>填空题12选8，每道题2个空</li><li>简答题4选2，每题6分（徐习东老师的题有一个一般固定是汇编程序阅读，要求说明该段汇编程序执行完之后的结果）</li><li>程序阅读题2选1（徐习东老师的题是汇编语言，一般也不难，就是加减乘除+寻址；闫老师的题我没细看，大概是ADC程序的初始化设置阅读题）</li><li>程序设计题2选1（徐习东老师的题是CMD文件的编写+变量的定义，跟21-22回忆卷的题5-1几乎一样；闫老师的题好像是EV的初始化填空吧，给要求然后填写部分初始化数值）</li><li>C语言程序设计题（中断程序编程，按要求手搓代码，包括main、CPU中断，跟21-22回忆卷的题5-2很像）</li></ol><h2 id="电力系统稳态分析"><a href="#电力系统稳态分析" class="headerlink" title="电力系统稳态分析"></a>电力系统稳态分析</h2><p>​        怎么说呢，这门课很建议选林振智老师的班…实在不行选甘德强，这grp我是真受不了，上课=原封不动念PPT，PPT=原封不动抄书。后来我就溜到隔壁去了，林振智老师讲的还是很有激情的，至少能让你搞懂什么是重点，但是可能进度会比较慢，而且有点口音（比如三相交流电的“线”和“相”我老是听不出区别）。</p><p>​        这门课一开始学起来会有点害怕，因为作业很难，计算量也非常大，课本里有很多全新的公式和概念。但是记住一件事，就是很多东西都不考！比如长距离输电线模型，前面数学推导一大堆，实际上只要看下记住结论，甚至金奈力系数一般也都不出。比如牛顿-拉夫逊法解方程，比如PQ分解法等等，都只需要掌握原理和概念即可，因为考试根本不可能让你去手撕这么高阶的方程和行列式！而且手算潮流的迭代也不会太多，不然时间都画在计算上了。</p><p>​        然后考卷里我记得有很多选择题，都是书上比较细节的东西，可能属于概念性的内容。考前务必通读一遍课本，然后找找这些定义啊、概念啊之类的东西。后面的计算题lzz还是出的过于简单了，气煞我也，计算题拉不开分差，选择题很多都靠蒙，最后分数自然也没多高了。</p><h2 id="控制理论"><a href="#控制理论" class="headerlink" title="控制理论"></a>控制理论</h2><p>​        控制理论的回忆卷可以在98搜“2022~2023秋冬《控制理论 (乙)》回忆卷”，然后还有一个<a href="\myfile\控论1617.pdf" target="_blank">控论16-17回忆卷</a>。前面98那张感觉一般，可能由题目他数据回忆错了，看看思路吧。感觉把书本通读一遍，然后把课后题再做一遍也是一个不错的选择。</p><p>​        非常不幸地这门课没有选到姚维老师班，ww这个老登真的服，上课不知道在讲啥，钉钉群不会建，班级不管，课程的成绩分布也不知道。还信誓旦旦地说我从来不点名，然后我就被背刺。我从第二节课开始就溜到姚维老师班去了，讲的是真好，上课氛围也很轻松。</p><p>​        这门课我感觉还是比较简单的，如果信号分析与处理学得好的话。然后多去总结内在的联系，多去了解原理，不要拘泥于表象。静态性能、动态性能，这些都和什么有关？怎样让一个系统变得更好？这些都搞明白之后，最后的校正就会好做很多。然后考试和写题要注意什么时候用开环系统分析，什么时候用闭环系统分析，一定要搞清楚，因为这很重要。</p><h2 id="电机学"><a href="#电机学" class="headerlink" title="电机学"></a>电机学</h2><p>​        电机学这门课我还真没怎么听到说哪个老师特别离谱。电机学总体难度确实还是有的，但是也没有被传的那么夸张，学的过程中因为全都是新知识，对模型也不清晰，所以会有些一头雾水。但是每隔一两周稍微总结一下学到的知识，把一些推导什么的去掉，去关心最后总结出来的模型就清晰了，直接用模型来代替电机，然后再把功率的流向弄懂，基本上掌握了电机学的80%了。</p><p>​        考试的题型是10分的选择题，20分的填空题，30分的简答题（6题，5分一题），40分的计算题（4题，10分一题，直流电机、变压器、异步电机、同步电机各一题）。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电气学院大二（秋冬）课程资料整理（部分）</title>
      <link href="/2026/02/24/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E7%AD%94%E6%A1%88/"/>
      <url>/2026/02/24/%E5%A4%A7%E4%BA%8C%E4%B8%8A%E7%AD%94%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​    有人求大二上学期的课程资料，这里找一下能找到的。不定期更新（低情商：不催我就不更新）。</p><h2 id="电路与电子技术1"><a href="#电路与电子技术1" class="headerlink" title="电路与电子技术1"></a>电路与电子技术1</h2><p>​    这门课确实比较难，题目做不出来很正常（也可能是我菜）……放平心态慢慢来。</p><p>链接：<a href="https://pan.baidu.com/s/1SP5zCHrkOmlj61kzHusenw">https://pan.baidu.com/s/1SP5zCHrkOmlj61kzHusenw</a><br>提取码：pvez<br>—来自百度网盘超级会员V4的分享</p><p>​    这个文件太大了，上次传超过100MB的文件让我网站崩了整整大半天，百度网盘凑活用一下。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大二 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 课程资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工程原理</title>
      <link href="/2026/02/24/%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86/"/>
      <url>/2026/02/24/%E5%B7%A5%E7%A8%8B%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="工程原理"><a href="#工程原理" class="headerlink" title="工程原理"></a>工程原理</h2><p>上课反正是听不懂一点，真就纯念PPT</p><hr><ul><li>百度网盘版本</li></ul><p>链接：<a href="https://pan.baidu.com/s/1aQJflqAabJoZLQNV5GvLcg">https://pan.baidu.com/s/1aQJflqAabJoZLQNV5GvLcg</a></p><p>提取码：z7gx</p><p>—来自百度网盘超级会员V4的分享</p><ul><li>网页链接</li></ul><p>（寄了，文件太大传不了）</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 大二 </tag>
            
            <tag> ACEE </tag>
            
            <tag> 课程资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微机原理课本外知识点补充</title>
      <link href="/2026/02/24/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E8%AF%BE%E6%9C%AC%E5%A4%96%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/"/>
      <url>/2026/02/24/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E8%AF%BE%E6%9C%AC%E5%A4%96%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="微机原理补充"><a href="#微机原理补充" class="headerlink" title="微机原理补充"></a>微机原理补充</h1><ul><li><strong>整理了PDF版本，内容跟下面差别不大，好处是可以打印而且不会出现渲染问题</strong><ul><li><a href="\myfile\微机原理补充.pdf" target="_blank">微机原理补充PDF版</a></li></ul></li><li>在这里推一个98帖子：<ul><li>【E电园】徐习东老师DSP_电子笔记及一些资料分享 <a href="https://www.cc98.org/topic/4751962">https://www.cc98.org/topic/4751962</a> 复制本链接，打开【CC98】微信小程序，直接查看本帖！</li></ul></li></ul><h2 id="CPU模块"><a href="#CPU模块" class="headerlink" title="CPU模块"></a>CPU模块</h2><h3 id="CPU寄存器"><a href="#CPU寄存器" class="headerlink" title="CPU寄存器"></a>CPU寄存器</h3><p>​        2812芯片大体上分为：中央处理单元（CPU），存储器和外设。其中的CPU寄存器如下（大致）：</p><pre>CPU寄存器   |- 读写改集成的累加器模块 ALU           |- 加法器 ACC(32) = AH(16) + AL(16)   |- 32位乘法器模块               |- 乘数寄存器(暂存) : XT              |- 乘法寄存器(结果) : P(32) = PH(16) + PL(16)   |- 辅助寄存器模块 ARAU(32) : 地址寄存器算术单元             |- 辅助寄存器 AR(8个×32位) : XARn (n=0~7) = 高16位 + ARn (低16位)             |- 数据页指针 DP(16) : 直接寻址(22,4M) = DP(16) + 偏移量(6)   |- 堆栈指针 SP(16) : 偏移量小于64, 只能访问[0,0xffffH]低地址空间单元, 复位0x0400   |- 程序计数器 PC : 总是包含到达D2阶段指令的地址   |- 指令计数器 IC : 装入下一条指令的地址, 保持到下个D2阶段   |- 状态寄存器 ST0/ST1              |- 溢出位 V (Overflow): 1为有溢出, 用于判断有符号运算是否出错                                    溢出一旦置位不会被下一次运算清除，会一直保留                                    比较运算CMP不会溢出（因为溢出的要求是“存入寄存器”）              |- 进位/借位位 C (Carry): 用于判断无符号数高低, 对有符号数而言不重要                          |- 0 : 无进位/有借位                          |- 1 : 有进位/无借位              |- 负标志位 N (Negative): 1为有负数产生,用于有符号数判断大小                          CMP比较时，看计算结果的真实值（不怕溢出）                          SUB减法时，看计算机操作、存储的结果，默认读最高位              |- 零标志位 Z (Zero): 1为有0产生              |- 符号扩展模式位 SXM : 0-无扩展, 1-符号扩展              |- (ST1) - 辅助寄存器指针 ARP    |- 其他 (如中断控制寄存器IFR,IER等)</pre><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><p>​        2812的存储器空间被分为了两大块：程序空间（P）和数据空间（D）。</p><p>​        访问任一空间，都需要两种总线配合：地址总线（A）和数据总线（D），前者终于传送存储单元的地址，后者用于传送存储单元的具体内容。</p><ul><li>下面对英文缩写做一点简单的说明：</li></ul><pre>    P : Program 程序(空间)    A : Address 地址(总线)    D : Data    数据(空间或总线)    R/W : Read/Write 读取/写入 省略表示两者均可    B : Base 总线</pre>![](\image\微机01.png)* 下面就是2812CPU对存储空间内数据的调用的过程<pre>        存储空间         程序空间P              数据空间D                           |               |-----|-----|                           |               |           |        地址总线A         PAB(22)        DWAB(32)     DRAB(32)                           |-------|      |            |                               |       |------|            |        数据总线D         PRDB(32)      D/PWDB(32)    DRDB(32)</pre><p>可以看到：</p><ol><li>一共有6跟总线，三根数据总线，3根地址总线</li><li>地址总线A少一根的原因是程序空间P的读写共用一根总线（因此程序的读写不能同时进行）</li><li>数据总线D少一根的原因是程序、数据空间共用一根总线进行数据的写入</li></ol><h3 id="指令流水线"><a href="#指令流水线" class="headerlink" title="指令流水线"></a>指令流水线</h3><p>2812的指令流水线大体上遵循一下几点规则：</p><ol><li>一条指令最多分8步完成</li><li>每一步都要一个时间间隔完成</li><li>同一时间最多可能有8条指令在执行</li><li>步与步之间可能会插入间隔（如当此步需要用到上一步的结果，就会等待）</li></ol><p>流水线的8步分别为：</p><pre>    获取指令地址 ——> 获取指令内容 ——> 对指令进行解码 ——> 解析操作数地址 ——> 锁定操作数地址 ——> 获取操作数 ——> CPU执行'real work' ——> 将结果存入到内存</pre><h2 id="2812指令系统——寻址"><a href="#2812指令系统——寻址" class="headerlink" title="2812指令系统——寻址"></a>2812指令系统——寻址</h2><h3 id="寻址的基本操作"><a href="#寻址的基本操作" class="headerlink" title="寻址的基本操作"></a>寻址的基本操作</h3><p>​        2812采用增强型哈佛总线结构，能够并行的访问地址和数据存储空间，其寻址的范围为 <code>[0,0x3fffff]</code> （即2^22^=4M）。介绍寻址之前，大致先了解一下 <code>MOV</code> 指令，大意就是：<code>MOV A B</code> 近似于把B放到A里面，这也是最重要的汇编语言之一。</p><p>​        寻址方式大致上的分类有以下3种：</p><div class="table-container"><table><thead><tr><th>寻址方式</th><th>含义</th><th>写法</th></tr></thead><tbody><tr><td><strong>立即寻址</strong></td><td>直接对应数字本身</td><td>#</td></tr><tr><td><strong>直接寻址</strong></td><td>某一个单元格内对应的数字</td><td>@</td></tr><tr><td><strong>间接寻址</strong></td><td>指向某个单元的指针对应的单元中的数字</td><td>*</td></tr></tbody></table></div><p>​        下面介绍一些常用的寻址方法及其写法（下文中 <code>loc16</code> 表示任一16位的地址/数据存储单元）：</p><ol><li><p><strong>立即数寻址</strong>（把数据送到寄存器）</p><ol><li>数据不能太大，一般为16bit，只有XAR可以接受22bit的数据</li><li>ACC不能直接接受更多位的立即数</li></ol></li></ol>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MOVL XARn, #<span class="number">22b</span>it</span><br><span class="line">MOVW DP, #<span class="number">16b</span>it</span><br><span class="line">MOVW DP, #<span class="number">16b</span>it &gt;&gt; <span class="number">6</span></span><br><span class="line">MOV SP, #<span class="number">16b</span>it</span><br><span class="line">MOV ACC, #<span class="number">16b</span>it</span><br></pre></td></tr></table></figure><ol><li><p><strong>偏移量直接寻址</strong>（DP的使用，好用的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVW DP, #<span class="number">0x3F9000</span> &gt;&gt; <span class="number">6</span>   <span class="comment">// 把3F9000“赋值”给DP</span></span><br><span class="line">MOV @<span class="number">4</span>, #<span class="number">16b</span>it          <span class="comment">// 偏移量=4，把某个数16bit“赋值”给3F9004单元</span></span><br></pre></td></tr></table></figure><p>因为DP寻址方式是用16位DP“并上”6位偏移量来实现的，因此为了避免繁杂的计算，在给DP输入时要把 <code>0x70D4</code> 右移6位，直接移到偏移量的位置上，就可以把“并”换成简单的加法。</p></li><li><p><strong>堆栈间接寻址</strong>（SP的使用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV SP, #<span class="number">0x70DF</span>         <span class="comment">// 把70DF“赋值”给SP</span></span><br><span class="line">MOV *-SP[<span class="number">5</span>], #<span class="number">16b</span>it      <span class="comment">// 偏移量=-5，*表示C语言的指针，把某个数16bit“赋值”给70DA单元</span></span><br></pre></td></tr></table></figure><p>SP就是只能用负的偏移量，也就是 <code>-SP[n]</code>；</p><p>其中 <code>n=#6bit</code> ，即 $n\le2^6-1=63$</p></li><li><p><strong>寄存器间接寻址</strong>（AR/XAR的使用）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOVL XAR6, #<span class="number">0x70D0</span>       <span class="comment">// 把70D0“赋值”给XAR6</span></span><br><span class="line">MOV *+XAR6[<span class="number">4</span>], #<span class="number">16b</span>it    <span class="comment">// 偏移量=4，把某个数16bit“赋值”给70D4单元</span></span><br></pre></td></tr></table></figure><p>AR/XAR就是只能用正的偏移量，也就是 <code>+XARn[m]</code>；</p><p>其中 <code>m=#3bit</code>，即 $m\le2^3-1=7$</p><p>上述方法2/3/4的第二行都属于 <code>MOV loc16 #16bit</code> 的形式</p></li><li><p><strong>寄存器直接寻址</strong>（说实话我看不太懂）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVL ACC, @XAR2        <span class="comment">// MOV AX, loc16</span></span><br><span class="line">MOVL @<span class="number">6</span>, ACC          <span class="comment">// MOV loc16, AX</span></span><br><span class="line">MOVL T, @AL           <span class="comment">// MOV loc16, AX</span></span><br></pre></td></tr></table></figure><p>ACC(32)=AH(16)+AL(16)，这里用AX指代AH或AL中的任意一个，是汇编里面比较特殊的一个量</p><p>AL的目的之一就是作为中转站，来代替被禁止的 <code>MOV loc16 loc16</code></p></li><li><p><strong>空间立即寻址</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV *(<span class="number">0</span>:<span class="number">16b</span>it),loc16     <span class="comment">// 这个是通式</span></span><br><span class="line">MOV *(<span class="number">0</span>:<span class="number">0x70D4</span>), @AX     <span class="comment">// 这个是例子</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>以下是两种被<strong>禁止</strong>的寻址写法：<ul><li><code>MOV loc16 loc16</code>，代表为：<code>MOV DP XAR</code>，但是 <code>ACC(AH/AL)</code> 除外</li><li><code>MOC *(0:0x16bit), #16bit</code>，代表为：<code>MOV *(0:0x70D4), 0xFF00</code></li></ul></li><li>一般对于 <code>MOV A B</code> 而言，若A/B表示寄存器（DP，XAR等）时，A中不加@，B中加@（大部分情况下）</li></ul><h3 id="寻址例程"><a href="#寻址例程" class="headerlink" title="寻址例程"></a>寻址例程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Gpfmux=0xF0FF (Gpfmux地址为0x70D4) </span></span><br><span class="line"><span class="comment">/* Code 1 */</span></span><br><span class="line">MOVW DP,#<span class="number">0x01C3</span>    <span class="comment">// 01C3 = 0000 0001 1100 0011</span></span><br><span class="line">MOV @<span class="number">20</span>, #<span class="number">0xF0FF</span>   <span class="comment">// 01C3 &amp; 20 = 00 0000 0111 0000 1101 0100</span></span><br><span class="line"><span class="comment">/* Code 2 */</span></span><br><span class="line">MOV AL,#<span class="number">0xF0FF</span> </span><br><span class="line">MOV *(<span class="number">0</span>:<span class="number">0x70D4</span>),@AL  <span class="comment">// 利用中间变量AL进行空间立即寻址</span></span><br><span class="line"><span class="comment">/* Code 3 */</span></span><br><span class="line">MOVL XAR2,#<span class="number">0x70D0</span> </span><br><span class="line">MOV *+XAR2[<span class="number">4</span>],#<span class="number">0xF0FF</span></span><br></pre></td></tr></table></figure><h2 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h2><h3 id="常用汇编语言"><a href="#常用汇编语言" class="headerlink" title="常用汇编语言"></a>常用汇编语言</h3><ol><li><p><strong>传送指令</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV / MOVL (<span class="number">32b</span>it) / MOVW (专用于DP) / MOVU (高位<span class="number">0</span>扩展，常用于ACC)</span><br></pre></td></tr></table></figure></li><li><p><strong>简单指令集</strong>（AX=AH或AL）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 加法 */</span> ADD AX, loc16  <span class="comment">// AX = AX + loc16</span></span><br><span class="line"><span class="comment">/* 减法 */</span> SUB AX, loc16  <span class="comment">// AX = AX - loc16</span></span><br><span class="line"><span class="comment">/* 比较 */</span> CMP AX, loc16  <span class="comment">// 根据比较结果置位，但不会改动数值</span></span><br><span class="line">       <span class="comment">// 如置零位ZF，符号位SF</span></span><br><span class="line"><span class="comment">/* 与 */</span>  AND AX, loc16  <span class="comment">// AX = AX &amp; loc16</span></span><br><span class="line"><span class="comment">/* 或 */</span>  OR AX, loc16   <span class="comment">// AX = AX | loc16</span></span><br><span class="line"><span class="comment">/* 取反 */</span> NEG AX, loc16  <span class="comment">// AX = -AX</span></span><br></pre></td></tr></table></figure><p>上面的指令后面多一个B表示短指令，如<code>ANDB AX #8bit</code></p></li><li><p><strong>移位指令</strong>（可以代替以2为倍数的乘除法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LSL AX, #<span class="number">16b</span>it  <span class="comment">// 逻辑左移(unsigned)</span></span><br><span class="line">LSR AX, #<span class="number">16b</span>it  <span class="comment">// 逻辑右移(unsigned)</span></span><br><span class="line">ASR AX, #<span class="number">16b</span>it  <span class="comment">// 算数右移(signed)，保留符号位</span></span><br><span class="line">      <span class="comment">// 例: LSR AL, #4 表示 AL = AL / 16</span></span><br></pre></td></tr></table></figure></li><li><p><strong>重复执行</strong>（常用于除法，要背除法的代码段）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RPT #N<span class="number">-1</span>    <span class="comment">// 重复下一行N次</span></span><br><span class="line">|| ....     <span class="comment">// 只能写简单的代码，比如加、减等</span></span><br></pre></td></tr></table></figure></li><li><p><strong>乘法</strong>（写法很多，只介绍其中一种）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MPYB P,T,#<span class="number">8b</span>it   <span class="comment">// P (signed 32) = T (signed 16) * 8bit (unsigned 8)</span></span><br><span class="line">            <span class="comment">// P (32) = PH (16) + PL (16)</span></span><br></pre></td></tr></table></figure></li><li><p><strong>条件减法</strong>（常用于除法，要背除法的代码段）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBCU ACC, loc16   <span class="comment">// ACC = ACC 条件减 loc16，具体原理不想写了</span></span><br></pre></td></tr></table></figure></li><li><p><strong>条件指令</strong>（好多啊，这咋记得住啊）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">B CODE, LOGIC    <span class="comment">// B代表条件指令，SB短跳8bit，LB长跳22bit</span></span><br><span class="line">    <span class="comment">// CODE是代码块的名称，可以理解为C或Py的函数</span></span><br><span class="line">    <span class="comment">// LOGIC表示条件，满足跳转，不满足不跳</span></span><br></pre></td></tr></table></figure><pre>条件列表：中文名    条件名             翻译              具体判断标准不等于     NEQ         Not Equal To             Z = 0等于       EQ            Equal To               Z = 1大于       GT          Greater Then         Z = 0 AND N = 0大于等于   GEQ     Greater Then Or Equal To      N = 0小于       LT           Less Then               N = 1小于等于   LEQ     Less Then Or Equal To     Z = 1 OR N = 1高于       HI             Higher            C = 1 AND Z = 0高于等于  HIS,C   Higher Or Same, Carry Set      C = 1低于     LO,NC      Lower, Carry Clear          C = 0低于等于   LOS         Lower Or Same         C = 0 OR Z = 1未溢出     NOV         No Overflow               V = 0溢出       OV            Overflow               V = 1我不到啊   NTC        Test Bit Not Set           TC = 0我不到啊   TC          Test Bit Set              TC = 1</pre></li><li><p><strong>自增</strong>（i++，这个不用背）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INC loc16  <span class="comment">// 如 INC @2</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="汇编代码块"><a href="#汇编代码块" class="headerlink" title="汇编代码块"></a>汇编代码块</h3><ol><li><p><strong>除法</strong>（需要记）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 无符号数除法 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Num ÷ Den = Quot ... Rem</span></span><br><span class="line"><span class="comment">  商: Quot = Num / Den</span></span><br><span class="line"><span class="comment">  余数: Rem = Num % Den</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MOVU ACC, @Num    <span class="comment">// AH = 0, AL = Num,</span></span><br><span class="line">RPT #<span class="number">15</span>         <span class="comment">// 16bit, Repeat 15 times</span></span><br><span class="line">||SUBCU ACC, @Den  <span class="comment">// 条件减法</span></span><br><span class="line">MOV @Rem, AH     <span class="comment">// 余数存在高位AH，移到Rem里</span></span><br><span class="line">MOV @Quot, AL    <span class="comment">// 商存在低位AL，移到Quot里</span></span><br></pre></td></tr></table></figure></li><li><p><strong>代码块的调用</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 代码块的调用——类似于C与Py的函数 */</span></span><br><span class="line">TODO  <span class="comment">// PRE CODE </span></span><br><span class="line">LC NAME  <span class="comment">// 调用, LC = CALL</span></span><br><span class="line">TODO  <span class="comment">// POST CODE</span></span><br><span class="line"></span><br><span class="line">NAME:</span><br><span class="line">  TODO  <span class="comment">// FUNCTION</span></span><br></pre></td></tr></table></figure></li><li><p><strong>考试的代码块要求</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 考试的代码块要求 */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  1. 有标号，或者“函数名”</span></span><br><span class="line"><span class="comment">  2. 以LRET结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/* 示例 */</span></span><br><span class="line">TEST:</span><br><span class="line">  TODO  <span class="comment">// Code Here</span></span><br><span class="line">  LRET</span><br></pre></td></tr></table></figure></li></ol><h3 id="汇编实例"><a href="#汇编实例" class="headerlink" title="汇编实例"></a>汇编实例</h3><p><strong>例1</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  将9000H单元中的16进制数(&lt;99)转为8421BCD码存入9002H单元中</span></span><br><span class="line"><span class="comment">  如：51H = 81 -&gt; 81H</span></span><br><span class="line"><span class="comment">  实现方法：51H/10 = 8...1 -&gt; 8*16+1 = 81</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  MOVW DP, #<span class="number">0x9000</span> &gt;&gt; <span class="number">6</span></span><br><span class="line">  MOVU ACC, @<span class="number">0</span></span><br><span class="line">  LC HEX2BCD</span><br><span class="line">  MOV @<span class="number">2</span>, AL</span><br><span class="line">  </span><br><span class="line">HEX2BCD:</span><br><span class="line">  MOV T, #<span class="number">10</span></span><br><span class="line">  RPT #<span class="number">15</span></span><br><span class="line">  ||SUBCU ACC, @T  <span class="comment">// 除法: 高位AH=余数, 低位AL=商</span></span><br><span class="line">  LSL AL, #<span class="number">4</span>    <span class="comment">// AL = AL(3..0) * 16</span></span><br><span class="line">  ADD AL, @AH    <span class="comment">// AL = AL + AH</span></span><br><span class="line">  LRET</span><br></pre></td></tr></table></figure><p><strong>例2</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  将9004H单元中的8421BCD码转为16进制数存入9006H单元</span></span><br><span class="line"><span class="comment">  如：56H -&gt; 56 = 38H</span></span><br><span class="line"><span class="comment">  实现方法：56H -&gt; 5*10+6 = 56 = 38H</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">BCD2HEX:</span><br><span class="line">  MOVW DP, #<span class="number">0x9000</span> &gt;&gt; <span class="number">6</span></span><br><span class="line">  MOVU ACC, @<span class="number">4</span>  <span class="comment">// ACC = 0 0 | 5 6</span></span><br><span class="line">  MOV AH, @AL  <span class="comment">// ACC = 5 6 | 5 6</span></span><br><span class="line">  ASR AH, #<span class="number">4</span>  <span class="comment">// AH = 0 5</span></span><br><span class="line">  AND AL, #<span class="number">0x0F</span>  <span class="comment">// AL = 0 6</span></span><br><span class="line">  MOV T, @AH</span><br><span class="line">  MPYB P,T,#<span class="number">10</span>  <span class="comment">// P = AH * 10</span></span><br><span class="line">  MOV AH, @PL  <span class="comment">// AH = 50</span></span><br><span class="line">  ADD AH, @AL  <span class="comment">// AH = 50 + 6</span></span><br><span class="line">  MOV @<span class="number">6</span>, AH</span><br><span class="line">  LRET</span><br></pre></td></tr></table></figure><p><strong>例3</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  程序阅读题，求下列代码执行后，V、C、N、Z 的值</span></span><br><span class="line"><span class="comment">  并说明最终结果和存放位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">MOV SP, #<span class="number">0x420</span></span><br><span class="line">MOV *-SP[<span class="number">10</span>], #<span class="number">0x10</span></span><br><span class="line">MOV AL, #<span class="number">0x12</span></span><br><span class="line">SUB *-SP[<span class="number">10</span>], AL</span><br></pre></td></tr></table></figure><ul><li><p>分析：</p><ul><li><code>*-SP[10]</code> 给单元 <code>*(0x416)</code> 赋值 <code>0x10</code></li><li>减法SUB得到 <code>0x10 - 0x12 = -0x2 = 0xFFFE</code>，因此答案为：</li></ul><ol><li>V保持不变，原来是1就是1，原来是0还是0</li><li>零位Z=0（因为结果不是0）</li><li>负位N=1，因为结果是负数（最高位是1就是负数）</li><li>进位/借位位C=0，减法C=0表示有借位</li><li>最终结果为 <code>0xFEFF</code>，存放在 <code>0x416</code> 的地址中</li></ol></li></ul><p><strong>例4</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *(Uint *)0x3F9008 = (*((Uint *)0x3F9002)) / 5 + 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AAAA:</span><br><span class="line">  MOVL XAR4, #<span class="number">0x3F9002</span></span><br><span class="line">  MOVU ACC, *+XAR4[<span class="number">0</span>]</span><br><span class="line">  MOVW T,#<span class="number">5</span></span><br><span class="line">  RPT #<span class="number">15</span></span><br><span class="line">  ||SUBCU ACC, @T</span><br><span class="line">  MOV AH, #<span class="number">0x6</span></span><br><span class="line">  ADD AH, @AL    <span class="comment">// AL 和 @AL 应该是一样的</span></span><br><span class="line">  MOV *+XAR4[<span class="number">6</span>], AH</span><br><span class="line">  LRET</span><br></pre></td></tr></table></figure><p><strong>例5</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  *(Uint *)0x3F9008 = (*((Uint *)0x3F9002)) * 15 + 6</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">AAAA:</span><br><span class="line">  MOVW DP, #<span class="number">0x3F9002</span> &gt;&gt; <span class="number">6</span></span><br><span class="line">  MOV AL, @<span class="number">2</span></span><br><span class="line">  MOV T, @AL</span><br><span class="line">  MPYB P, T, #<span class="number">15</span></span><br><span class="line">  MOV AL, #<span class="number">6</span></span><br><span class="line">  ADD AL, @PL</span><br><span class="line">  MOV @<span class="number">8</span>, AL</span><br><span class="line">  LRET</span><br></pre></td></tr></table></figure><p><strong>例6</strong>（这个太难了考试不会考的）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  数组求和，求给定数组前10个元素之和，C代码如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> k = <span class="number">0</span>,i;</span><br><span class="line"><span class="type">int</span> m[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++) k += m[i];</span><br><span class="line"><span class="comment">/* 下面是汇编语言写法 */</span></span><br><span class="line"><span class="comment">/* int k = 0,i; */</span> </span><br><span class="line">  MOVW DP, #<span class="number">0x3F9000</span> &gt;&gt; <span class="number">6</span>  <span class="comment">// 设i为@0, k为@1</span></span><br><span class="line">  MOV @<span class="number">1</span>, #<span class="number">0</span>  <span class="comment">// k = 0</span></span><br><span class="line"><span class="comment">/* int m[10] */</span></span><br><span class="line">  MOVL XAR4, #<span class="number">0x3F9040</span>  <span class="comment">// 设为数组初始地址</span></span><br><span class="line"><span class="comment">/* for(i=0;i&lt;10;i++) k += m[i]; */</span></span><br><span class="line">  MOV @<span class="number">0</span>, #<span class="number">0</span>  <span class="comment">// i = 0</span></span><br><span class="line">  MOV AL, @<span class="number">0</span></span><br><span class="line">L1:</span><br><span class="line">  MOV ACC, @<span class="number">0</span></span><br><span class="line">  ADDL @XAR4, ACC  <span class="comment">// XAR4 = &amp;m[i]</span></span><br><span class="line">  MOV AL, *+XAR4[<span class="number">0</span>]  <span class="comment">// AL = m[i]</span></span><br><span class="line">  ADD @<span class="number">1</span>, AL  <span class="comment">// k = k + m[i]</span></span><br><span class="line">  </span><br><span class="line">  INC @<span class="number">0</span>  <span class="comment">// i++</span></span><br><span class="line">  MOV AL, @<span class="number">0</span>  <span class="comment">// AL = i</span></span><br><span class="line">  CMPB AL, #<span class="number">10</span></span><br><span class="line">  SB L1, LT  <span class="comment">// LT = Less Than</span></span><br><span class="line">  LRET</span><br></pre></td></tr></table></figure><h2 id="连接命令文件CMD"><a href="#连接命令文件CMD" class="headerlink" title="连接命令文件CMD"></a>连接命令文件CMD</h2><ul><li><p>连接文件的内容：把软件安排到硬件中去，用于控制程序文件中代码和数据输出段在存储器区域中的定位</p></li><li><p><strong>MEMORY</strong></p><ol><li>划分程序页、数据页，一页可分为若干段 </li><li>与存储器映射有关 </li><li>调试程序放在RAM中（也可用FLASH，没学），有RESET（复位向量）项</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MEMORY&#123;</span><br><span class="line">  PAGE <span class="number">0</span>:  <span class="comment">// 程序空间</span></span><br><span class="line">    PRAMH0 : origin = <span class="number">0x3F8000</span> length = <span class="number">0x001000</span> </span><br><span class="line">         <span class="comment">//程序段不要写到保留段中去 </span></span><br><span class="line">         <span class="comment">//定下长度后，程序段就不能超过这个长度，否则会报错</span></span><br><span class="line">    RESET : origin = <span class="number">0x3FFFC0</span>, length = <span class="number">0x000002</span> </span><br><span class="line">         <span class="comment">//复位向量，固定，从这个地址中取出32位地址为程序开头</span></span><br><span class="line">  PAGE <span class="number">1</span>:  <span class="comment">// 数据空间</span></span><br><span class="line">    SPI_A : origin=<span class="number">0x007740</span>, length=<span class="number">0x000010</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>SECTION</strong></p><ol><li>把程序中的段定位到硬件的段 </li><li>程序段 .reset  .text  .cinit </li><li>数据段 .bss    .ebss  .stack </li><li>数据段根据要求增加 </li><li>要求掌握安排变量到固定地址中，如GPIOF </li></ol></li><li><p><strong>.text</strong>：初始化段、所有可以执行的代码和常量、存储类型：ROM或RAM（FLASH）、Page0</p><ul><li>常量例如define PI=3.14（也可以用立即数赋值，但不常用） </li></ul></li><li><strong>.cinit</strong>：初始化段、全局变量和静态变量的C初始化记录、存储类型：ROM或RAM（FLASH）、Page0 </li><li><strong>.stack</strong>：非初始化段、为系统堆栈保留的空间，主要用于和函数传递变量或位局部变量分配空间、存储类型：ROM或RAM（FLASH）、Page1 </li><li><strong>.bss</strong>：非初始化段、为全局变量和局部变量保留的空间、存储类型：ROM或RAM（FLASH）、Page1，在程序上电时.cinit空间中的数据复制出来并存 储在.bss空间中。分配范围被限制在<strong>低64K 16位</strong>数据区 位 </li><li><strong>.ebss</strong>：为使用大寄存器模式时的全局变量和静态变量预留的空间。分配范围为<strong>4M 22位</strong>数据区 位 （分配范围不同于寻址方式相关） </li><li>.cinit、.bss、.ebss：三者只与C相关，用汇编时不需要 </li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">  SciaRegsFile: &gt; SCI_A,   PAGE = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  .text        : &gt; PRAMH0,  PAGE = <span class="number">0</span></span><br><span class="line">  .reset       : &gt; RESET,   PAGE = <span class="number">0</span>, TYPE = DSECT <span class="comment">/* not used, */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="一个简单的例子"><a href="#一个简单的例子" class="headerlink" title="一个简单的例子"></a>一个简单的例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">MEMORY&#123;</span><br><span class="line">  PAGE <span class="number">1</span>:</span><br><span class="line">    GPFMUX  : origin = <span class="number">0x0070D4</span>, length = <span class="number">0x000001</span></span><br><span class="line">    GPFDIR  : origin = <span class="number">0x0070D5</span>, length = <span class="number">0x000001</span></span><br><span class="line">    GPFDAT  : origin = <span class="number">0x0070D6</span>, length = <span class="number">0x000001</span></span><br><span class="line">&#125;</span><br><span class="line">SECTION&#123;</span><br><span class="line">  GpiofMuxRegs  : &gt; GPFMUX,  PAGE = <span class="number">1</span></span><br><span class="line">  GpiofDirRegs  : &gt; GPFDIR,  PAGE = <span class="number">1</span></span><br><span class="line">  GpiofDataRges : &gt; GPFDAT,  PAGE = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> DATA_SECTION(Gpfmux,<span class="string">&quot;GpiofMuxRegs&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> DATA_SECTION(Gpfdir,<span class="string">&quot;GpiofDirRegs&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> DATA_SECTION(Gpfdat,<span class="string">&quot;GpiofDataRegs&quot;</span>)</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> Gpfmux,Gpfdir,Gpfdat</span><br><span class="line"><span class="comment">// 注意 GPFMUX -&gt; GpiofMuxRegs -&gt; Gpfmux 的关系</span></span><br></pre></td></tr></table></figure><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .c */</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> DATA_SECTION (<span class="string">&lt;variable&gt;</span>,<span class="string">&quot;&lt;section&gt;&quot;</span>);</span></span><br><span class="line"><span class="comment">// 定义一个变量和一个段，这个变量会被分配到这个段中去</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> &lt;</span>struct_name&gt; &lt;variable&gt;;</span><br><span class="line"><span class="comment">// 声名这个变量的变量类型</span></span><br><span class="line"><span class="comment">/* .cmd */</span></span><br><span class="line">MEMORY&#123;</span><br><span class="line">    PAGE <span class="number">1</span>: </span><br><span class="line">      &lt;space_name&gt; : origin = <span class="number">0x0000</span>, length = <span class="number">0x0400</span></span><br><span class="line">      <span class="comment">// 定义一个数据空间</span></span><br><span class="line">&#125;</span><br><span class="line">SECTION&#123;</span><br><span class="line">    &lt;section&gt;  : &gt; &lt;space_name&gt;, PAGE = <span class="number">1</span></span><br><span class="line">    <span class="comment">// 把一个段放到这个数据空间里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* .c */</span></span><br><span class="line"><span class="meta">#progma DATA_SECTION (AdcRegs,<span class="string">&quot;AdcRegsFile&quot;</span>);</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">ADC_REGS</span> <span class="title">AdcRegs</span>;</span>  <span class="comment">// struct ADC_REGS 是一个被定义好的变量类型</span></span><br><span class="line"><span class="comment">/* .cmd */</span></span><br><span class="line">MEMORY&#123;</span><br><span class="line">    PAGE <span class="number">1</span>:</span><br><span class="line">      ADC : origin = <span class="number">0x007100</span>, length = <span class="number">0x000020</span></span><br><span class="line">&#125;</span><br><span class="line">SECTION&#123;</span><br><span class="line">    AdcRegsFile : &gt;ADC, PAGE = <span class="number">1</span></span><br><span class="line">               <span class="comment">// load = ADC, PAGE = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
            <tag> 微机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微机原理（DSP）笔记</title>
      <link href="/2026/02/24/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88DSP%EF%BC%89/"/>
      <url>/2026/02/24/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%EF%BC%88DSP%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="课程笔记"><a href="#课程笔记" class="headerlink" title="课程笔记"></a>课程笔记</h1><h2 id="时钟与系统控制"><a href="#时钟与系统控制" class="headerlink" title="时钟与系统控制"></a>时钟与系统控制</h2><div class="table-container"><table><thead><tr><th>从属</th><th>名称</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>外部</td><td>OSCCLK</td><td>外部晶振信号</td><td></td></tr><tr><td>时钟控制</td><td>PLLCR</td><td>提供倍数于参考信号的系统时钟</td><td>$\text{SYSCLK}=\frac{f\cdot\text{PLLCR}}2$</td></tr><tr><td></td><td>PCLKCR</td><td>外设时钟信号</td><td></td></tr><tr><td></td><td>HISPCP</td><td>高速时钟信号</td><td></td></tr><tr><td></td><td>LOSPCP</td><td>低速时钟信号</td><td></td></tr><tr><td>看门狗</td><td>WDCR</td><td>看门狗时钟寄存器</td><td>含使能控制、逻辑校验位、频率设置</td></tr><tr><td></td><td>SCSR</td><td>系统控制和状态寄存器</td><td>含WDINTS（中断状态位）、WDENNIT（中断使能位）</td></tr><tr><td>低功耗</td><td>LPMCR0</td><td>低功耗控制寄存器0</td><td>低二位LPM控制低功耗模式，QUALSTDBY控制频率</td></tr><tr><td></td><td>LPMCR1</td><td>低功耗控制寄存器1</td><td>低八位控制STDBY模式的唤醒（全1唤醒）</td></tr></tbody></table></div><h2 id="GPIO"><a href="#GPIO" class="headerlink" title="GPIO"></a>GPIO</h2><div class="table-container"><table><thead><tr><th>从属</th><th>名称</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>控制寄存器</td><td>GPxMUX</td><td>功能选择控制寄存器</td><td>‘0’ - I/O；‘1’ - 外设</td></tr><tr><td></td><td>GPxDIR</td><td>方向控制寄存器</td><td>‘0’ - Input；‘1’ - Output</td></tr><tr><td></td><td>GPxQUAL</td><td>输入限定控制</td><td>使输入在n个采样相同时才变化</td></tr><tr><td>数据寄存器</td><td>GPxDAT</td><td>数据寄存器</td><td>16位</td></tr></tbody></table></div><h2 id="CPU定时器"><a href="#CPU定时器" class="headerlink" title="CPU定时器"></a>CPU定时器</h2><div class="table-container"><table><thead><tr><th>从属</th><th>名称</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>减法计数</td><td>TIMER0TIM</td><td>计数器寄存器</td><td>32位减法计数器，减到0产生中断（控制寄存器）</td></tr><tr><td></td><td>TIMER0TIMH</td><td></td><td>与上面的合起来</td></tr><tr><td>赋值（高位）</td><td>TIMER0PRD</td><td>周期寄存器</td><td>定义为<code>long int*</code>，可以直接实现两个一起赋值，最大4G</td></tr><tr><td></td><td>TIMER0PRDH</td><td></td><td>合起来的话，在上面那个地方赋值</td></tr><tr><td>控制</td><td>TIMER0PCR</td><td>控制寄存器</td><td>15位 - 中断标志位，计数器减到0置1，否则为0，写入1清零<br />5位 - 定时器重装，写1时重装PRD和TDDR(TPR)的值</td></tr><tr><td>赋值（低位）</td><td>TIMER0TPR</td><td>预定标寄存器</td><td>必须分两块写入数据，每块16位最大256 bit</td></tr><tr><td></td><td>TIMER0TPRH</td><td></td><td>跟上面那个都定义为<code>unsigned int*</code></td></tr><tr><td>控制</td><td>TIMER0TCR</td><td>定时器控制寄存器</td><td>第15位 - 中断标志位。定时器到0时置1，写入1清零</td></tr></tbody></table></div><p>因此：</p><script type="math/tex; mode=display">T=\frac{\text{TDDRH:TDDR}+1}{\text{SYSCLKOUT}(Hz)}\cdot(\text{PRDH:PRD}+1)</script><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><div class="table-container"><table><thead><tr><th>从属</th><th>名称</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>CPU中断</td><td>IER</td><td>中断使能寄存器（16位）</td><td>‘0’ - 禁止；‘1’ - 使能</td></tr><tr><td></td><td>IFR</td><td>中断标志寄存器（16位）</td><td>‘0’ - 清零；‘1’ - 中断</td></tr><tr><td></td><td>INTM</td><td>全局中断使能寄存器</td><td>‘1’ - 全局使能</td></tr><tr><td>PIE中断</td><td>PIRIER</td><td>PIE中断使能寄存器（12×8）</td><td>同上</td></tr><tr><td></td><td>PIEIFR</td><td>PIE中断标志寄存器（12×8）</td><td>同上</td></tr><tr><td></td><td>PIEACK</td><td>PIE中断应答寄存器</td><td>不确定几位，清0申请中断，置1为等待状态</td></tr><tr><td></td><td>PIECTRL</td><td>PIE控制寄存器</td><td>ENPIE，位0，置1表示向量取自PIE向量表</td></tr></tbody></table></div><h2 id="存储器与寄存器"><a href="#存储器与寄存器" class="headerlink" title="存储器与寄存器"></a>存储器与寄存器</h2><h3 id="存储器与CMD"><a href="#存储器与CMD" class="headerlink" title="存储器与CMD"></a>存储器与CMD</h3><p>CMD：记录下如何分配存储空间内容的文件</p><p>CMD的工作分为两步：</p><ol><li>MEMORY：指示定义存储空间</li><li>SECTIONS：分配存储空间</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* SRAM.CMD */</span></span><br><span class="line">MEMORY&#123;</span><br><span class="line">    PAGE <span class="number">1</span>: <span class="comment">// PAGE0表示程序空间，PAGE1表示数据空间</span></span><br><span class="line">    SPI_A:origin=<span class="number">0x007740</span>, length=<span class="number">0x000010</span></span><br><span class="line">    <span class="comment">//   名称    起始地址           长度</span></span><br><span class="line">    <span class="comment">// 相当于在仓库（存储空间）里开了一个大集装箱，名叫SPI_A，并告诉大家这块箱子在哪，能装多少东西</span></span><br><span class="line">&#125;</span><br><span class="line">SECTIONS&#123;</span><br><span class="line">    SciaRegsFile:&gt;SCI_A,PAGE=<span class="number">1</span></span><br><span class="line">    <span class="comment">// 输出段名称      地址（绝对地址或地址名）</span></span><br><span class="line">    <span class="comment">// 以后公司采购，分类为SpiaRegsFile的数据（PAGE=1）都会被丢到SPI_A的箱子里</span></span><br><span class="line">    <span class="comment">// 因此，以后就不用管箱子叫啥了，直接把东西归类为SpiaRegsFile，我们称之为“段”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C语音中已经预先定义好了很多<strong>“段”</strong>，我们可以直接拿来用，或者我们可以自己新建或定义“段”，用于存放我们所需要的<strong>变量</strong>。方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 写法 */</span></span><br><span class="line"><span class="meta">#progma DATA_SECTION(<span class="string">&lt;variables&gt;</span>,<span class="string">&quot;&lt;section_name&gt;&quot;</span>);</span></span><br><span class="line">struction variables;</span><br><span class="line"><span class="comment">/* 解释 */</span></span><br><span class="line"><span class="comment">// DATA_SECTION 定义数据段，CODE_SECTION 定义程序段</span></span><br><span class="line"><span class="comment">// &lt;variables&gt; 是变量名，如s；&lt;section_name&gt;是段名，如上文的SciaRegsFile</span></span><br><span class="line"><span class="comment">// 下面一行是常见的变量定义，如：unsigned int s[100];</span></span><br><span class="line"><span class="comment">/* 举例 */</span></span><br><span class="line"><span class="meta">#progma DATA_SECTION(SciaRegs,<span class="string">&quot;SciaRegsFile&quot;</span>)；</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">SCI_REGS</span> <span class="title">SciaRegs</span>;</span></span><br></pre></td></tr></table></figure><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>位域与结构：为了解决（1）不能对位变量的独立操作；（2）每一位都要写出具体数字；的问题。下面简述我们的解决方案</p><p><strong>（一）定义一个位结构（位域）——&gt; 联合结构（共同体）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下文件应该放在.h文件（Head）下 */</span></span><br><span class="line"><span class="comment">/* 1. 定义位结构（位域） */</span></span><br><span class="line"><span class="comment">// 用于独立的对变量进行操作</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPFDAT_BITS</span>&#123;</span></span><br><span class="line">    Uint16 GPIO0:<span class="number">1</span>; <span class="comment">// 第一个为最低位，:1表示长度为1bit</span></span><br><span class="line">    Uint16 GPIO1:<span class="number">1</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 2. 定义联合结构（共同体） */</span></span><br><span class="line"><span class="comment">// 由位结构struct+整型变量Uint共同组成，可以单独操作也可以整体操作</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GPFDAT_REG</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GPFDAT_BITS</span> <span class="title">bit</span>;</span> <span class="comment">// 单独操作调用方法</span></span><br><span class="line">    Uint16 all; <span class="comment">// 整体操作调用方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>演示一下调用方法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">GPFDAT_REG</span> <span class="title">GPFDAT</span>;</span></span><br><span class="line">GPFDAT.all = <span class="number">0x00ff</span>;</span><br><span class="line">GPFDAT.bit.GPIO15 = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>（二）定义一个包含一组联合的结构（结构体文件）</strong></p><p>说来复杂，其实也不难，就是把刚刚我们的一堆共同体union丢到一起，就是结构体文件了。一个结构体文件相当于一个班。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下文件应该放在.h文件（Head）下 */</span></span><br><span class="line"><span class="comment">/* 定义结构体（这个是最大的结构体了） */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GPIO_DATA_REGS</span>&#123;</span> <span class="comment">//结构体名字</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">GPADAT_REG</span> <span class="title">GPADAT</span>;</span> <span class="comment">// 类型（union GPADAT_REG）+ 变量（GPADAT）</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">GPFDAT_REG</span> <span class="title">GPFDAT</span>;</span></span><br><span class="line">    Uint16 rsvd1[<span class="number">4</span>]; <span class="comment">// 不严谨啊，位置不在这的，就是表示一下也可以有Uint16这种类型变量在的意思</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* 定义变量 */</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">GPIO_DATA_REGS</span> <span class="title">GpioDataRegs</span>;</span> <span class="comment">// 这个就是最后用的变量之一了！</span></span><br></pre></td></tr></table></figure><p><strong>（三）申明结构体变量实体，并指定其与section的关系（即分配空间）</strong></p><p>前半句话，就是上面（二）代码块中的最后一行，合并在一起写了</p><p>后半句话，参考CMD中的progma代码段，一般常用的都定义好了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下文件应该放在.c文件下 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> DATA_SECTION(<span class="string">&quot;GpioDataRegsFile&quot;</span>) </span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> DATA_SECTION(GpioDataRegs,<span class="string">&quot;GpioDataRegsFile&quot;</span>);</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="keyword">volatile</span> <span class="class"><span class="keyword">struct</span> <span class="title">GPIO_DATA_REGS</span> <span class="title">GpioDataRegs</span>;</span></span><br></pre></td></tr></table></figure><p><strong>（四）在链接命令文件CMD中建立连接</strong></p><p>参考CMD中的第一个代码块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">MEMORY&#123;</span><br><span class="line">    PAGE <span class="number">1</span>:</span><br><span class="line">        GPIODAT : origin = <span class="number">0x0070E0</span>, length = <span class="number">0x000020</span></span><br><span class="line">        PIE_VECT: origin = <span class="number">0x000D00</span>, length = <span class="number">0x000100</span></span><br><span class="line">&#125;</span><br><span class="line">SECTIONS&#123;</span><br><span class="line">    PieVectTableFile : &gt; PIE_VECT,  PAGE = <span class="number">1</span></span><br><span class="line">    GpioDataRegsFile : &gt; GPIODAT ，PAGE = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（五）成功调用</strong></p><p>变量成为一个结构的成员，同时又有了自己的地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GpioDataRegs.GPFDAT.bit.GPIO11 = <span class="number">1</span>;</span><br><span class="line">GpioDataRegs.GPFDAT.all = <span class="number">0x1234</span>;</span><br><span class="line"><span class="comment">// 大结构体.共同体union.位域bit或整体all</span></span><br></pre></td></tr></table></figure><h2 id="串行外设接口SPI"><a href="#串行外设接口SPI" class="headerlink" title="串行外设接口SPI"></a>串行外设接口SPI</h2><div class="table-container"><table><thead><tr><th>从属</th><th>名称</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>配置</td><td>SPICCR</td><td>SPI配置控制寄存器</td><td>第6位控制信号极性（上升/下降沿）<br />0-3位控制单个字符读取数量</td></tr><tr><td>控制</td><td>SPICTL</td><td>SPI工作控制寄存器</td><td>第2位网络模式控制（‘0’ - 从机；‘1’ - 主机）<br />第1位主从机发送使能TALK；第0位中断使能</td></tr><tr><td>状态</td><td>SPISTS</td><td>SPI状态寄存器</td><td>第7位接收器溢出标志<br />第6位只读中断标志<strong>INT FLAG</strong>（完成数据发送/接收）<br />第5位发送缓冲器已满标志位<strong>FULL</strong></td></tr><tr><td>时钟</td><td>SPIBRR</td><td>SPI波特率寄存器</td><td>第0-6位控制波特率（$Rate=\frac{LSPCLK}{SPIBRR+1}$）</td></tr><tr><td>数据</td><td>SPIRXBUF</td><td>SPI串行接收缓存寄存器</td><td>接收后INT FLAG置1</td></tr><tr><td></td><td>SPITXBUF</td><td>SPI串行发送缓存寄存器</td><td>发送后TX BUF FULL被清除</td></tr><tr><td></td><td>SPIDAT</td><td>SPI串行数据寄存器</td><td>略</td></tr></tbody></table></div><h2 id="事件管理器EV"><a href="#事件管理器EV" class="headerlink" title="事件管理器EV"></a>事件管理器EV</h2><ul><li>以EVA的Timer1为例</li></ul><div class="table-container"><table><thead><tr><th>从属</th><th>名称</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>控制</td><td>GPTCONA</td><td>全局控制寄存器A</td><td>.T1PIN：比较输出极性，01低，10高<br />.T1CMPOE：比较输出使能（1有效）<br />.TCMPOE：全局比较输出使能（1有效）</td></tr><tr><td></td><td>T1CON</td><td>定时器1控制寄存器</td><td>.TECMPR：定时器比较使能（1有效）<br />.TCLKS10：时钟源（00内部时钟）<br />.TENABLE：定时器使能（1有效）<br />.TPS：输入时钟预定标因子（分频：HSPCLK/2^n）<br />.TMODE10：计数模式（01连续增减，10连续增）</td></tr><tr><td>计数</td><td>T1CNT</td><td>定时器1计数寄存器</td><td>略</td></tr><tr><td></td><td>T1PR</td><td>定时器1周期寄存器</td><td>略</td></tr><tr><td></td><td>T1CMPR</td><td>定时器1比较寄存器</td><td>略</td></tr><tr><td>死区</td><td>DBTCONA</td><td>死区定时器控制寄存器</td><td>.DBTPS：死区定时器预定标因子（分频：T1时钟/2^n）<br />.EDBT1：死区定时器1使能（1有效）<br />.DBT：死区周期</td></tr><tr><td>PWM波</td><td>CMPR1</td><td>比较寄存器1</td><td>略</td></tr></tbody></table></div><h2 id="数模转换器ADC"><a href="#数模转换器ADC" class="headerlink" title="数模转换器ADC"></a>数模转换器ADC</h2><ul><li>ADC的时钟分频：</li></ul><ol><li>准备：PCLKCR使能</li><li>外部晶振信号30MHz——PLLCR=0xA——SYSCLKOUT=150MHz</li><li>HISPCP=001（例）——HSPCLK=150/2MHz=75MHz</li><li>ADCTRL3.ADCCLKPS分频（2n）倍（n=0时不起作用）</li><li>ADCTRL1.CPS分频（m+1）倍</li></ol><div class="table-container"><table><thead><tr><th>从属</th><th>名称</th><th>描述</th><th>使用</th></tr></thead><tbody><tr><td>控制</td><td>ADCTRL1</td><td>ADC控制寄存器1</td><td>.CPS：内核时钟预定标，用于分频<br />.CONT RUN：连续运行or启停模式（一般选0启停）<br />.SEQ CASC：SEQ级联or双序列</td></tr><tr><td></td><td>ADCTRL2</td><td>ADC控制寄存器2</td><td>.RST1：复位序列发生器<br />.SOC SEQ1：序列发生器1启动触发，主动写入/中断自动调用<br />.INT ENA SEQ1：中断使能<br />.INT MOD SEQ1：中断方式（每个/隔一个）<br />.EVA SOC SEQ1：事件管理器EVA允许触发使能<br />其余有关SEQ2的略，类似</td></tr><tr><td></td><td>ADCTRL3</td><td>ADC控制寄存器3</td><td>.ADCBGRFDN：上电，一般写1，需要长延时<br />.ADCPWDN：上电，一般写1，需要长延时<br />.ADCCLKPS：时钟分频<br />.SMODE SEL：采样方式：顺序or并发</td></tr><tr><td>序列</td><td>MAXCONV</td><td>最大转换通道寄存器</td><td>进行（n+1）次转换</td></tr><tr><td></td><td>ADCCHSELSEQ1-4</td><td>输入通道选择序列控制寄存器</td><td>见书p254，一个CHSELSEQ有4个CONV，一个CONV寄存一个输入</td></tr><tr><td>状态</td><td>ADCASEQSR</td><td>自动序列状态寄存器</td><td>看不懂</td></tr><tr><td></td><td>ADCST</td><td>ADC状态和标志寄存器</td><td>.INT SEQx CLR：中断清除位，写1清除<br />.SEQx BSY：忙状态位，0表示空闲，只读<br />.INT SEQx：中断标志位，1表示有中断，只读</td></tr></tbody></table></div><h1 id="C语言代码"><a href="#C语言代码" class="headerlink" title="C语言代码"></a>C语言代码</h1><h2 id="基本代码定义与框架"><a href="#基本代码定义与框架" class="headerlink" title="基本代码定义与框架"></a>基本代码定义与框架</h2><h3 id="引脚定义实例"><a href="#引脚定义实例" class="headerlink" title="引脚定义实例"></a>引脚定义实例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> <span class="string">&lt;引脚名&gt;</span> *((volatile unsigned int*) 引脚号);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLCR *((volatile unsigned int*) 0x7021);</span></span><br></pre></td></tr></table></figure><h3 id="控制时钟PLL初始化"><a href="#控制时钟PLL初始化" class="headerlink" title="控制时钟PLL初始化"></a>控制时钟PLL初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitPLL</span><span class="params">()</span>&#123;</span><br><span class="line">EALLOW;</span><br><span class="line">PLLCR=<span class="number">10</span>; <span class="comment">// 0~10, SYSCLK=外部晶振f*PLLCR/2</span></span><br><span class="line">EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="看门狗初始化"><a href="#看门狗初始化" class="headerlink" title="看门狗初始化"></a>看门狗初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DisableDog</span><span class="params">()</span>&#123;</span><br><span class="line">EALLOW;</span><br><span class="line">WDCR = <span class="number">0x0068</span>; <span class="comment">// 禁止WatchDog, 0x0028开启</span></span><br><span class="line">EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="外设时钟初始化"><a href="#外设时钟初始化" class="headerlink" title="外设时钟初始化"></a>外设时钟初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitPeripheralClock</span><span class="params">()</span>&#123;</span><br><span class="line">EALLOW;</span><br><span class="line">EVAENCLK = <span class="number">1</span>;</span><br><span class="line">EVBENCLK = <span class="number">1</span>;</span><br><span class="line">SCIENCLKA = <span class="number">1</span>;</span><br><span class="line">EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总初始化-InitSysCtrl"><a href="#总初始化-InitSysCtrl" class="headerlink" title="总初始化 InitSysCtrl"></a>总初始化 InitSysCtrl</h3><h4 id="写法1"><a href="#写法1" class="headerlink" title="写法1"></a>写法1</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitSysCtrl</span><span class="params">()</span>&#123;</span><br><span class="line">DisableDog();</span><br><span class="line">InitPLL();</span><br><span class="line">InitPeripheralClock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="写法2"><a href="#写法2" class="headerlink" title="写法2"></a>写法2</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitSysCtrl</span><span class="params">()</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line"><span class="comment">// DisableDog();</span></span><br><span class="line">WDCR = <span class="number">0x0068</span>;</span><br><span class="line"><span class="comment">// InitPLL();</span></span><br><span class="line">    PLLCR=(<span class="number">0</span>~<span class="number">10</span>);</span><br><span class="line"><span class="comment">// InitPeripheralClock();</span></span><br><span class="line">    EVAENCLK = <span class="number">1</span>;</span><br><span class="line">EVBENCLK = <span class="number">1</span>;</span><br><span class="line">SCIENCLKA = <span class="number">1</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="GPIO初始化-InitGpio"><a href="#GPIO初始化-InitGpio" class="headerlink" title="GPIO初始化 InitGpio"></a>GPIO初始化 InitGpio</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitGpioF</span><span class="params">()</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    GPFMUX=<span class="number">0x0000</span>; <span class="comment">// 也等于0x80FF等</span></span><br><span class="line">    GPXDIR=<span class="number">0xFF00</span>; <span class="comment">// 也等于3F00等</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CPU定时器初始化-InitCPUtimer"><a href="#CPU定时器初始化-InitCPUtimer" class="headerlink" title="CPU定时器初始化 InitCPUtimer"></a>CPU定时器初始化 InitCPUtimer</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER0PRD *((volatile long int*)0x0C02;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER0TCR *((volatile unsigned int*)0x0C04;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER0TPR *((volatile unsigned int*)0x0C06;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER0TPRH *((volatile unsigned int*)0x0C07;</span></span><br><span class="line"><span class="comment">// SYSCLKIN = 30 MHz, PLLCR = 10, SYSCLKOUT = 150 MHz</span></span><br><span class="line"><span class="comment">// 要求变成1s的定时器，这里先除150[(149+1)*(0+1)]，再除10e6(999999+1)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCPUtimer</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    TIMER0TPR = <span class="number">149</span>;</span><br><span class="line">    TIMER0TPRH = <span class="number">0</span>;</span><br><span class="line">    TIMER0PRD = <span class="number">999999</span>;</span><br><span class="line">    TIMER0TCR = <span class="number">0xf000</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时钟延时函数"><a href="#时钟延时函数" class="headerlink" title="时钟延时函数"></a>时钟延时函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 已经定义过InitCPUtimer</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> val)</span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    EALLOW;</span><br><span class="line">    TIMER0PRD = val;</span><br><span class="line">    TIMER0TCR = <span class="number">0xf020</span>; <span class="comment">// 重新装载数据</span></span><br><span class="line">    <span class="keyword">do</span> &#123;k = TIMER0TCR&#125; <span class="keyword">while</span> ((k &amp; <span class="number">0x8000</span>) == <span class="number">0</span>);</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PIE中断初始化-InitPIE"><a href="#PIE中断初始化-InitPIE" class="headerlink" title="PIE中断初始化 InitPIE"></a>PIE中断初始化 InitPIE</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设仅使用INT1.7，仅允许该中断通过</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIECTRL *((volatile unsigned int*)0x0CE0);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIEACK *((volatile unsigned int*)0x0CE1);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIEIER1 *((volatile unsigned int*)0x0CE2);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PIEIFR1 *((volatile unsigned int*)0x0CE3);</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPIE</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    PIEIFR1 = <span class="number">0x0000</span>;</span><br><span class="line">    PIEIER1 = <span class="number">0x0040</span>; <span class="comment">// 使能</span></span><br><span class="line">    PIECTRL = <span class="number">0x1</span>; <span class="comment">// 使向量取自PIE向量表</span></span><br><span class="line">    PIEACK = <span class="number">0x1</span>; <span class="comment">// 清零，表示暂无中断</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="中断向量的申请"><a href="#中断向量的申请" class="headerlink" title="中断向量的申请"></a>中断向量的申请</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 申明</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_m_n</span><span class="params">(<span class="type">void</span>)</span>; <span class="comment">// m=0~12, n=0~8</span></span><br><span class="line"><span class="comment">// 2.地址计算</span></span><br><span class="line">PIE_VECT_m_n = <span class="number">0x0D40</span> + ((m<span class="number">-1</span>)*<span class="number">8</span>+(n<span class="number">-1</span>))*<span class="number">2</span>; <span class="comment">// 起始地址为0x0D40，如INT1.7就是0x0D4C</span></span><br><span class="line"><span class="comment">// 3. 赋值</span></span><br><span class="line"><span class="keyword">typedef</span> interrupt <span class="title function_">void</span> <span class="params">(*PINT)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">(*(PINT*) PIE_VECT_m_n) = &amp;INT_m_n</span><br></pre></td></tr></table></figure><h3 id="CPU中断初始化"><a href="#CPU中断初始化" class="headerlink" title="CPU中断初始化"></a>CPU中断初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitCPU</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    <span class="comment">// 汇编语言</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot; and IFR,#00H&quot;</span>); <span class="comment">// IFR置0，表示此时无中断</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot; and IER,#01H&quot;</span>); <span class="comment">// IER置1，使能</span></span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot; EINT&quot;</span>); <span class="comment">// 总闸使能，这个就是INTM</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPI初始化"><a href="#SPI初始化" class="headerlink" title="SPI初始化"></a>SPI初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitSpi</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    GpioMuxRegs.GPFMUX.all = <span class="number">0x000F</span>; <span class="comment">// SPI与GPIOF共用引脚</span></span><br><span class="line">    EDIS;</span><br><span class="line">    SpiaRegs.SPICCR.all = <span class="number">0x47</span>; <span class="comment">// 个人感觉0x07也行</span></span><br><span class="line">    SpiaRegs.SPICTL.all = <span class="number">0x06</span>; <span class="comment">// 主机模型 + 禁用中断</span></span><br><span class="line">    SpiaRegs.SPIBRR = <span class="number">0x7F</span>; <span class="comment">// 书上作0x1D，配置波特率</span></span><br><span class="line">    SpiaRegs.SPICCR.all = SpiaRegs.SPICCR.all | <span class="number">0x0080</span>; <span class="comment">// 退出复位的方式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SPI数据发送"><a href="#SPI数据发送" class="headerlink" title="SPI数据发送"></a>SPI数据发送</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SpiSent</span><span class="params">(<span class="type">int</span> k)</span>&#123;</span><br><span class="line">    SpiaRegs.SPITXBUF = k; <span class="comment">// 数据输入</span></span><br><span class="line">    <span class="keyword">while</span> (SpiaRegs.SPISTS.bit.INT_FLAG != <span class="number">1</span>) &#123;&#125; <span class="comment">// 确认数据发送完毕</span></span><br><span class="line">    SpiaRegs.SPIRXBUF = SpiaRegs.SPIRXBUF; <span class="comment">// 复位</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="点红灯函数"><a href="#点红灯函数" class="headerlink" title="点红灯函数"></a>点红灯函数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> redled = <span class="number">0xffff</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Out_redled</span><span class="params">(redled)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all |= <span class="number">0Xff00</span>;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">2</span>;</span><br><span class="line">    GpioDataRegs.GPBDAT.all = redled * <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">3</span>;</span><br><span class="line">    GpioDataRegs.GPBDAT.all = redled;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">7</span>;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all &amp;= <span class="number">0X00ff</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="八段数码管循环"><a href="#八段数码管循环" class="headerlink" title="八段数码管循环"></a>八段数码管循环</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Display</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GpioDataRegs.GPADAT.bit.GPIOA11 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// 依次输入8个数据，数码管自动往前移位</span></span><br><span class="line">        SpiaRegs.SPITXBUF= LEDCode[LEDReg[i]]; </span><br><span class="line">        <span class="keyword">while</span> (SpiaRegs.SPISTS.bit.INT_FLAG!= <span class="number">1</span>) &#123;&#125;;</span><br><span class="line">        SpiaRegs.SPIRXBUF= SpiaRegs.SPIRXBUF;</span><br><span class="line">    &#125;</span><br><span class="line">    GpioDataRegs.GPADAT.bit.GPIOA11 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键盘的读取"><a href="#键盘的读取" class="headerlink" title="键盘的读取"></a>键盘的读取</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Keyin = <span class="number">0xffff</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Keyscan</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key1R , key2R; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    EALLOW;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all &amp;= <span class="number">0x00FF</span>;</span><br><span class="line">    <span class="comment">/* KEYA - 低八位 */</span></span><br><span class="line">    GpioDataRegs.GPEDAT.all  = <span class="number">0xFFF8</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;&#125; <span class="comment">//短延时</span></span><br><span class="line">    key1R = GpioDataRegs.GPBDAT.all;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">30000</span>; i++) &#123;&#125;   <span class="comment">// 长延时消除抖动</span></span><br><span class="line">    <span class="keyword">if</span> (key1R != GpioDataRegs.GPBDAT.all) key1R=<span class="number">0xffff</span> ;</span><br><span class="line">    <span class="comment">/* KEYB - 高八位 */</span></span><br><span class="line">    GpioDataRegs.GPEDAT.all  = <span class="number">0xFFF9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;&#125; <span class="comment">//短延时</span></span><br><span class="line">    key2R = GpioDataRegs.GPBDAT.all;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">30000</span>; i++) &#123;&#125;   <span class="comment">// 长延时消除抖动</span></span><br><span class="line">    <span class="keyword">if</span>(key2R != GpioDataRegs.GPBDAT.all) key2R=<span class="number">0xffff</span>;</span><br><span class="line">    <span class="comment">/* Add */</span></span><br><span class="line">    Keyin = key2R &amp; <span class="number">0xff00</span> + key1R / <span class="number">256</span>; </span><br><span class="line"><span class="comment">// 例：key2R = 0xfbff, key1R = ffff, 则：Keyin = fbff, 同一时间不允许两个键同时按下 </span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="等待键盘输入"><a href="#等待键盘输入" class="headerlink" title="等待键盘输入"></a>等待键盘输入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">WaitKeyin</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (Keyin == <span class="number">0xffff</span>) &#123;Keyscan();&#125; <span class="comment">// 等待直到键盘有输入</span></span><br><span class="line">    temp = Keyin;</span><br><span class="line">    <span class="keyword">while</span> (Keyin != <span class="number">0xffff</span>) &#123;Keyscan();&#125; <span class="comment">// 松开键盘时建立响应</span></span><br><span class="line">    <span class="keyword">switch</span> (temp)&#123;</span><br><span class="line">        <span class="keyword">case</span> K1: Keyin = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span> : Keyin = <span class="number">0x10</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键号判别、功能转移"><a href="#键号判别、功能转移" class="headerlink" title="键号判别、功能转移"></a>键号判别、功能转移</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// for (;;) &#123;asm(&quot; IDLE&quot;);&#125;</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;KeyFunction();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyFunction</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    WaitKeyin();</span><br><span class="line">    <span class="keyword">switch</span> (Keyin)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            <span class="comment">// do something</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通用定时器编程初始化"><a href="#通用定时器编程初始化" class="headerlink" title="通用定时器编程初始化"></a>通用定时器编程初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EVA_Timer1</span><span class="params">()</span>&#123;</span><br><span class="line">    EvaRegs.EXTCONA.bit.INDCOE= <span class="number">1</span>; <span class="comment">// 决定T1，T2是否关联</span></span><br><span class="line">    EvaRegs.GPTCONA.all= <span class="number">0x0012</span>; <span class="comment">// 4.5.6位说明T1，T2是否输出</span></span><br><span class="line">    EvaRegs.T1PR = <span class="number">0x003</span>; <span class="comment">// 峰值</span></span><br><span class="line">    EvaRegs.T1CMPR = <span class="number">0x0001</span>; <span class="comment">// Compare</span></span><br><span class="line">    EvaRegs.T1CNT = <span class="number">0x0000</span>; <span class="comment">// 计数器初始化</span></span><br><span class="line">    EvaRegs.T1CON.all = <span class="number">0x1742</span>; <span class="comment">// 确定运行方式，或0x0F42</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置PWM波周期波形"><a href="#设置PWM波周期波形" class="headerlink" title="设置PWM波周期波形"></a>设置PWM波周期波形</h3><ol><li>准备：PCLKCR使能EVA时钟</li><li>晶振30MHz——PLLCR=10——SYSCLK=150MHz</li><li>HISPCP=001（例）——HSPCLK=150/2MHz=75MHz（见书p134）</li><li>T1CON.TPS10=n——T1CLK：HSPCLK/2^ n=75/2^n MHz</li><li>T1PR = T1CLK / 要求的时钟频率 - 1</li></ol><ul><li>T1PWM，T2PWM不带死区</li><li>PWM1-6带死区，12、34、56互补</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitEVA</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化设置 */</span></span><br><span class="line">    EvaRegs.T1CON.bit.TMODE = <span class="number">2</span>; <span class="comment">// 连续增</span></span><br><span class="line">    EvaRegs.T1CON.bit.TPS = <span class="number">1</span>; <span class="comment">// T1CLK = HSPCLK/2 = 37.5 MHz</span></span><br><span class="line">    EvaRegs.T1CON.bit.TENABLE = <span class="number">0</span>; <span class="comment">// 暂时禁止T1计数</span></span><br><span class="line">    EvaRegs.T1CON.bit.TCLKS10 = <span class="number">0</span>; <span class="comment">// 使用内部时钟T1CLK</span></span><br><span class="line">    EvaRegs.T1CON.bit.TECMPR = <span class="number">1</span>; <span class="comment">// 使能定时器比较操作</span></span><br><span class="line">    EvaRegs.GPTCONA.bit.TCMPOE = <span class="number">1</span>; <span class="comment">// T1和T2互不影响（书上代码写的是TCOMPOE?）</span></span><br><span class="line">    EvaRegs.GPTCONA.bit.T1PIN = <span class="number">1</span>; <span class="comment">//低电平有效</span></span><br><span class="line">    EvaRegs.COMCONA.bit.CENABLE = <span class="number">1</span>; <span class="comment">// 使能比较单元的比较操作</span></span><br><span class="line">    EvaRegs.COMCONA.bit.FCOMPOE = <span class="number">1</span>; <span class="comment">// 全比较输出</span></span><br><span class="line">    EvaRegs.COMCONA.bit.CLD = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">/* 具体设置——T1PWM */</span></span><br><span class="line">    EvaRegs.T1PR = <span class="number">0x927B</span>; <span class="comment">// 1kHz，计算详见书p239</span></span><br><span class="line">    EvaRegs.T1CMPR = <span class="number">0x3A98</span>; <span class="comment">// 占空比40%</span></span><br><span class="line">    EvaRegs.T1CNT = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 死区设置——PWM1-6 */</span></span><br><span class="line">    EvaRegs.DBTCONA.bit.DBT = <span class="number">10</span>; <span class="comment">// 周期</span></span><br><span class="line">    EvaRegs.DBTCONA.bit.EDBT1 = <span class="number">1</span>; <span class="comment">// 死区定时器1使能</span></span><br><span class="line">    EvaRegs.DBTCONA.bit.DBTPS = <span class="number">4</span>; <span class="comment">// 预标定因子——分频</span></span><br><span class="line">    EvaRegs.ACTRA.all = <span class="number">0x9999</span>;</span><br><span class="line">    EvaRegs.CMPR1 = <span class="number">0x3A98</span>; <span class="comment">// 占空比40%</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* 初始化 */</span></span><br><span class="line">    InitEVA();</span><br><span class="line">    EvaRegs.T1CON.bit.TENABLE = <span class="number">1</span>; <span class="comment">// 使能定时器1计数</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ADC上电"><a href="#ADC上电" class="headerlink" title="ADC上电"></a>ADC上电</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AdcPower</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    AdcRegs.ADCTRL3.bit.ADCBGRFDN = <span class="number">0x3</span>; <span class="comment">// ADC带隙和参考电路加电</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100000</span>;i++)&#123;&#125; <span class="comment">//至少5ms延时</span></span><br><span class="line">    AdcRegs.ADCTRL3.bit.ADCPWDN = <span class="number">1</span>; <span class="comment">// ADC模拟电路加电</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">50000</span>;i++)&#123;&#125; <span class="comment">//至少20us延时</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ADC初始化"><a href="#ADC初始化" class="headerlink" title="ADC初始化"></a>ADC初始化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InitAdc</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    AdcRegs.ADCTRL1.bit.CPS = <span class="number">1</span>; <span class="comment">// 3分频 —— 75MHz/3 = 25MHz</span></span><br><span class="line">    AdcRegs.ADCTRL1.bit.CONT_RUN = <span class="number">0</span>; <span class="comment">// 启停模式</span></span><br><span class="line">    AdcRegs.ADCTRL1.bit.SEQ_CASC = <span class="number">1</span>; <span class="comment">// 单序列发生器</span></span><br><span class="line">    AdcRegs.ADCTRL1.bit.ACQ_PS = <span class="number">0xf</span>; <span class="comment">// 采样窗口大小</span></span><br><span class="line">    AdcRegs.ADCTRL3.bit.ADCCLKPS = <span class="number">2</span>; <span class="comment">// 4分频 —— 25MHz/4 = 6.25MHz</span></span><br><span class="line">    AdcRegs.ADCTRL3.bit.SMODE_SEL = <span class="number">0</span>; <span class="comment">// 顺序采样</span></span><br><span class="line">    AdcRegs.ADCMAXCONV.all = <span class="number">0x0</span>; <span class="comment">// 只采样1个通道，书上这里寄存器写错了</span></span><br><span class="line">    AdcRegs.ADCCHSELSEQ1.bit.CONV00 = <span class="number">0xF</span>; <span class="comment">// 本实验仅用到ADCINB7</span></span><br><span class="line">    <span class="comment">/* 书中还有下文，但是感觉应该都是控制中断，本实验不需要中断，因此不用初始化 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ADC调用示例"><a href="#ADC调用示例" class="headerlink" title="ADC调用示例"></a>ADC调用示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AdcFunction</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    AdcRegs.ADCTRL2.bit.SOC_SEQ1 = <span class="number">1</span>; <span class="comment">// 手动启动</span></span><br><span class="line">    <span class="keyword">while</span>(AdcRegs.ADCST.bit.SEQ1_BSY == <span class="number">1</span>)&#123;&#125; <span class="comment">// 等待转换完毕</span></span><br><span class="line">    <span class="type">int</span> AD1,AD2;</span><br><span class="line">    AD1 = AdcRegs.ADCRESULT0 &gt;&gt; <span class="number">4</span>; <span class="comment">// 数据寄存在高12位，右移四位</span></span><br><span class="line">    AD2 = (AD1<span class="number">-0x0</span>)*<span class="number">3</span>*<span class="number">1000</span> / <span class="number">0x0fff</span>; <span class="comment">// 0x0对应0,0x0fff对应3V，线性比例关系。</span></span><br><span class="line">    <span class="comment">//  *1000 用于取小数，可自由增删0的个数，以增减精度（因为是int）</span></span><br><span class="line">    <span class="comment">/* TODO */</span></span><br><span class="line">    AdcRegs.ADCTRL2.bit.RST_SEQ1 = <span class="number">1</span>; <span class="comment">// 复位序列发生器SEQ1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="键盘与红灯的冲突解决方案"><a href="#键盘与红灯的冲突解决方案" class="headerlink" title="键盘与红灯的冲突解决方案"></a>键盘与红灯的冲突解决方案</h3><p>原因是两者都会调用GPB和GPE，且键盘需要一直进行监视（<code>Keyscan()</code>），不能把GPB放出来。</p><ol><li>选择将<code>Keyscan()</code>这个函数放到CPUTimer中，而不是在main的死循环里面调用。</li><li>将<code>Keyscan()</code>函数中的输出值放到全局变量中，并尽可能减小其时间，即删去防抖动的延时、减小反应时间延时。</li><li><code>WaitKeyin()</code>函数不再被允许调用<code>Keyscan()</code>，而是直接读取数值</li><li>在<code>Keyscan()</code>中的开头和结尾都要加上对GPB的控制</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> Keyin = <span class="number">0xffff</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Keyscan</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key1R , key2R; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    EALLOW;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all &amp;= <span class="number">0x00FF</span>;</span><br><span class="line">    <span class="comment">/* KEYA - 低八位 */</span></span><br><span class="line">    GpioDataRegs.GPEDAT.all  = <span class="number">0xFFF8</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;&#125; <span class="comment">//短延时</span></span><br><span class="line">    key1R = GpioDataRegs.GPBDAT.all;</span><br><span class="line">    <span class="comment">/* KEYB - 高八位 */</span></span><br><span class="line">    GpioDataRegs.GPEDAT.all  = <span class="number">0xFFF9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;&#125; <span class="comment">//短延时</span></span><br><span class="line">key2R = GpioDataRegs.GPBDAT.all;</span><br><span class="line">    <span class="comment">/* Add */</span></span><br><span class="line">    Keyin = key2R &amp; <span class="number">0xff00</span> + key1R / <span class="number">256</span>; </span><br><span class="line">GpioMuxRegs.GPBDIR.all &amp;= <span class="number">0x00FF</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WaitKeyin</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="keyword">asm</span>(<span class="string">&quot; IDLE&quot;</span>);&#125; <span class="keyword">while</span>(Keyin == <span class="number">0xffff</span>); <span class="comment">// 按下</span></span><br><span class="line">    temp = Keyin;</span><br><span class="line">    <span class="keyword">do</span> &#123;<span class="keyword">asm</span>(<span class="string">&quot; IDLE&quot;</span>);&#125; <span class="keyword">while</span>(Keyin != <span class="number">0xffff</span>); <span class="comment">// 松开</span></span><br><span class="line">    <span class="keyword">switch</span>(temp)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xfffe</span>: Keyout = <span class="number">0</span>; <span class="keyword">break</span>; <span class="comment">// 0</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> redled = <span class="number">0xffff</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Out_redled</span><span class="params">(redled)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all |= <span class="number">0Xff00</span>;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">2</span>;</span><br><span class="line">    GpioDataRegs.GPBDAT.all = redled * <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">3</span>;</span><br><span class="line">    GpioDataRegs.GPBDAT.all = redled;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">7</span>;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all &amp;= <span class="number">0X00ff</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="实例1-点灯"><a href="#实例1-点灯" class="headerlink" title="实例1 点灯"></a>实例1 点灯</h3><ul><li>点亮六盏灯，利用GPIOF的8-13位输出。（高电平灭灯）</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPFMUX *((volatile unsigned int*)0x70D4);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFDIR *((volatile unsigned int*)0x70D5);</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFDAT *((volatile unsigned int*)0x70F4);</span></span><br><span class="line"><span class="type">int</span> delay_n <span class="number">30000</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSysCtrl</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpioF</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_Loop</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    InitSysCtrl();</span><br><span class="line">    InitGpioF();</span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        Delay_Loop(delay_n);</span><br><span class="line">        GPFDAT = <span class="number">0x5600</span> <span class="comment">// 0x56 = 01010110</span></span><br><span class="line">        Delay_Loop(delay_n);</span><br><span class="line">        GPFDAT = <span class="number">0x1200</span> <span class="comment">// 0x12 = 00010010</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例2-中断编程"><a href="#实例2-中断编程" class="headerlink" title="实例2 中断编程"></a>实例2 中断编程</h3><ul><li>利用TIMER0中断，使GPIOF8闪烁，周期为3s，亮1s。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> interrupt <span class="title function_">void</span><span class="params">(*PINT)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_1_7</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 四个初始化</span></span><br><span class="line">    InitSysCtrl();</span><br><span class="line">    InitGpioF();</span><br><span class="line">    InitCPUtimer();</span><br><span class="line">    InitPIE();</span><br><span class="line">    <span class="comment">// 主程序</span></span><br><span class="line">    EALLOW;</span><br><span class="line">    *(PINT*)<span class="number">0x0D4C</span> = &amp;INT_1_7;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot; and IFR,#00H&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot; and IER,#01H&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot; EINT&quot;</span>);</span><br><span class="line">    LPMCR0 = <span class="number">0x0</span>; <span class="comment">// 定义低功耗方式为00，即IDLE</span></span><br><span class="line">    EDIS;</span><br><span class="line">    <span class="comment">// Else</span></span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">asm</span>(<span class="string">&quot; IDLE&quot;</span>); <span class="comment">// 开始睡觉</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_1_7</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    k += <span class="number">1</span>; <span class="comment">// Global k</span></span><br><span class="line">    <span class="keyword">if</span> (k==<span class="number">3</span>)&#123;</span><br><span class="line">        k=<span class="number">0</span>;</span><br><span class="line">        GPFDAT = <span class="number">0xfeff</span>; <span class="comment">// 开</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        GPFDAT = <span class="number">0x0100</span>; <span class="comment">// 关</span></span><br><span class="line">    &#125;</span><br><span class="line">    PIEACK = <span class="number">0x1</span>; <span class="comment">// 表示响应过了（0的话会申请中断）</span></span><br><span class="line">    TIMER0TCR = <span class="number">0xf000</span>; <span class="comment">// 写1中断清除</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例3-绿灯闪烁-点红灯"><a href="#实例3-绿灯闪烁-点红灯" class="headerlink" title="实例3 绿灯闪烁+点红灯"></a>实例3 绿灯闪烁+点红灯</h3><ul><li>GPIOE</li></ul><div class="table-container"><table><thead><tr><th>输入</th><th>效果</th></tr></thead><tbody><tr><td>2</td><td>选择寄存器1，即GPBDAT与左边八盏红灯建立联系</td></tr><tr><td>3</td><td>选择寄存器2，即GPBDAT与右边八盏红灯建立联系</td></tr><tr><td>7</td><td>产生一个下降沿，使寄存器（GPBDAT）发送数据</td></tr></tbody></table></div><ul><li>GPIOB</li></ul><p>输入数据的前八位控制红灯（初始化GPBDIR为0xFF00）</p><p>如<code>GPBDAT = 0xfeff</code>，且<code>GPEDAT = 2</code>，则左边第一盏红灯亮。（DAT最低位对应第一盏灯）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EALLOW asm(<span class="string">&quot; EALLOW&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EDIS   asm(<span class="string">&quot; EDIS&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PLLCR   *((volatile unsigned int *) 0x7021)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCLKCR  *((volatile unsigned int *) 0x701C)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HISPCP  *((volatile unsigned int *) 0x701A)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LOSPCP  *((volatile unsigned int *) 0x701B)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WDCR    *((volatile unsigned int *) 0x7029)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCSR    *((volatile unsigned int *) 0x7022)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LPMCR0  *((volatile unsigned int *) 0x701E)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFMUX  *((volatile unsigned int *) 0x70D4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFDIR  *((volatile unsigned int *) 0x70D5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFDAT  *((volatile unsigned int *) 0x70F4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBMUX  *((volatile unsigned int *) 0x70C4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDIR  *((volatile unsigned int *) 0x70C5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT  *((volatile unsigned int *) 0x70E4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPEMUX  *((volatile unsigned int *) 0x70D0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPEDIR  *((volatile unsigned int *) 0x70D1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPEDAT  *((volatile unsigned int *) 0x70F0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER0PRD   *((volatile unsigned long int *) 0x0C02)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER0TCR   *((volatile unsigned int *) 0x0C04)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER0TPR   *((volatile unsigned int *) 0x0C06)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIMER0TPRH  *((volatile unsigned int *) 0x0C07)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  PIECTRL    *((volatile unsigned int *) 0x0CE0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  PIEACK     *((volatile unsigned int *) 0x0CE1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  PIEIER1    *((volatile unsigned int *) 0x0CE2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>  PIEIFR1    *((volatile unsigned int *) 0x0CE3)</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPll</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   <span class="type">int</span> i;</span><br><span class="line">    EALLOW;</span><br><span class="line">    PLLCR = <span class="number">10</span>;<span class="comment">//SYSCLK = 外部振荡频率（30M） * PLLCR /2</span></span><br><span class="line">    EDIS;</span><br><span class="line">    <span class="keyword">for</span>(i= <span class="number">0</span>; i&lt; ( (<span class="number">131072</span>/<span class="number">2</span>)/<span class="number">12</span> ); i++) &#123;;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPeripheralClocks</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    HISPCP = <span class="number">1</span>;  <span class="comment">// HISPCLK= SYSCLK * HISPCP /2</span></span><br><span class="line">    LOSPCP = <span class="number">2</span>;  <span class="comment">// LOSPCLK= SYSCLK * LOSPCP /2</span></span><br><span class="line">    PCLKCR = <span class="number">0x909</span>;<span class="comment">// 开启部分外设</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DisableDog</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    WDCR = <span class="number">0x0068</span>; <span class="comment">//关闭看门狗；；</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSysCtrl</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    DisableDog();</span><br><span class="line">    InitPll();</span><br><span class="line">    InitPeripheralClocks();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpiof</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    GPFMUX =<span class="number">0x0000</span>;</span><br><span class="line">    GPFDIR =<span class="number">0xFF00</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpiob</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    GPBMUX =<span class="number">0x0000</span>;</span><br><span class="line">    GPBDIR =<span class="number">0xFF00</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpioe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    GPEMUX =<span class="number">0x0</span>;</span><br><span class="line">    GPEDIR =<span class="number">0x7</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCputimer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    TIMER0TPR=<span class="number">149</span>;</span><br><span class="line">    TIMER0TPRH=<span class="number">0</span>;</span><br><span class="line">    TIMER0PRD=<span class="number">999</span>;<span class="comment">//周期为0.001s，即1ms </span></span><br><span class="line">    TIMER0TCR=<span class="number">0xf000</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPIE</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    PIEIFR1=<span class="number">0x0000</span>;</span><br><span class="line">    PIEIER1=<span class="number">0x0040</span>;</span><br><span class="line">    PIECTRL=<span class="number">0x1</span>;</span><br><span class="line">    PIEACK =<span class="number">0x1</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> interrupt <span class="title function_">void</span><span class="params">(*PINT)</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_1_7</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">int</span> a, b, c, d, e, f;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   InitSysCtrl();</span><br><span class="line">    InitGpiof();</span><br><span class="line">    InitGpiob();</span><br><span class="line">    InitGpioe();</span><br><span class="line">    InitCputimer();</span><br><span class="line">    InitPIE();</span><br><span class="line">    EALLOW;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点红灯</span></span><br><span class="line"></span><br><span class="line">    GPEDAT = <span class="number">2</span>;      <span class="comment">//选第一组</span></span><br><span class="line">    GPBDAT = <span class="number">0xFDFF</span>; <span class="comment">//第二盏灯亮</span></span><br><span class="line"><span class="comment">//    for(i = 0;i&lt;100;i++)&#123;&#125;</span></span><br><span class="line">    GPEDAT = <span class="number">7</span>;      <span class="comment">//使产生一个下降沿</span></span><br><span class="line"></span><br><span class="line">    GPEDAT = <span class="number">3</span>;      <span class="comment">//选第二组</span></span><br><span class="line">    GPBDAT = <span class="number">0x7FFF</span>; <span class="comment">//第一盏灯亮</span></span><br><span class="line"><span class="comment">//    for(i = 0;i&lt;100;i++)&#123;&#125;</span></span><br><span class="line">    GPEDAT = <span class="number">7</span>;      <span class="comment">//使产生一个下降沿</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    * (PINT *) <span class="number">0x0D4C</span> = &amp; INT_1_7;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;  and IFR,#00H&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;  or  IER,#01H&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;  EINT&quot;</span>);</span><br><span class="line">    LPMCR0=<span class="number">0x0</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">    a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>, e = <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;<span class="keyword">asm</span>(<span class="string">&quot; IDLE&quot;</span>);&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_1_7</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一盏灯</span></span><br><span class="line">    a+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">500</span>)&#123;</span><br><span class="line">        GPFDAT=GPFDAT&amp;<span class="number">0xFEFF</span>;<span class="comment">//变亮</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">2000</span>)&#123;</span><br><span class="line">        a = <span class="number">0</span>;</span><br><span class="line">        GPFDAT=GPFDAT|<span class="number">0x0100</span>;<span class="comment">//变暗</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二盏灯</span></span><br><span class="line">    b+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">300</span>)&#123;</span><br><span class="line">        GPFDAT=GPFDAT&amp;<span class="number">0xFDFF</span>;<span class="comment">//变亮</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">1000</span>)&#123;</span><br><span class="line">        b = <span class="number">0</span>;</span><br><span class="line">        GPFDAT=GPFDAT|<span class="number">0x0200</span>;<span class="comment">//变暗</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三盏灯</span></span><br><span class="line">    c+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">100</span>)&#123;</span><br><span class="line">        GPFDAT=GPFDAT&amp;<span class="number">0xFBFF</span>;<span class="comment">//变亮</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(c == <span class="number">200</span>)&#123;</span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">        GPFDAT=GPFDAT|<span class="number">0x0400</span>;<span class="comment">//变暗</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第四盏灯</span></span><br><span class="line">    d+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">10</span>)&#123;</span><br><span class="line">        GPFDAT=GPFDAT&amp;<span class="number">0xF7FF</span>;<span class="comment">//变亮</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(d == <span class="number">20</span>)&#123;</span><br><span class="line">        d = <span class="number">0</span>;</span><br><span class="line">        GPFDAT=GPFDAT|<span class="number">0x0800</span>;<span class="comment">//变暗</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第五盏灯</span></span><br><span class="line">    e+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="number">9</span>)&#123;</span><br><span class="line">        GPFDAT=GPFDAT&amp;<span class="number">0xEFFF</span>;<span class="comment">//变亮</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e == <span class="number">10</span>)&#123;</span><br><span class="line">        e = <span class="number">0</span>;</span><br><span class="line">        GPFDAT=GPFDAT|<span class="number">0x1000</span>;<span class="comment">//变暗</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第六盏灯</span></span><br><span class="line">    GPFDAT=GPFDAT|<span class="number">0x2000</span>;</span><br><span class="line">    </span><br><span class="line">    PIEACK=<span class="number">0x1</span>;</span><br><span class="line">    TIMER0TCR=<span class="number">0xf000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例4-键盘响应-时钟-AD转换"><a href="#实例4-键盘响应-时钟-AD转换" class="headerlink" title="实例4 键盘响应+时钟+AD转换"></a>实例4 键盘响应+时钟+AD转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DSP281x_Device.h&quot;</span>     <span class="comment">// DSP281x头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DSP281x_GlobalPrototypes.h&quot;</span><span class="comment">// Prototypes for global functions within the  .c files.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Init */</span> </span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpiof</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    GpioMuxRegs.GPFMUX.all =<span class="number">0x0000</span>;</span><br><span class="line">    GpioMuxRegs.GPFDIR.all =<span class="number">0xFF00</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpioe</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    GpioMuxRegs.GPEMUX.all =<span class="number">0x0</span>;</span><br><span class="line">    GpioMuxRegs.GPEDIR.all =<span class="number">0x7</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpiob</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    GpioMuxRegs.GPBMUX.all =<span class="number">0x0000</span>;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all =<span class="number">0xFF00</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpioa</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    GpioMuxRegs.GPAMUX.all =<span class="number">0x0000</span>;</span><br><span class="line">    GpioMuxRegs.GPADIR.all =<span class="number">0xFF00</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCputimer</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    CpuTimer0Regs.TPR.all = <span class="number">149</span>;</span><br><span class="line">    CpuTimer0Regs.TPRH.all= <span class="number">0</span>;</span><br><span class="line">    CpuTimer0Regs.PRD.all = <span class="number">9999</span>; <span class="comment">// 10ms一个timer0中断</span></span><br><span class="line">    CpuTimer0Regs.TCR.all =<span class="number">0xf000</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitSpi</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    GpioMuxRegs.GPFMUX.all = <span class="number">0x000F</span>; <span class="comment">// SPI与GPIOF共用引脚</span></span><br><span class="line">    EDIS;</span><br><span class="line">    SpiaRegs.SPICCR.all = <span class="number">0x47</span>; <span class="comment">// 个人感觉0x07也行？ </span></span><br><span class="line">    SpiaRegs.SPICTL.all = <span class="number">0x06</span>; <span class="comment">// 主机模型 + 禁用中断</span></span><br><span class="line">    SpiaRegs.SPIBRR = <span class="number">0x7F</span>;</span><br><span class="line">    SpiaRegs.SPICCR.all = SpiaRegs.SPICCR.all | <span class="number">0x0080</span>; <span class="comment">// 退出复位的方式</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//typedef interrupt void(*PINT)(void);</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_1_7</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPIE</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;   EALLOW;</span><br><span class="line">    PieCtrlRegs.PIEIFR1.all=<span class="number">0x0000</span>;</span><br><span class="line">    PieCtrlRegs.PIEIER1.all=<span class="number">0x0040</span>;</span><br><span class="line">    PieCtrlRegs.PIECRTL.bit.ENPIE=<span class="number">0x1</span>;</span><br><span class="line">    PieCtrlRegs.PIEACK.all =<span class="number">0x1</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcPower</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    AdcRegs.ADCTRL3.bit.ADCBGRFDN = <span class="number">0x3</span>; <span class="comment">// ADC带隙和参考电路加电</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;&#125; <span class="comment">//至少5ms延时</span></span><br><span class="line">    AdcRegs.ADCTRL3.bit.ADCPWDN = <span class="number">1</span>; <span class="comment">// ADC模拟电路加电</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5000</span>;i++)&#123;&#125; <span class="comment">//至少20us延时</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitAdc</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">// 这里跟老师的有点不太一样，改了分配，最终6.25MHz快了2倍</span></span><br><span class="line">    AdcRegs.ADCTRL1.bit.CPS = <span class="number">2</span>; <span class="comment">// 3分频 —— 75MHz/3 = 25MHz</span></span><br><span class="line">    AdcRegs.ADCTRL1.bit.CONT_RUN = <span class="number">0</span>; <span class="comment">// 启停模式</span></span><br><span class="line">    AdcRegs.ADCTRL1.bit.SEQ_CASC = <span class="number">0</span>; <span class="comment">// 单序列发生器</span></span><br><span class="line">    AdcRegs.ADCTRL1.bit.ACQ_PS = <span class="number">0xf</span>; <span class="comment">// 采样窗口大小</span></span><br><span class="line">    AdcRegs.ADCTRL3.bit.ADCCLKPS = <span class="number">2</span>; <span class="comment">// 4分频 —— 25MHz/4 = 6.25MHz</span></span><br><span class="line">    AdcRegs.ADCTRL3.bit.SMODE_SEL = <span class="number">0</span>; <span class="comment">// 顺序采样</span></span><br><span class="line">    AdcRegs.ADCMAXCONV.all = <span class="number">0x0</span>; <span class="comment">// 只采样1个通道</span></span><br><span class="line">    AdcRegs.ADCCHSELSEQ1.bit.CONV00 = <span class="number">0xF</span>; <span class="comment">// 本实验仅用到ADCINB7</span></span><br><span class="line">    <span class="comment">/* 书中还有下文，但是感觉应该都是控制中断，本实验不需要中断，因此不用初始化 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Functions */</span></span><br><span class="line"><span class="type">int</span> sec=<span class="number">0</span>,min=<span class="number">0</span>,hour=<span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> LEDReg[<span class="number">8</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">unsigned</span>  <span class="type">int</span> LEDCode[<span class="number">30</span>]=&#123;\</span><br><span class="line"><span class="comment">// 0      1      2     3      4      5       6      7      8      9</span></span><br><span class="line"><span class="number">0xc000</span>,<span class="number">0xf900</span>,<span class="number">0xA400</span>,<span class="number">0xB000</span>,<span class="number">0x9900</span>,<span class="number">0x9200</span>,<span class="number">0x8200</span>,<span class="number">0xF800</span>,<span class="number">0x8000</span>,<span class="number">0x9000</span>,\</span><br><span class="line"><span class="comment">// A      b     C      d      E      F       P      -      c      空 </span></span><br><span class="line"><span class="number">0x8800</span>,<span class="number">0x8300</span>,<span class="number">0xc600</span>,<span class="number">0xa100</span>,<span class="number">0x8600</span>,<span class="number">0x8e00</span>,<span class="number">0x8c00</span>,<span class="number">0xbf00</span>,<span class="number">0xa700</span>,<span class="number">0xff00</span>,\</span><br><span class="line"><span class="comment">// 0.     1.     2.    3.     4.     5.      6.     7.     8.     9.</span></span><br><span class="line"><span class="number">0x4000</span>,<span class="number">0x7900</span>,<span class="number">0x2400</span>,<span class="number">0x3000</span>,<span class="number">0x1900</span>,<span class="number">0x1200</span>,<span class="number">0x0200</span>,<span class="number">0x7800</span>,<span class="number">0x0000</span>,<span class="number">0x1000</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Display</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GpioDataRegs.GPADAT.bit.GPIOA11 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;<span class="number">8</span>;i++)&#123;</span><br><span class="line">        <span class="comment">// 依次输入8个数据，数码管自动往前移位</span></span><br><span class="line">        SpiaRegs.SPITXBUF= LEDCode[LEDReg[i]]; </span><br><span class="line">        <span class="keyword">while</span> (SpiaRegs.SPISTS.bit.INT_FLAG!= <span class="number">1</span>) &#123;&#125;;</span><br><span class="line">        SpiaRegs.SPIRXBUF= SpiaRegs.SPIRXBUF;</span><br><span class="line">    &#125;</span><br><span class="line">    GpioDataRegs.GPADAT.bit.GPIOA11 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> redled  = <span class="number">0x0000</span>;<span class="comment">//低八位是左边，从低到高是从左到右；高八位是右边，从高到低是从右到左</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Out_redled</span> <span class="params">(redled)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all |= <span class="number">0XFF00</span>;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">2</span>;</span><br><span class="line">    GpioDataRegs.GPBDAT.all = redled * <span class="number">256</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">3</span>;</span><br><span class="line">    GpioDataRegs.GPBDAT.all = redled;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">100</span>; i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all = <span class="number">7</span>;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all &amp;= <span class="number">0X00FF</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Keyin = <span class="number">0xffff</span>;</span><br><span class="line"><span class="type">int</span> Keyout = <span class="number">16</span>; <span class="comment">// 0x10</span></span><br><span class="line"><span class="type">int</span> Flag_Stop = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> flag_AD = <span class="number">0</span>; <span class="comment">// 1-AD转换，0-时钟</span></span><br><span class="line"><span class="type">int</span> temp[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> AD[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> ten_ms = <span class="number">0</span>;<span class="comment">//10ms计数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Keyscan</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> key1R , key2R; </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    EALLOW;</span><br><span class="line">    GpioMuxRegs.GPBDIR.all &amp;= <span class="number">0x00FF</span>;</span><br><span class="line">    <span class="comment">/* KEYA - 低八位 */</span></span><br><span class="line">    GpioDataRegs.GPEDAT.all  = <span class="number">0xFFF8</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;&#125; <span class="comment">//短延时</span></span><br><span class="line">    key1R = GpioDataRegs.GPBDAT.all;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">30000</span>; i++) &#123;&#125;   <span class="comment">// 长延时消除抖动</span></span><br><span class="line">    <span class="keyword">if</span> (key1R != GpioDataRegs.GPBDAT.all) key1R=<span class="number">0xffff</span> ;</span><br><span class="line">    <span class="comment">/* KEYB - 高八位 */</span></span><br><span class="line">    GpioDataRegs.GPEDAT.all  = <span class="number">0xFFF9</span>;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++) &#123;&#125; <span class="comment">//短延时</span></span><br><span class="line">    key2R = GpioDataRegs.GPBDAT.all;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="number">30000</span>; i++) &#123;&#125;   <span class="comment">// 长延时消除抖动</span></span><br><span class="line">    <span class="keyword">if</span>(key2R != GpioDataRegs.GPBDAT.all) key2R=<span class="number">0xffff</span>;</span><br><span class="line">    <span class="comment">/* Add */</span></span><br><span class="line">    Keyin = key2R &amp; <span class="number">0xff00</span> + key1R / <span class="number">256</span>; </span><br><span class="line">    <span class="comment">// 例：key2R = 0xfbff, key1R = ffff, 则：Keyin = fbff</span></span><br><span class="line">    <span class="comment">// 同一时间不允许两个键同时按下</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">WaitKeyin</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span> (Keyin == <span class="number">0xffff</span>) &#123;Keyscan();&#125; <span class="comment">// 等待直到键盘有输入</span></span><br><span class="line">    temp = Keyin;</span><br><span class="line">    <span class="keyword">while</span> (Keyin != <span class="number">0xffff</span>) &#123;Keyscan();&#125; <span class="comment">// 松开键盘时建立响应</span></span><br><span class="line">    <span class="keyword">switch</span> (temp)&#123;</span><br><span class="line">        <span class="comment">// 低八位 - key1R</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xfffe</span>: Keyout = <span class="number">0</span>; <span class="keyword">break</span>; <span class="comment">// 0</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xfffd</span>: Keyout = <span class="number">1</span>; <span class="keyword">break</span>; <span class="comment">// 1</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xfffb</span>: Keyout = <span class="number">2</span>; <span class="keyword">break</span>; <span class="comment">// 2</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xfff7</span>: Keyout = <span class="number">3</span>; <span class="keyword">break</span>; <span class="comment">// 3</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xffef</span>: Keyout = <span class="number">4</span>; <span class="keyword">break</span>; <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xffdf</span>: Keyout = <span class="number">5</span>; <span class="keyword">break</span>; <span class="comment">// 5</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xffbf</span>: Keyout = <span class="number">6</span>; <span class="keyword">break</span>; <span class="comment">// 6</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xff7f</span>: Keyout = <span class="number">7</span>; <span class="keyword">break</span>; <span class="comment">// 7</span></span><br><span class="line">        <span class="comment">// 高八位 - key2R</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xfeff</span>: Keyout = <span class="number">8</span>; <span class="keyword">break</span>; <span class="comment">// 8</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xfdff</span>: Keyout = <span class="number">9</span>; <span class="keyword">break</span>; <span class="comment">// 9</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xfbff</span>: Keyout = <span class="number">10</span>; <span class="keyword">break</span>; <span class="comment">// A</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xf7ff</span>: Keyout = <span class="number">11</span>; <span class="keyword">break</span>; <span class="comment">// B</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xefff</span>: Keyout = <span class="number">12</span>; <span class="keyword">break</span>; <span class="comment">// C</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xdfff</span>: Keyout = <span class="number">13</span>; <span class="keyword">break</span>; <span class="comment">// D</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0xbfff</span>: Keyout = <span class="number">14</span>; <span class="keyword">break</span>; <span class="comment">// E</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">0x7fff</span>: Keyout = <span class="number">15</span>; <span class="keyword">break</span>; <span class="comment">// F</span></span><br><span class="line">        <span class="keyword">default</span> : Keyout = <span class="number">0x10</span>; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">TimerModify</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, flag = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i&lt;<span class="number">6</span>)&#123;</span><br><span class="line">        WaitKeyin();</span><br><span class="line">        <span class="keyword">switch</span> (Keyout)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: temp[i++] = <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: temp[i++] = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: temp[i++] = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>: temp[i++] = <span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>: temp[i++] = <span class="number">4</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>: temp[i++] = <span class="number">5</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>: temp[i++] = <span class="number">6</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>: temp[i++] = <span class="number">7</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">8</span>: temp[i++] = <span class="number">8</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">9</span>: temp[i++] = <span class="number">9</span>; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>: &#123;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">6</span>;temp[j++]=<span class="number">0</span>)&#123;&#125;</span><br><span class="line">                i = <span class="number">6</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">        hour = temp[<span class="number">0</span>]*<span class="number">10</span>+temp[<span class="number">1</span>];</span><br><span class="line">        min = temp[<span class="number">2</span>]*<span class="number">10</span>+temp[<span class="number">3</span>];</span><br><span class="line">        sec = temp[<span class="number">4</span>]*<span class="number">10</span>+temp[<span class="number">5</span>];</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;<span class="number">6</span>;temp[j++]=<span class="number">0</span>)&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">LED_Filling</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    LEDReg[<span class="number">0</span>] = hour / <span class="number">10</span>; LEDReg[<span class="number">1</span>] = hour % <span class="number">10</span>; <span class="comment">// hour</span></span><br><span class="line">    LEDReg[<span class="number">3</span>] = min / <span class="number">10</span>; LEDReg[<span class="number">4</span>] = min % <span class="number">10</span>; <span class="comment">// min</span></span><br><span class="line">    LEDReg[<span class="number">6</span>] = sec / <span class="number">10</span>; LEDReg[<span class="number">7</span>] = sec % <span class="number">10</span>; <span class="comment">// sec</span></span><br><span class="line">    LEDReg[<span class="number">2</span>] = <span class="number">17</span>; LEDReg[<span class="number">5</span>] = <span class="number">17</span>; <span class="comment">// 分隔符:-</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcFunction</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* Read */</span></span><br><span class="line">    <span class="keyword">while</span>(AdcRegs.ADCST.bit.SEQ1_BSY == <span class="number">1</span>)&#123;&#125; <span class="comment">// 等待转换完毕</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> AD1,AD2,i;</span><br><span class="line">    AD1 = AdcRegs.ADCRESULT0 &gt;&gt; <span class="number">4</span>; <span class="comment">// 数据寄存在高12位，右移四位</span></span><br><span class="line">    AD2 = (AD1)*<span class="number">3</span>*<span class="number">1000</span> / <span class="number">0x0fff</span>; <span class="comment">// 0x0对应0,0x0fff对应3V，线性比例关系。</span></span><br><span class="line">    <span class="comment">//  *1000 用于取小数，可自由增删0的个数，以增减精度（因为是int）</span></span><br><span class="line">    AD[<span class="number">0</span>] = AD2 / <span class="number">1000</span>;</span><br><span class="line">    AD[<span class="number">1</span>] = (AD2 % <span class="number">1000</span>) / <span class="number">100</span>;</span><br><span class="line">    AD[<span class="number">2</span>] = (AD2 % <span class="number">100</span>) / <span class="number">10</span>;</span><br><span class="line">    AD[<span class="number">3</span>] = (AD2 % <span class="number">10</span>);</span><br><span class="line">    AdcRegs.ADCTRL2.bit.RST_SEQ1 = <span class="number">1</span>; <span class="comment">// 复位序列发生器SEQ1</span></span><br><span class="line">    AdcRegs.ADCTRL2.bit.SOC_SEQ1 = <span class="number">1</span>; <span class="comment">// 手动启动</span></span><br><span class="line">    <span class="comment">/* Led Filling */</span></span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) LEDReg[i+<span class="number">5</span>] = AD[i+<span class="number">1</span>];</span><br><span class="line">    LEDReg[<span class="number">4</span>] = AD[<span class="number">0</span>] + <span class="number">20</span>; <span class="comment">// 带小数点</span></span><br><span class="line">    LEDReg[<span class="number">0</span>] = <span class="number">10</span>; LEDReg[<span class="number">1</span>] = <span class="number">13</span>; LEDReg[<span class="number">2</span>] = <span class="number">18</span>; LEDReg[<span class="number">3</span>] = <span class="number">17</span>; <span class="comment">// 标识符：Adc-</span></span><br><span class="line">    <span class="comment">//LEDReg[7] = 19;</span></span><br><span class="line">    <span class="type">int</span> offset = AD2 / <span class="number">500</span>;</span><br><span class="line">    GpioDataRegs.GPFDAT.all = (<span class="number">0xff00</span> &lt;&lt; offset) % <span class="number">0x10000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">KeyFunction</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    WaitKeyin();</span><br><span class="line">    <span class="keyword">switch</span> (Keyout)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span>(++sec &gt;=<span class="number">60</span>) sec = <span class="number">0</span>; <span class="comment">//秒+1</span></span><br><span class="line">            LED_Filling();</span><br><span class="line">            Display();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span>(--sec &lt;<span class="number">0</span>) sec = <span class="number">59</span>; <span class="comment">//秒-1</span></span><br><span class="line">            LED_Filling();</span><br><span class="line">            Display();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span>(++min &gt;=<span class="number">60</span>) min = <span class="number">0</span>; <span class="comment">//分+1</span></span><br><span class="line">            LED_Filling();</span><br><span class="line">            Display();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span>(--min &lt;<span class="number">0</span>) min = <span class="number">59</span>; <span class="comment">//分-1</span></span><br><span class="line">            LED_Filling();</span><br><span class="line">            Display();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span>(++hour &gt;=<span class="number">24</span>) hour = <span class="number">0</span>; <span class="comment">//时+1</span></span><br><span class="line">            LED_Filling();</span><br><span class="line">            Display();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: &#123;</span><br><span class="line">            <span class="keyword">if</span>(--hour &lt;<span class="number">0</span>) hour = <span class="number">23</span>; <span class="comment">//时-1</span></span><br><span class="line">            LED_Filling();</span><br><span class="line">            Display();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: &#123;</span><br><span class="line">            Flag_Stop = <span class="number">1</span>;      <span class="comment">//暂停</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: &#123;</span><br><span class="line">            Flag_Stop = <span class="number">0</span>;      <span class="comment">//启动</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>: &#123;</span><br><span class="line">            sec=<span class="number">0</span>,min=<span class="number">0</span>,hour=<span class="number">0</span>; <span class="comment">//清零重启</span></span><br><span class="line">            LED_Filling();</span><br><span class="line">            Display();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:&#123; <span class="comment">// A</span></span><br><span class="line">            flag_AD = !flag_AD; <span class="comment">// AD与时钟的转换</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:&#123; <span class="comment">// B</span></span><br><span class="line">            flag_AD = <span class="number">0</span>; <span class="comment">// AD与时钟的转换</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:&#123; <span class="comment">// F</span></span><br><span class="line">            TimerModify(); <span class="comment">// 自由修改</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* main */</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    InitSysCtrl();</span><br><span class="line">    AdcPower();</span><br><span class="line">    InitGpiof();</span><br><span class="line">    InitGpiob();</span><br><span class="line">    InitGpioe();</span><br><span class="line">    InitGpioa();</span><br><span class="line">    InitCputimer();</span><br><span class="line">    InitPIE();</span><br><span class="line">    InitSpi();</span><br><span class="line">    InitAdc();</span><br><span class="line">    EALLOW;</span><br><span class="line">    PieVectTable.TINT0 = &amp; INT_1_7;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;  and IFR,#00H&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;  or  IER,#01H&quot;</span>);</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;  EINT&quot;</span>);</span><br><span class="line">    EDIS;</span><br><span class="line">    Out_redled (redled); <span class="comment">// 全亮</span></span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        KeyFunction();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_1_7</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="comment">/* time add */</span></span><br><span class="line">    <span class="keyword">if</span> (flag_AD == <span class="number">0</span>)&#123; <span class="comment">// 时钟</span></span><br><span class="line">        <span class="keyword">if</span>(Flag_Stop == <span class="number">0</span> &amp;&amp; ++ten_ms == <span class="number">100</span>)&#123; <span class="comment">// 不暂停</span></span><br><span class="line">            ten_ms = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">/* time add */</span></span><br><span class="line">            sec ++;</span><br><span class="line">            <span class="keyword">if</span> (sec == <span class="number">60</span>)&#123;</span><br><span class="line">                sec = <span class="number">0</span>;</span><br><span class="line">                min ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min == <span class="number">60</span>)&#123;</span><br><span class="line">                min = <span class="number">0</span>;</span><br><span class="line">                hour ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (hour == <span class="number">24</span>)&#123;</span><br><span class="line">                hour = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/* LEDReg filling */</span></span><br><span class="line">            LED_Filling();</span><br><span class="line">            Display();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// AD</span></span><br><span class="line">        AdcFunction();</span><br><span class="line">        Display();</span><br><span class="line">    &#125;</span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">0x1</span>;</span><br><span class="line">    CpuTimer0Regs.TCR.all = <span class="number">0xf000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例5-跑马灯——正弦亮度变化"><a href="#实例5-跑马灯——正弦亮度变化" class="headerlink" title="实例5 跑马灯——正弦亮度变化"></a>实例5 跑马灯——正弦亮度变化</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DSP281x_Device.h&quot;</span>     <span class="comment">// DSP281x头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;DSP281x_GlobalPrototypes.h&quot;</span><span class="comment">// Prototypes for global functions within the  .c files.</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Parameters */</span></span><br><span class="line"><span class="type">int</span> redled  = <span class="number">0xffff</span>; <span class="comment">//低八位是左边，从低到高是从左到右；高八位是右边，从高到低是从右到左</span></span><br><span class="line"><span class="type">int</span> times = <span class="number">0</span>; <span class="comment">// 20ms改变一次比较值</span></span><br><span class="line"><span class="type">int</span> index = <span class="number">0</span>; <span class="comment">// 2s周期内一共100个比较值,16等分则index += 100/16</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> T_Period = <span class="number">587</span>; <span class="comment">// EvaRegs.T1PR+1</span></span><br><span class="line"><span class="type">int</span> led_tab[<span class="number">100</span>]=&#123;</span><br><span class="line"><span class="number">587</span>,<span class="number">585</span>,<span class="number">583</span>,<span class="number">580</span>,<span class="number">576</span>,<span class="number">571</span>,<span class="number">565</span>,<span class="number">558</span>,<span class="number">549</span>,<span class="number">540</span>,</span><br><span class="line"><span class="number">530</span>,<span class="number">518</span>,<span class="number">506</span>,<span class="number">493</span>,<span class="number">479</span>,<span class="number">465</span>,<span class="number">449</span>,<span class="number">434</span>,<span class="number">417</span>,<span class="number">400</span>,</span><br><span class="line"><span class="number">383</span>,<span class="number">365</span>,<span class="number">347</span>,<span class="number">329</span>,<span class="number">311</span>,<span class="number">293</span>,<span class="number">274</span>,<span class="number">256</span>,<span class="number">238</span>,<span class="number">220</span>,</span><br><span class="line"><span class="number">202</span>,<span class="number">185</span>,<span class="number">168</span>,<span class="number">151</span>,<span class="number">136</span>,<span class="number">120</span>,<span class="number">106</span>,<span class="number">92</span> ,<span class="number">79</span> ,<span class="number">67</span> ,</span><br><span class="line"><span class="number">55</span> ,<span class="number">45</span> ,<span class="number">36</span> ,<span class="number">27</span> ,<span class="number">20</span> ,<span class="number">14</span> ,<span class="number">9</span>  ,<span class="number">9</span>  ,<span class="number">9</span>  ,<span class="number">9</span>  ,</span><br><span class="line"><span class="number">9</span>  ,<span class="number">9</span>  ,<span class="number">9</span>  ,<span class="number">9</span>  ,<span class="number">9</span>  ,<span class="number">14</span> ,<span class="number">20</span> ,<span class="number">27</span> ,<span class="number">36</span> ,<span class="number">45</span> ,</span><br><span class="line"><span class="number">55</span> ,<span class="number">67</span> ,<span class="number">79</span> ,<span class="number">92</span> ,<span class="number">106</span>,<span class="number">120</span>,<span class="number">136</span>,<span class="number">151</span>,<span class="number">168</span>,<span class="number">185</span>,</span><br><span class="line"><span class="number">202</span>,<span class="number">220</span>,<span class="number">238</span>,<span class="number">256</span>,<span class="number">274</span>,<span class="number">292</span>,<span class="number">311</span>,<span class="number">329</span>,<span class="number">347</span>,<span class="number">365</span>,</span><br><span class="line"><span class="number">383</span>,<span class="number">400</span>,<span class="number">417</span>,<span class="number">434</span>,<span class="number">449</span>,<span class="number">465</span>,<span class="number">479</span>,<span class="number">493</span>,<span class="number">506</span>,<span class="number">518</span>,</span><br><span class="line"><span class="number">530</span>,<span class="number">540</span>,<span class="number">549</span>,<span class="number">558</span>,<span class="number">565</span>,<span class="number">571</span>,<span class="number">576</span>,<span class="number">580</span>,<span class="number">583</span>,<span class="number">585</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Init */</span></span><br><span class="line"><span class="comment">//interrupt void INT_Timer(void);</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_T1</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 控制左数1-4盏灯</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_T1CINT</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 左数第1盏</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP1</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 左数第2盏</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP2</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 左数第3盏</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP3</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 左数第4盏</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_T3</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 控制左数5-8盏灯</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_T3CINT</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 左数第5盏</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP4</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 左数第6盏</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP5</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 左数第7盏</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP6</span><span class="params">(<span class="type">void</span>)</span>;<span class="comment">// 左数第8盏</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Init_Sys</span><span class="params">(<span class="type">void</span>)</span> <span class="comment">/*初始化系统*/</span></span><br><span class="line">&#123;</span><br><span class="line">  SysCtrlRegs.PLLCR.all=<span class="number">0xA</span>;</span><br><span class="line">  SysCtrlRegs.PCLKCR.all=<span class="number">0xffff</span>;<span class="comment">//使能外设时钟</span></span><br><span class="line">  SysCtrlRegs.HISPCP.all=<span class="number">0x1</span>;   <span class="comment">//default默认设置</span></span><br><span class="line">  SysCtrlRegs.LOSPCP.all=<span class="number">0x2</span>;   <span class="comment">//default</span></span><br><span class="line">  SysCtrlRegs.WDCR=<span class="number">0x68</span>;    <span class="comment">//disable w d</span></span><br><span class="line">  SysCtrlRegs.LPMCR0.all=<span class="number">0x0</span>;   <span class="comment">//Low power --Idle</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitGpio</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    GpioMuxRegs.GPFMUX.all=<span class="number">0x00ff</span>;    <span class="comment">//f8~f13配置为通用io口</span></span><br><span class="line">    GpioMuxRegs.GPFDIR.all=<span class="number">0x3f00</span>;<span class="comment">//方向设置为输出</span></span><br><span class="line">    GpioDataRegs.GPFDAT.all=<span class="number">0x0700</span>;<span class="comment">//右边三灯先行亮起</span></span><br><span class="line"></span><br><span class="line">    GpioMuxRegs.GPEMUX.all=<span class="number">0x0</span>;   <span class="comment">//e口全io</span></span><br><span class="line">    GpioMuxRegs.GPEDIR.all=<span class="number">0xFF</span>;<span class="comment">//全输出</span></span><br><span class="line">    GpioDataRegs.GPEDAT.all=<span class="number">0xFFFF</span>;<span class="comment">//全1</span></span><br><span class="line"></span><br><span class="line">    GpioMuxRegs.GPBMUX.all=<span class="number">0x0</span>;   <span class="comment">//b口全io，但只用到高8位</span></span><br><span class="line">    GpioMuxRegs.GPBDIR.all=<span class="number">0xFF00</span>;<span class="comment">//高8位为输出</span></span><br><span class="line">    GpioDataRegs.GPBDAT.all=<span class="number">0xff00</span>;<span class="comment">//高8位全为1，全熄灭</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GpioDataRegs.GPEDAT.all=<span class="number">0xFFFA</span>;<span class="comment">//e口最低位1010/////////为什么这里要先行配置e口</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all=<span class="number">0xFFFB</span>;<span class="comment">//e口最低位1011，锁存</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all=<span class="number">0xFFFF</span>;<span class="comment">//e口低位1111，锁存</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCputimer</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    CpuTimer0Regs.TPR.all = <span class="number">149</span>;</span><br><span class="line">    CpuTimer0Regs.TPRH.all= <span class="number">0</span>;</span><br><span class="line">    CpuTimer0Regs.PRD.all = <span class="number">999999</span>; <span class="comment">// 1秒一个timer0中断</span></span><br><span class="line">    CpuTimer0Regs.TCR.all =<span class="number">0xf000</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitCpuINT</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    <span class="comment">//extern cregister volatile unsigned int IFR;</span></span><br><span class="line">    <span class="comment">//extern cregister volatile unsigned int IER;</span></span><br><span class="line">    IFR = <span class="number">0x0</span>;</span><br><span class="line">    IER = <span class="number">0x000f</span>; <span class="comment">// 0xA for 1010 - INT2 &amp; INT4</span></span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitPIE</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EALLOW;</span><br><span class="line">    PieCtrlRegs.PIEIFR1.all = <span class="number">0x0000</span>;</span><br><span class="line"><span class="comment">//    PieCtrlRegs.PIEIER1.all = 0x0040;</span></span><br><span class="line">    PieCtrlRegs.PIEIFR2.all = <span class="number">0x0000</span>; <span class="comment">// 初始清零</span></span><br><span class="line">    PieCtrlRegs.PIEIER2.all = <span class="number">0x001f</span>; <span class="comment">// INT2.1 - INT2.5</span></span><br><span class="line">    PieCtrlRegs.PIEIFR4.all = <span class="number">0x0000</span>;</span><br><span class="line">    PieCtrlRegs.PIEIER4.all = <span class="number">0x001f</span>; <span class="comment">// INT4.1 - INT4.5</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all =<span class="number">0x0</span>;<span class="comment">//错误点</span></span><br><span class="line">    PieCtrlRegs.PIECRTL.all=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/* 中断函数定义 */</span></span><br><span class="line"><span class="comment">//    PieVectTable.TINT0 = &amp; INT_Timer;</span></span><br><span class="line">    PieVectTable.T1PINT = &amp; INT_T1;</span><br><span class="line">    PieVectTable.CMP1INT = &amp; INT_CMP1;</span><br><span class="line">    PieVectTable.CMP2INT = &amp; INT_CMP2;</span><br><span class="line">    PieVectTable.CMP3INT = &amp; INT_CMP3;</span><br><span class="line">    PieVectTable.T1CINT = &amp; INT_T1CINT;</span><br><span class="line">    PieVectTable.T3PINT = &amp; INT_T3;</span><br><span class="line">    PieVectTable.CMP4INT = &amp; INT_CMP4;</span><br><span class="line">    PieVectTable.CMP5INT = &amp; INT_CMP5;</span><br><span class="line">    PieVectTable.CMP6INT = &amp; INT_CMP6;</span><br><span class="line">    PieVectTable.T3CINT = &amp; INT_T3CINT;</span><br><span class="line">    EDIS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitEva</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EvaRegs.EXTCONA.all=<span class="number">1</span>;</span><br><span class="line">    EvaRegs.GPTCONA.all=<span class="number">0x0010</span>;<span class="comment">//定时器1比较输出使能,比较输出极性为强制低,因为用不到pwm波</span></span><br><span class="line">    EvaRegs.T1CON.all=<span class="number">0x17ca</span>;<span class="comment">//0001 0111 1100 1010连续增计数、预定标因子为/128,重载条件为立即重载，避免因为装载时间造成显示不准</span></span><br><span class="line">    EvaRegs.T1PR   =<span class="number">586</span>;</span><br><span class="line">    EvaRegs.COMCONA.all=<span class="number">0x82e0</span>;<span class="comment">//1000 0010 1110 0000使能比较操作，使能比较器输出，对比较器1/2/3输出使能</span></span><br><span class="line">    EvaRegs.ACTRA.all=<span class="number">0x1</span>;<span class="comment">//比较输出引脚CMP1输出极性设置为低有效,但其实并不用到此引脚</span></span><br><span class="line">    EvaRegs.DBTCONA.all=<span class="number">0</span>;<span class="comment">//不加死区控制</span></span><br><span class="line">    EvaRegs.T1CMPR=index;</span><br><span class="line">    EvaRegs.CMPR1=index+<span class="number">7</span>;</span><br><span class="line">    EvaRegs.CMPR2=index+<span class="number">14</span>;</span><br><span class="line">    EvaRegs.CMPR3=index+<span class="number">21</span>;</span><br><span class="line">    EvaRegs.EVAIMRA.all=<span class="number">0x018e</span>;<span class="comment">//0000 0001 1000 1110定时器1比较和周期中断使能，比较单元1/2/3比较中断使能</span></span><br><span class="line">    EvaRegs.EVAIFRA.all=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InitEvb</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EvbRegs.EXTCONB.all=<span class="number">1</span>;</span><br><span class="line">    EvbRegs.GPTCONB.all=<span class="number">0x0010</span>;<span class="comment">//定时器3比较输出使能,比较输出极性为强制低,因为用不到pwm波</span></span><br><span class="line">    EvbRegs.T3CON.all=<span class="number">0x17ca</span>;<span class="comment">//0001 0111 1100 1010连续增计数、预定标因子为/128,重载条件为立即重载，避免因为装载时间造成显示不准</span></span><br><span class="line">    EvbRegs.T3PR   =<span class="number">586</span>;</span><br><span class="line">    EvbRegs.COMCONB.all=<span class="number">0x82e0</span>;<span class="comment">//1000 0010 1110 0000使能比较操作，使能比较器输出，对比较器4/5/6输出使能</span></span><br><span class="line">    EvbRegs.ACTRB.all=<span class="number">0x1</span>;<span class="comment">//比较输出引脚CMP1输出极性设置为低有效</span></span><br><span class="line">    EvbRegs.DBTCONB.all=<span class="number">0</span>;<span class="comment">//不加死区控制</span></span><br><span class="line">    EvbRegs.T3CMPR=index+<span class="number">28</span>;</span><br><span class="line">    EvbRegs.CMPR4=index+<span class="number">35</span>;</span><br><span class="line">    EvbRegs.CMPR5=index+<span class="number">42</span>;</span><br><span class="line">    EvbRegs.CMPR6=index+<span class="number">49</span>;</span><br><span class="line">    EvbRegs.EVBIMRA.all=<span class="number">0x018e</span>;<span class="comment">//0000 0001 1000 1110定时器1比较和周期中断使能，比较单元1/2/3比较中断使能</span></span><br><span class="line">    EvbRegs.EVBIFRA.all=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Functions */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Out_redled</span> <span class="params">(redled)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GpioDataRegs.GPBDAT.all=redled;</span><br><span class="line">    GpioDataRegs.GPEDAT.all=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all=<span class="number">7</span>;</span><br><span class="line">    <span class="comment">//点右边灯</span></span><br><span class="line">    GpioDataRegs.GPBDAT.all=redled*<span class="number">256</span>;</span><br><span class="line">    GpioDataRegs.GPEDAT.all=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;&#125;</span><br><span class="line">    GpioDataRegs.GPEDAT.all=<span class="number">7</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">CPU_timer0_isr</span><span class="params">()</span>&#123;</span><br><span class="line">    PieCtrlRegs.PIEACK.all=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 只在这个中断里更改times和index */</span></span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_T1</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">// 控制左数1-8盏灯</span></span><br><span class="line">    redled = <span class="number">0xff00</span>; <span class="comment">// 点亮最左边8盏</span></span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    <span class="type">int</span> i;<span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)&#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (++times == <span class="number">20</span>)&#123;</span><br><span class="line">        times = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (++index == <span class="number">100</span>) &#123;</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        EvaRegs.T1CMPR = led_tab[index];</span><br><span class="line">        EvaRegs.CMPR1 = led_tab[(index +<span class="number">7</span>)%<span class="number">100</span>];</span><br><span class="line">        EvaRegs.CMPR2 = led_tab[(index +<span class="number">7</span>*<span class="number">2</span>)%<span class="number">100</span>];</span><br><span class="line">        EvaRegs.CMPR3 = led_tab[(index +<span class="number">7</span>*<span class="number">3</span>)%<span class="number">100</span>];</span><br><span class="line">        EvbRegs.T3CMPR = led_tab[(index +<span class="number">7</span>*<span class="number">4</span>)%<span class="number">100</span>];</span><br><span class="line">        EvbRegs.CMPR4 = led_tab[(index +<span class="number">7</span>*<span class="number">5</span>)%<span class="number">100</span>];</span><br><span class="line">        EvbRegs.CMPR5 = led_tab[(index +<span class="number">7</span>*<span class="number">6</span>)%<span class="number">100</span>];</span><br><span class="line">        EvbRegs.CMPR6 = led_tab[(index +<span class="number">7</span>*<span class="number">7</span>)%<span class="number">100</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    EvaRegs.EVAIFRA.bit.T1PINT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    EvbRegs.EVBIFRA.bit.T3PINT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_T3</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    EvbRegs.EVBIFRA.bit.T3PINT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_T1CINT</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">// 左数第1盏</span></span><br><span class="line">    redled = redled ^ <span class="number">0x0101</span>;</span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    EvaRegs.EVAIFRA.bit.T1CINT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP1</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">// 左数第二盏</span></span><br><span class="line">    redled = redled ^ <span class="number">0x0202</span>;</span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    EvaRegs.EVAIFRA.bit.CMP1INT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP2</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">// 左数第三盏</span></span><br><span class="line">    redled = redled ^ <span class="number">0x0404</span>;</span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    EvaRegs.EVAIFRA.bit.CMP2INT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP3</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">// 左数第四盏</span></span><br><span class="line">    redled = redled ^ <span class="number">0x0808</span>;</span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    EvaRegs.EVAIFRA.bit.CMP3INT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_T3CINT</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">//左数第五盏</span></span><br><span class="line">    redled = redled ^ <span class="number">0x1010</span>;</span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    EvbRegs.EVBIFRA.bit.T3CINT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP4</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">//左数第六盏</span></span><br><span class="line">    redled = redled ^ <span class="number">0x2020</span>;</span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    EvbRegs.EVBIFRA.bit.CMP4INT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP5</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">//左数第七盏</span></span><br><span class="line">    redled = redled ^ <span class="number">0x4040</span>;</span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    EvbRegs.EVBIFRA.bit.CMP5INT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line">interrupt <span class="type">void</span> <span class="title function_">INT_CMP6</span><span class="params">(<span class="type">void</span>)</span>&#123; <span class="comment">//左数第八盏</span></span><br><span class="line">    redled = redled ^ <span class="number">0x8080</span>;</span><br><span class="line">    Out_redled(redled);</span><br><span class="line">    EvbRegs.EVBIFRA.bit.CMP6INT = <span class="number">1</span>; <span class="comment">// 中断清除</span></span><br><span class="line">    PieCtrlRegs.PIEACK.all = <span class="number">8</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Main */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    DINT;</span><br><span class="line">    EALLOW;</span><br><span class="line">    Init_Sys();</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10000</span>;i++)&#123;&#125;</span><br><span class="line">    InitGpio();</span><br><span class="line"><span class="comment">//    InitCputimer();</span></span><br><span class="line">    InitCpuINT();</span><br><span class="line">    InitPIE();</span><br><span class="line">    InitEva();</span><br><span class="line">    InitEvb();</span><br><span class="line">    PieCtrlRegs.PIEACK.all =<span class="number">10</span>;</span><br><span class="line">    EDIS;</span><br><span class="line">    EINT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;<span class="keyword">asm</span>(<span class="string">&quot; IDLE&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
            <tag> 微机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制理论整理</title>
      <link href="/2026/02/24/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/"/>
      <url>/2026/02/24/%E6%8E%A7%E5%88%B6%E7%90%86%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>这门课在讲什么东西？<ul><li>控制——将一个输入信号丢到控制系统（一个黑匣子）中，得到一个输出信号</li><li>控制系统的性质、响应、稳定性，以及我们怎么去搭建控制系统</li><li>是信号分析与处理的后续课程</li></ul></li><li><p>下面我将分四章来进行阐述：</p></li><li><p>整理了PDF版本，内容跟下面差别不大，好处是可以打印而且不会出现渲染问题</p><ul><li><a href="\myfile\控制理论（乙）.pdf" target="_blank">控制理论笔记</a></li></ul></li></ul><h2 id="系统的时域分析"><a href="#系统的时域分析" class="headerlink" title="系统的时域分析"></a>系统的时域分析</h2><h3 id="信号分析与处理基础"><a href="#信号分析与处理基础" class="headerlink" title="信号分析与处理基础"></a>信号分析与处理基础</h3><div class="table-container"><table><thead><tr><th>时域</th><th>频域</th></tr></thead><tbody><tr><td>$e^{-pt}$</td><td>$\frac1{s+p}$</td></tr><tr><td>单位脉冲</td><td>$1$</td></tr><tr><td>单位阶跃</td><td>$\frac 1s$</td></tr><tr><td>单位斜坡$\gamma(t)=t$</td><td>$\frac1{s^2}$</td></tr><tr><td>单位加速度$\gamma(t)=\frac{t^2}2$</td><td>$\frac1{s^3}$</td></tr></tbody></table></div><h3 id="梅森公式与信号流图"><a href="#梅森公式与信号流图" class="headerlink" title="梅森公式与信号流图"></a>梅森公式与信号流图</h3><p>记：</p><ol><li>$P_k$为第k条前向通道的通道增益</li><li>$\Delta$为特征式：$\Delta=1-(不同回路增益之和)+(每两个互不接触的回路增益乘积之和)+(每三个\dots)$</li><li>$\Delta_k$为去除第k条前向通道后的特征式</li></ol><script type="math/tex; mode=display">P=\frac1{\Delta}\sum_kP_k\Delta_k</script><h3 id="稳态误差"><a href="#稳态误差" class="headerlink" title="稳态误差"></a>稳态误差</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ul><li>默认单位闭环传递函数，即H(s)为1。否则其定义式有分歧。</li></ul><script type="math/tex; mode=display">\begin{gather*}\frac{C(s)}{R(s)}=\frac{G(s)}{1+G(s)H(s)} \\\frac{E(s)}{R(s)}=1-\frac{C(s)H(s)}{R(s)}=\frac1{1+G(s)H(s)}\\\Rightarrow E(s)=\frac{R(s)} {1+G(s)H(s)}\,;\,e_{ss}=\text{lim}_{s\rightarrow0}\frac{sR(s)} {1+G(s)H(s)}\end{gather*}</script><h4 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h4><div class="table-container"><table><thead><tr><th></th><th>0型系统</th><th>1型系统</th><th>2型系统</th></tr></thead><tbody><tr><td>静态误差系数</td><td>位置$K<em>p=\lim</em>{s\to0}G(s)H(s)$</td><td>速度$K<em>v=\lim</em>{s\to0}sG(s)H(s)$</td><td>加速度$K<em>a=\lim</em>{s\to0}s^2G(s)H(s)$</td></tr><tr><td>有常数稳态误差的输入信号</td><td>单位阶跃</td><td>单位斜坡</td><td>单位加速度</td></tr><tr><td>稳态误差</td><td>$e_{ss}=\frac1{1+K_p}$</td><td>$e_{ss}=\frac1{K_v}$</td><td>$e_{ss}=\frac1{K_a}$</td></tr></tbody></table></div><ul><li>静态误差系数的含义：开环（或闭环）传递函数的增益，即分子的K值</li></ul><h3 id="暂态响应"><a href="#暂态响应" class="headerlink" title="暂态响应"></a>暂态响应</h3><div class="table-container"><table><thead><tr><th>指标</th><th>最大超调量$\sigma_p$</th><th>延迟时间$t_d$</th><th>上升时间$t_r$</th><th>峰值时间$t_p$</th><th>调整时间$t_s$</th></tr></thead><tbody><tr><td>定义</td><td>$\frac{Max-Final}{Final}\times100\%$</td><td>到达稳态值一半</td><td>第一次到达稳态值</td><td>第一次到达峰值</td><td>偏差小于5%或2%</td></tr><tr><td>一阶</td><td>/</td><td>/</td><td>/</td><td>/</td><td>3T或4T</td></tr><tr><td>二阶</td><td>$\text{exp}(-\frac{\xi\pi}{\sqrt{1-\xi^2}})$</td><td>/</td><td>$\frac{\pi-\text{atan}\frac{\sqrt{1-\xi^2}}{\xi}}{\omega_n\sqrt{1-\xi^2}}=\frac{\pi-\beta}{\omega_d}$</td><td>$\frac{\pi}{\omega_d}$</td><td>$\frac3{\xi\omega_n}$或$\frac4{\xi\omega_n}$</td></tr></tbody></table></div><ul><li>二阶系统的传递函数为：</li></ul><script type="math/tex; mode=display">\begin{gather*}开环:G(s)=\frac{\omega_n^2}{s(s+2\xi\omega_n)}\,;\,闭环:G(s)=\frac{\omega_n^2}{s^2+2\xi\omega_ns+\omega_n^2}\\s_1,s_2=-\xi\omega_n\pm j\omega_n\sqrt{1-\xi^2}\triangleq \sigma\pm j\omega_d\end{gather*}</script><ul><li>其典型参数为：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>$\xi$</th><th>$\omega_n$</th><th>$\omega_d$</th><th>$\beta$</th></tr></thead><tbody><tr><td>含义</td><td>阻尼比</td><td>无阻尼自然振荡角频率</td><td>阻尼自然振荡频率</td><td></td></tr><tr><td>公式</td><td>$\xi=\text{cos}\theta$</td><td></td><td>$\omega_d=\omega_n\sqrt{1-\xi^2}$</td><td>$\text{atan}\frac{\sqrt{1-\xi^2}}{\xi}$</td></tr></tbody></table></div><p><img src="\image\控制理论01.jpg" alt=""></p><h2 id="系统的频域分析"><a href="#系统的频域分析" class="headerlink" title="系统的频域分析"></a>系统的频域分析</h2><h3 id="频率响应"><a href="#频率响应" class="headerlink" title="频率响应"></a>频率响应</h3><p>​        频率响应是针对正弦输入信号所做的分析。因为所有信号均可由傅里叶变换分解为若干个正弦信号之和（详见信号分析与处理的笔记），因此掌握对于不同频率的正弦信号的频率特性是系统分析的重要一环。</p><ul><li>把开环（一般是闭环）传递函数$G(s)$中的变量$s$用$j\omega$代替（即虚轴），就得到了其频率特性$G(j\omega)$</li><li>频率特性可以直接反应对正弦信号的稳态响应：$c(t)=A|G(j\omega)|\cdot\text{sin}(\omega t+\varphi)$，其中：<ul><li>$G(j\omega)=|G(j\omega)|e^{j\varphi(\omega)}$</li></ul></li></ul><h4 id="极坐标图"><a href="#极坐标图" class="headerlink" title="极坐标图"></a>极坐标图</h4><p>以$\sigma$作为横轴，$j\omega$作为纵轴，画出$G(j\omega)$随着ω从0变化到$+\infty$时的曲线</p><ul><li>一般将其表示为$G(j\omega)=|G(j\omega)|e^{j\varphi(\omega)}$的形式，分别找到幅值和相角随着ω变化的规律<ul><li><strong>幅值：</strong>当ω=0时，0型系统在常数位置的定点，1型、2型系统在无穷远点；当ω=$\infty$时，一般而言都在0点。</li><li><strong>相角：</strong>对于分子m次，分母n次的$\nu$型系统，$\varphi(0)=-90°\nu\,\,;\,\,\varphi(+\infty)=90°(m-n)$</li></ul></li><li>ω<0的部分与ω>0的部分沿实轴对称</li><li>当ω=0的地方在无穷远点时，从0-出发顺时针绕一个半径为无穷大的圆（半圆）回到0+</li></ul><h3 id="对数坐标图"><a href="#对数坐标图" class="headerlink" title="对数坐标图"></a>对数坐标图</h3><p>注意我们一般把传递函数写成$G(s)=\frac{1+T_1s}{s^{\nu}(1+T_2s)}$的形式，但是其分界点是$\omega_i=\frac1{T_1}$，或者可以写成$G(j\omega)=\frac1{1+j\frac{\omega}{\omega_0}}$这样</p><div class="table-container"><table><thead><tr><th>典型环节</th><th>表达式</th><th>图</th><th>特点</th></tr></thead><tbody><tr><td>一阶惯性</td><td>$\frac1{Ts+1}$</td><td><img src="\image\控制理论05.png" alt=""></td><td>在$\frac1T$后以20dB/dec下降，<br />相角渐变-90°，$\frac1T$时为-45°</td></tr><tr><td>积分</td><td>$\frac1s$</td><td><img src="\image\控制理论06.png" alt=""></td><td>一直以20dB/dec下降，相角全局 -90°</td></tr><tr><td>微分</td><td>$s$</td><td><img src="\image\控制理论07.png" alt=""></td><td>一直以20dB/dec上升，相角全局+90°</td></tr></tbody></table></div><h4 id="对数坐标图的性质"><a href="#对数坐标图的性质" class="headerlink" title="对数坐标图的性质"></a>对数坐标图的性质</h4><ol><li>在伯德图的最后段，斜率为$k=-(n-m)\text{dB/dec}$，相角为$\varphi=-90°(n-m)$</li><li>对于0型系统：低频段水平，高度$20\text{lg}K_p$</li><li>对于1型系统：低频段斜率$-20\text{dB/dec}$；转折点$\omega=1$，高度$20\text{lg}K_v$；<strong>延长线交点$(K_v,0)$</strong></li><li>对于2型系统：低频段斜率$-40\text{dB/dec}$；转折点$\omega=1$，高度$20\text{lg}K_a$；<strong>延长线交点$(\sqrt{K_a},0)$</strong></li></ol><h2 id="系统稳定的四种判定"><a href="#系统稳定的四种判定" class="headerlink" title="系统稳定的四种判定"></a>系统稳定的四种判定</h2><p>劳斯判据、根轨迹、奈氏图、伯德图+余量</p><p>下面用一道题来演示一下（求该<strong>闭环系统</strong>稳定的时候K的取值范围）：</p><script type="math/tex; mode=display">G(s)=\frac{K(1-s)(1+10s)}{s^2(1+2s)}</script><h3 id="劳斯判据"><a href="#劳斯判据" class="headerlink" title="劳斯判据"></a>劳斯判据</h3><div class="table-container"><table><thead><tr><th>原理</th><th>演示</th></tr></thead><tbody><tr><td>$\begin{gather<em>}s^n&amp;a<em>0&amp;a_2&amp;a_4&amp;\dots\s^{n-1}&amp;a_1&amp;a_3&amp;a_5&amp;\dots\s^{n-2}&amp;\frac{x</em>{i+1}y<em>1-x_1y</em>{i+1}}{y_1}&amp;\dots\\vdots&amp;\vdots\s^0&amp;z_1   \end{gather</em>}$</td><td>$2s^3+(1-10K)s^2+9Ks+K=0$<br />$\begin{gather<em>}  s^3&amp;2&amp;9K\s^{2}&amp;(1-10K)&amp;K\s&amp;\frac{K(7-90K)}{1-10K} \s^0&amp;K\end{gather</em>}$</td></tr></tbody></table></div><script type="math/tex; mode=display">\begin{gather*}\Rightarrow K>0,1-10K>0,7-90K>0\\0<K<\frac7{90}\end{gather*}</script><h3 id="根轨迹图"><a href="#根轨迹图" class="headerlink" title="根轨迹图"></a>根轨迹图</h3><p>根轨迹作图法的8条规则（1.2条合起来）：</p><ol><li>连续性、对称性（实轴）</li><li>根轨迹条数=最高阶次，起点=开环极点，终点=开环零点（或无穷远）</li><li>实轴上右侧零极点数目之和为奇数的位置有根轨迹</li><li>渐近线：起点$\sigma=\frac{\Sigma(-p)-\Sigma(-z)}{n-m}$，倾角$\alpha=\frac{\pm(2k+1)\pi}{n-m}$</li><li>分离点和汇合点：$\frac{\text dK}{\text ds}=0$</li><li>出射角$\varphi_p=\mp(2k+1)\pi+\sum\lambda_i-\Sigma\Lambda_i$，入射角反一下。其中$\lambda$是零点，$\Lambda$是极点</li><li>虚轴交点—临界稳定：$s=j\omega$（相应的，求阻尼比$\xi$为特定值的点，只要$s=A(\text{cos}\theta+j\text{sin}\theta)$即可）</li><li>（补充）当$n-m\ge2$时，开环极点之和=闭环极点之和</li></ol><p><strong>非最小相位系统：</strong></p><p>把上面8条法则中的“奇数”全部换成“偶数”（2k+1换成2k）</p><p><strong>本题演示：</strong></p><p><img src="\image\控制理论02.png" alt=""></p><script type="math/tex; mode=display">\begin{gather*}s=j\omega\Rightarrow-2j\omega^3+(1-10K)(-\omega^2)+9Kj\omega+K=0\\\begin{cases}\omega^2(10K-1)+K=0\\9K\omega-2\omega^3=0 \end{cases}\\\Rightarrow K=\frac7{90}\Rightarrow K\le\frac7{90}\end{gather*}</script><h3 id="奈氏图"><a href="#奈氏图" class="headerlink" title="奈氏图"></a>奈氏图</h3><p>奈奎斯特图、幅角原理与奈奎斯特稳定判据的<strong>原理</strong>：</p><ol><li>幅角原理：s平面上的闭合曲线C顺时针包围了Z个零点和P个极点，则其在F(s)平面上的映射将沿着原点顺时针旋转$N=Z-P$圈</li><li>要判断是否稳定，需要找右半平面的点—&gt;曲线C=虚轴+半径无限大右半平面半圆</li><li>大半圆映射—&gt;定点（无意义），虚轴映射—&gt;奈奎斯特曲线恰好为极坐标图</li><li>闭环极点与开环有区别—&gt;看包围$(-1,j0)$的圈数</li><li><strong>当$Z=0$时系统稳定</strong>，因此要求$Z=N+P=0$，即$N=-P$（逆时针旋转）</li></ol><p><strong>本题演示：</strong></p><p><img src="\image\控制理论03.png" alt=""></p><script type="math/tex; mode=display">\begin{gather*}G(j\omega)=\frac{K(1+28\omega^2)+jK\omega(7-20\omega^2)}{-\omega^2(1+4\omega^2)}（上下乘分母的共轭化为实数）\\\varphi(\omega)=\text{atan}\frac{K\omega(7-20\omega^2)}{K(1+28\omega^2)}-\pi=\pi\Rightarrow\omega^2=\frac7{20}\\\Rightarrow G(j\omega)=\frac{90K}7e^{j\pi}=-\frac{90K}7\ge -1\Rightarrow K\le\frac7{90}\end{gather*}</script><h3 id="伯德图-余量"><a href="#伯德图-余量" class="headerlink" title="伯德图+余量"></a>伯德图+余量</h3><div class="table-container"><table><thead><tr><th>Name</th><th>定义</th><th>频率伯德图</th><th>判据</th></tr></thead><tbody><tr><td>相位裕量</td><td>$\gamma=180°+\varphi(\omega_c)$</td><td>增益穿越频率$\omega_c$—零分贝点</td><td>相角$\varphi(\omega_c)&gt;-180°$稳定</td></tr><tr><td>增益裕量</td><td>$K_g=\frac1{</td><td>G(j\omega)H(j\omega)</td><td>}$</td><td>相位穿越频率$\omega_g$—相角-180°点</td><td>增益$L(\omega)&lt;0$稳定</td></tr></tbody></table></div><p><strong>本题演示：</strong>（下图为临界稳定的伯德图）</p><p><img src="\image\控制理论04.png" alt=""></p><ul><li>用增益裕量的计算与上面奈氏图的计算式子几乎一样</li><li>用相位裕量的计算如下：（注：$1-s$相当于用$1+s$写，相位直接加π并反向）<ul><li>其斜率为：（-40)—(0.1)—&gt;(-20)—(0.5)—&gt;(-40)—(1)—&gt;(-20)</li><li>假设其在$\omega\in(0.5,1)$之间增益为0（这个肯定是要一步步假设的），计算$K=f(\omega)$，带入$\varphi(\omega)$使之等于0</li><li>md这题有点复杂我不太会算啊</li></ul></li></ul><h2 id="控制系统的设计"><a href="#控制系统的设计" class="headerlink" title="控制系统的设计"></a>控制系统的设计</h2><h3 id="系统的设计指标"><a href="#系统的设计指标" class="headerlink" title="系统的设计指标"></a>系统的设计指标</h3><p>​        事实上，这一小节的内容贯穿整个控制理论的课程，个人认为也是整个控制理论最重要的内容。</p><div class="table-container"><table><thead><tr><th>设计指标</th><th>时域指标</th><th>频域指标</th></tr></thead><tbody><tr><td><strong>静态性能</strong></td><td>静态误差：$e_{ss}$</td><td>静态误差系数：$K_{p,v,a}$</td></tr><tr><td><strong>动态性能</strong></td><td>时间：$t_p~,~t_s\propto\frac1{\omega_c}$<br />超调量：$\sigma_p\propto\frac1{\gamma}$</td><td>剪切频率：$\omega_c$<br />中频宽度：$h=\frac{\omega_3}{\omega_2}$</td></tr><tr><td><strong>稳定性</strong></td><td></td><td>相位裕量：$\gamma $ <br />幅值裕量：$K_g$</td></tr></tbody></table></div><ul><li><p>个人的理解是，“稳定性”是独立于静态和动态性能的一个指标，是分析整个系统的前提（倘若不稳定，就没有后续分析的必要了）。如果硬要说是哪方面的话，还是感觉跟静态性能更接近一点（可以理解为如果系统不稳定，那么系统的静态性能为无穷差）。</p></li><li><p>闭环系统中：</p><ul><li>谐振峰值：$M<em>r=\frac{M</em>{max}}{M(0)}$，与最大超调量$\sigma_p$成正比，与时间量$t_r/t_s$成反比</li><li>补充：$M_r=\frac{h+1}{h-1}=\frac1{\text{sin}\gamma }$</li></ul></li></ul><h3 id="校正装置与频率法设计"><a href="#校正装置与频率法设计" class="headerlink" title="校正装置与频率法设计"></a>校正装置与频率法设计</h3><h4 id="超前校正与滞后校正"><a href="#超前校正与滞后校正" class="headerlink" title="超前校正与滞后校正"></a>超前校正与滞后校正</h4><div class="table-container"><table><thead><tr><th></th><th>超前校正</th><th>滞后校正</th></tr></thead><tbody><tr><td><strong>表达式</strong></td><td>$\frac{1+Ts}{1+\alpha Ts}=\frac1{\alpha}\frac{s+\frac1T}{s+\frac1{\alpha T}}$</td><td>$\frac{1+Ts}{1+\beta Ts}=\frac1{\beta}\frac{s+\frac1T}{s+\frac1{\beta T}}$</td></tr><tr><td><strong>稳态性能</strong></td><td>不会改善系统的静态（稳态）性能</td><td>改变开环增益，提升稳态性能</td></tr><tr><td><strong>动态性能</strong></td><td>通过增斜率，增相位裕量提升动态性能</td><td>将斜率使剪切频率前移，降低动态性能</td></tr><tr><td><strong>原理</strong></td><td>1. 用中间<strong>+20dB/dec</strong>提穿越频率处的斜率<br />2. 用超前的相角提相位裕量，使$\omega_g$大幅后移</td><td>1. 新剪切频率$\omega_c’$处，用<strong>-20dB</strong>降幅值<br />2. 使剪切频率$\omega_c$大幅前移以提高相位裕量</td></tr><tr><td><strong>原则</strong></td><td><strong>剪切频率$\omega_c$近似不变，选在最大超前角的位置$\omega_m$</strong></td><td><strong>在新剪切频率$\omega_c’$处相角不变，幅值降20dB</strong></td></tr><tr><td><strong>步骤</strong></td><td>1. 求所需补偿的最大超前角 $\phi_m=\gamma’-\gamma+\varepsilon$<br />2. 计算参数 $\text{sin}\phi_m=\frac{1-\alpha}{1+\alpha}\rightarrow\alpha=\frac{1-\text{sin}\phi_m}{1+\text{sin}\phi_m}$<br />3. 由<strong>原则</strong>：$20\text{lg}</td><td>G_0(j\omega_m)</td><td>=10\text{lg}\frac1{\alpha}$<br />4. 由3解得$\omega_m$并带入 $\omega_m=\frac1{\sqrt{\alpha}T}$</td><td>1. 由<strong>原则</strong>：$\varphi(\omega_c’)=\gamma+\varepsilon-180°$<br />2. 由1解得$\omega_c’$并带入 $20\text{lg}</td><td>G(j\omega_c’)</td><td>=20\text{lg}\beta$<br />3. 取 $\beta = \text{max}(10,\beta)$<br />4. 取 $\omega_2=\frac1T=\frac{\omega_c}{5\sim10}$</td></tr></tbody></table></div><h4 id="滞后-超前校正"><a href="#滞后-超前校正" class="headerlink" title="滞后-超前校正"></a>滞后-超前校正</h4><script type="math/tex; mode=display">G_c(s)=\frac{(T_1s+1)(T_2s+1)}{(\frac{T_1}{\beta}s+1)(\beta T_2s+1)}~;~\beta>1~,~T_2>T_1</script><p><strong>原则：</strong>（实际上就是一个PID控制器）</p><ol><li>用超前部分来增大系统的相位裕量，改善动态性能</li><li>用滞后部分来改善系统的静态性能</li><li>相位的滞后会带来不利影响，因此很显然滞后校正的转折频率要小于超前校正</li></ol><p><strong>步骤：</strong></p><ol><li><p>求新的剪切频率 $\omega_c’$ 如下：</p><ol><li>若题目要求快速性，则用题目给的 $\omega_c’$</li><li>若题目没有对此做出要求，解方程 $\varphi(\omega_c’)=-180°$ ，作为新的剪切频率</li></ol></li><li><p><strong>滞后校正</strong></p><ol><li>见“原则3”：取 $\omega_2=\frac1T=\frac{\omega_c’}{10}$</li><li>在工程上一般选取 $\beta=10$ （见“滞后校正-步骤3”）</li></ol></li><li><p><strong>超前校正</strong></p><ol><li><p>考虑剪切频率处满足 $20\text{lg}|G(j\omega_c’)|=0$，故计算 $20\text{lg}|G_c(j\omega_c’)| =-20\text{lg}|G_0(j\omega_c)|=-K$</p></li><li><p>由下图：$20\times (\text{lg}\omega_c’-\text{lg}\omega_1)=20-K$</p><p><img src="\image\控制理论08.jpg" alt=""></p></li><li><p>注：由于已经取了 $\beta=10$，因此两个转折频率满足十倍频的关系</p></li></ol></li><li><p>校验：若不满足，取 $\omega_c’’&lt;\omega_c’$，使相位裕量进一步增大</p></li></ol><h4 id="校正装置的选取"><a href="#校正装置的选取" class="headerlink" title="校正装置的选取"></a>校正装置的选取</h4><ol><li>倘若系统稳定，稳态性能已经满足要求，相位裕量不够，那么就用超前校正</li><li>倘若系统不稳定，如果用超前校正可能会使最大超前角$\phi_m$接近甚至大于90°，这是不可实现的，因此不稳定系统需要使用滞后校正</li><li>有时使用单纯的滞后校正会使系统剪切频率 $\omega_c’$ 过小，快速性不满足要求，这个时候上滞后-超前校正</li></ol><h3 id="根轨迹法设计"><a href="#根轨迹法设计" class="headerlink" title="根轨迹法设计"></a>根轨迹法设计</h3><h4 id="超前校正"><a href="#超前校正" class="headerlink" title="超前校正"></a>超前校正</h4><p>​        不管是用哪一种方法，都遵循下面这一张图和一条最基本的原则公式：</p><p><img src="\image\控制理论09.jpg" alt=""></p><p>​        在上图中，$s_d$是我们希望校正到的闭环极点，闭环极点满足<strong>相角-180°，幅值为1</strong>的条件。各点与$s_d$连线同正$x$轴的夹角之和就是相角，因此图中的$\phi$也表示校正系统提供给原系统的补偿角。<strong>在任何一种情况下，都应该先计算补偿角。</strong>因此有：</p><script type="math/tex; mode=display">\phi+\angle G_0(s_d)=-\pi</script><div class="table-container"><table><thead><tr><th></th><th>零极点抵消法</th><th>比值$\alpha$最大法</th><th>幅值确定法</th></tr></thead><tbody><tr><td><strong>条件</strong></td><td>所希望的闭环主导极点$s_d$的正下方实轴上恰好有一开环极点</td><td>最方便，当其余两个条件都不满足时用这个</td><td>当题目对稳态误差系数$K_{p,v,a}$有要求时用幅值确定法</td></tr><tr><td><strong>例题</strong></td><td>p173 例6-6</td><td>p172 例6-5</td><td>p175 例6-7</td></tr><tr><td><strong>步骤</strong></td><td>取 $\frac1T\approx p_i$，$p_i$为该正下方极点，如$p_i=1$可取$\frac1T=1.1,1.2,0.9$等</td><td>1. 套公式：$\gamma=\frac12(\pi-\theta-\phi)$<br />2. 需要额外计算闭环增益，以满足根轨迹的幅值条件 $</td><td>G(s_d)=1</td><td>$</td><td>1. 记：$u=\frac{</td><td>s_d^{\nu}</td><td>\sum</td><td>s_d+p_i</td><td>}{\sum</td><td>s_d+z_i</td><td>}$<br />2. 计算：$\text{cot} \gamma=\frac{u/k-\text{cos}\phi}{\text{sin}\phi}$</td></tr></tbody></table></div><h4 id="滞后校正"><a href="#滞后校正" class="headerlink" title="滞后校正"></a>滞后校正</h4><p>这也太抽象了这个b滞后校正</p><ul><li>原理：给予一对非常靠近原点的偶极子 $\frac1{\tau}和\frac1{\beta\tau}$ ，使主导极点基本不变，但是静态误差系数得以提高。步骤如下：<ol><li>根据时域指标计算 $s_d$ 和增益K，并由此计算所需要放大的 $\beta$</li><li>以 $s_d$ 为原点将引线向左旋转5~10°，其与负实轴的交点就是零点 $-\frac1{\tau}$</li></ol></li></ul><h3 id="PID校正"><a href="#PID校正" class="headerlink" title="PID校正"></a>PID校正</h3><script type="math/tex; mode=display">\begin{gather*} u(t)=K_P\left[ e(t)+\frac1{T_i}\int e(t)\text dt+T_d\frac{\text de(t)}{\text dt}\right]\\G_c(s)=K_P\left[ 1+\frac1{T_is}+\frac{T_ds}{1+s\frac{T_d}N} \right] \end{gather*}</script><table>    <tr>        <th rowspan=2>比例环节</th><td>Kp↑</td><td>静态误差系数↑，静态性能↑</td>    </tr>    <tr>        <td>Kp↓</td><td>振荡↓，动态性能↑</td>    </tr>    <tr>        <th rowspan=2>积分环节</th><td>Ti↑(积分作用减弱)</td><td>响应变慢，静态性能↓</td>    </tr>    <tr>        <td>Ti↓(积分作用增加)</td><td>相位滞后，控制不及时，稳定性↓</td>    </tr>    <tr>        <th>微分环节</th><td>一般N>10</td><td>加快响应速度</td>    </tr></table><ul><li>Z-N整定公式：记 $\alpha=k\frac{\tau}T$，查表</li></ul><h3 id="极点配置法"><a href="#极点配置法" class="headerlink" title="极点配置法"></a>极点配置法</h3><p>​        题目希望引入一校正装置，使闭环系统的极点移动到指定位置。先设该校正装置的通式，带入求解，列方程。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（研）现代运动控制策略-孙丹</title>
      <link href="/2026/02/24/%E7%8E%B0%E4%BB%A3%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5/"/>
      <url>/2026/02/24/%E7%8E%B0%E4%BB%A3%E8%BF%90%E5%8A%A8%E6%8E%A7%E5%88%B6%E7%AD%96%E7%95%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>跟其他电机控制or建模笔记中保持一致，<strong>正体的$\text p$表示海氏算子，斜体的$p$表示极对数</strong>。</li></ul><h1 id="矢量控制"><a href="#矢量控制" class="headerlink" title="矢量控制"></a>矢量控制</h1><ul><li>基本概念：矢量控制也称为磁场定向控制(Field-Oriented Control, <strong>FOC</strong>)，是将异步电动机通过坐标变换转换为同步旋转的直流电动机，将定子电流矢量分解成互相解耦的励磁电流标量和转矩电流标量，从而使异步电动机模拟直流电动机的工作方式对转矩和转速进行动态控制。</li><li>解耦方向：<ul><li><strong>异步电机</strong>：M-T坐标系的M轴选定在异步电机<strong>转子全磁通</strong>方向</li><li>电励磁同步电机：M-T坐标系的M轴选定在<strong>气隙磁通</strong>方向</li><li>永磁同步电机：d-q坐标系的d轴选定在永磁同步电机<strong>转子永磁磁通</strong>方向（其实也就是气隙磁通，一样的）</li></ul></li></ul><p><strong>基频以下电压补偿控制</strong></p><p><img src="/image/djkz09.jpg" alt=""></p><div class="table-container"><table><thead><tr><th></th><th>恒气隙电势频比 $E_1/f_1$</th><th>恒电压频比 $U_1/f_1$</th><th>恒转子磁通（转子电势） $E_r/f_1$</th></tr></thead><tbody><tr><td>特点</td><td>气隙磁通 $\phi<em>m$ 恒定<br />需要补偿定子阻抗上的压降<br />n-T 曲线纯向下平移<br />低频下 $T</em>{st}$ 大，$I_{st}$ 小<br />临界转差、转矩更硬，机械特性好</td><td>类似前一个，但控制更方便<br />最大转矩 $T_{st}$ 随频率降低而减小</td><td>机械特性 n-T 为直线<br />不同同步速下，为一簇平行线<br />工作特性好，由高性能电机实现</td></tr></tbody></table></div><h2 id="坐标变换"><a href="#坐标变换" class="headerlink" title="坐标变换"></a>坐标变换</h2><p>坐标变换仍然可以参考电机建模：<a href="https://zju-paradox.top/2024/04/02/电机系统建模与分析/#坐标变化基本定义">电机系统建模与分析 | Paradox’s Website (zju-paradox.top)</a>，电机建模里面是恒幅值变换（前面有一章是恒功率变化，那里需要把系数 $\frac23$ 换成 $\sqrt{\frac23}$）。关于 $(\alpha-\beta-0)$ 到 $(d-q-0)$ 的坐标变换方式在文章里已经写的很明白了，这里不再赘述。</p><p>在画控制框图的时候，只需要简化成一个黑盒，需要对应的角度$\theta$（如异步电机就是转子磁场角度）</p><ul><li>声明：在《电机控制（年珩）》的书以及孙丹的PPT上，后续有些地方省略（漏写）了变换系数$\frac23$，所以前后会有公式不匹配的情况出现。学习的时候注意甄别，不过也不需要拘泥于具体公式，只要原理一致就行。</li></ul><h2 id="异步电机矢量控制"><a href="#异步电机矢量控制" class="headerlink" title="异步电机矢量控制"></a>异步电机矢量控制</h2><p><img src="/image/xdyk01.png" alt=""></p><script type="math/tex; mode=display">T_e=\frac32p(\varPsi_Mi_T-\varPsi_Ti_M)=\frac32p\frac{L_m}{L_{22}'}\varPsi_{rM}i_{sT}</script><p>这条电磁转矩的公式非常重要，这条公式表明，异步电机电磁转矩直接由<strong>M轴转子磁通</strong>和<strong>T轴定子电流</strong>决定。</p><p>那么，转子磁链如何计算呢？公示如下：</p><script type="math/tex; mode=display">\varPsi_{rM}=\frac{L_m}{1+T_2\text p}i_{sM}</script><p>也就是说，<strong>转子磁链仅由定子电流励磁分量$i_{sT}$</strong>确定，这样<strong>电磁转矩可由定子电流的两个分量完全控制</strong>。当然，由于上述公式里的$\text p$是海氏算子，因此表明定子电流励磁分量对转子磁通的<strong>控制有延后</strong>，因此一般维持转子磁通不变，调节定子电流的转矩分量即可实现瞬态控制。</p><h3 id="转子磁链定向"><a href="#转子磁链定向" class="headerlink" title="转子磁链定向"></a>转子磁链定向</h3><div class="table-container"><table><thead><tr><th></th><th>磁通检测—电压模型</th><th>磁通检测—电流模型</th><th>转差频率控制式</th></tr></thead><tbody><tr><td>输入</td><td><strong>定子电压 $u<em>{s\alpha\beta}$、定子电流 $i</em>{s\alpha\beta}$</strong></td><td><strong>定子电流 $i_{s\alpha\beta}$、电机转速 $\omega_r$</strong></td><td>$i<em>{sT}^*,\psi</em>{r^*},\omega$</td></tr><tr><td>过程</td><td>$\begin{gather<em>}\psi<em>{r\alpha}=\frac{L_r}{L_mp}[u</em>{s\alpha}-(R<em>s+\sigma L_sp)i</em>{s\alpha}]\\psi<em>{r\beta}=\frac{L_r}{L_mp}[u</em>{s\beta}-(R<em>s+\sigma L_sp)i</em>{s\beta}]  \end{gather</em>}$</td><td>$\begin{gather<em>}\psi<em>{r\alpha}=\frac{1}{\tau_rp}[L_mi</em>{s\alpha}-\omega \tau<em>r\psi</em>{r\beta}]\\psi<em>{r\beta}=\frac{1}{\tau_rp}[L_mi</em>{s\beta}+\omega \tau<em>r\psi</em>{r\alpha}]  \end{gather</em>}$</td><td>$\begin{gather<em>} \omega<em>s=\frac{L_mi</em>{sT}^</em>}{\tau<em>r\psi_r^*}\=\frac{\tau_rp+1}{\tau_r}\frac{i</em>{sT}}{i_{sM}}\end{gather*}$</td></tr><tr><td>输出</td><td>$\begin{gather<em>}\psi<em>r=\sqrt{\psi</em>{r\alpha}^2+\psi<em>{r\beta}^2}\\theta_M=\text{atg}(\psi</em>{r\beta}/\psi_{r\alpha})  \end{gather</em>}$</td><td>$\begin{gather<em>}\psi<em>r=\sqrt{\psi</em>{r\alpha}^2+\psi<em>{r\beta}^2}\\theta_M=\text{atg}(\psi</em>{r\beta}/\psi_{r\alpha})  \end{gather</em>}$</td><td>$\theta_M=\int(\omega_s+\omega)\text dt$</td></tr><tr><td>优点</td><td>中高速准确</td><td>中低速准确</td><td>对电机参数变化不敏感</td></tr><tr><td>缺点</td><td>对电机参数变化敏感</td><td>对电机参数变化敏感</td><td>检测不了磁链幅值</td></tr></tbody></table></div><p>注：$\sigma$为漏磁系数，计算方式为$\sigma=1-\frac{L_m^2}{Ls-L_r}$</p><p>注：前两种方法都可以得到磁链的幅值和角度，但转差频率控制式只能得到角度，这点在后面控制方式的选择上会有差异。</p><h3 id="控制框图"><a href="#控制框图" class="headerlink" title="控制框图"></a>控制框图</h3><h4 id="电压源PWM"><a href="#电压源PWM" class="headerlink" title="电压源PWM"></a>电压源PWM</h4><p><img src="/image/xdyk02.png" alt=""></p><h4 id="电流源PWM"><a href="#电流源PWM" class="headerlink" title="电流源PWM"></a>电流源PWM</h4><p><img src="/image/xdyk03.png" alt=""></p><h2 id="永磁同步电机矢量控制"><a href="#永磁同步电机矢量控制" class="headerlink" title="永磁同步电机矢量控制"></a>永磁同步电机矢量控制</h2><p>如上文所述，永磁同步电机的坐标变换直接采用d-q轴方式：</p><script type="math/tex; mode=display">\begin{bmatrix} u_d\\u_q \end{bmatrix}=R_s\begin{bmatrix} i_d\\i_q \end{bmatrix}+\begin{bmatrix} L_d&0\\0&L_q \end{bmatrix}p\begin{bmatrix} i_d\\i_q \end{bmatrix}+\omega_r\begin{bmatrix} 0&-L_q\\L_d&0 \end{bmatrix}\begin{bmatrix} i_d\\i_q \end{bmatrix}+\omega_r\psi_f\begin{bmatrix} 0\\1 \end{bmatrix}</script><script type="math/tex; mode=display">\begin{bmatrix} \psi_d\\\psi_q \end{bmatrix}=\begin{bmatrix} L_d&0\\0&L_q \end{bmatrix}\begin{bmatrix} i_d\\i_q \end{bmatrix}+\begin{bmatrix} \psi_f\\0 \end{bmatrix}</script><script type="math/tex; mode=display">T_e=\frac32p(\psi_di_q-\psi_qi_d)=\frac32 p\left [\psi_fi_q+(L_d-L_q)i_di_q\right ]</script><ul><li><p>将电磁转矩的前后两段分为<strong>励磁转矩</strong>和<strong>磁阻转矩</strong>：</p><ul><li>对于<strong>内置式</strong>永磁同步电机，$L_d &lt; L_q$，直轴电枢反应助磁产生负的电磁功率，去磁却产生正的电磁功率，因此<strong>利用直轴电枢反应去磁作用可以提高电机的输出功率</strong>，并扩大调速范围</li><li>对于<strong>表贴式</strong>永磁同步电机，$L_d = L_q$，只有励磁转矩。此时$i_d=0$控制等同于最大转矩/电流比控制</li></ul></li><li><p>跟上文中比较有区别的是，永磁同步电机的气隙磁通就是<strong>永磁磁通$\psi_f$，其幅值是一个已知的定值，角度就是转子运动角度$\theta_r$</strong>，因此不需要观测器！</p></li></ul><h3 id="控制框图-1"><a href="#控制框图-1" class="headerlink" title="控制框图"></a>控制框图</h3><h4 id="i-d-0-控制"><a href="#i-d-0-控制" class="headerlink" title="$i_d=0$控制"></a>$i_d=0$控制</h4><p><img src="/image/xdyk04.png" alt=""></p><h4 id="最大转矩电流比-MTPA-控制"><a href="#最大转矩电流比-MTPA-控制" class="headerlink" title="最大转矩电流比(MTPA)控制"></a>最大转矩电流比(MTPA)控制</h4><p>根据标幺值计算$T_e^<em>=i_d^</em>(1-i_q^*)$，在根据不同的方法算出所需的定子电流，进行电流环：</p><div class="table-container"><table><thead><tr><th>方法</th><th>公式法</th><th>查表法</th><th>探索法</th><th>高频信号注入法</th></tr></thead><tbody><tr><td>实现方式</td><td>$T_e^<em>=\sqrt{i_d^</em>(i_d^<em>-1)^3}$<br/>$T_e^</em>=\frac{i_q^<em>}2(1+\sqrt{1+4i_q^{</em>2}})$</td><td></td><td>稳态且转矩给定时，以小步长改变电电流矢量角给定值，比较不同矢量角所对应电流检测值的大小，经过多次在线校正寻优</td><td>在控制侧基波信号上，叠加高频小信号，通过对注入的高频信号的处理，分析输出转矩的变化情况调整工作点</td></tr><tr><td>优势</td><td>参数准确时计算准确迅速</td><td>在线运算少，硬件负担小</td><td>不依赖模型，鲁棒性高，无需复杂计算</td><td></td></tr><tr><td>劣势</td><td>电机参数会受到温度、磁饱和等因素影响</td><td>离线测试工作量大，无法延拓</td><td>稳态时电流矢量角在极值处振荡；动态响应性能不佳</td></tr></tbody></table></div><p><img src="/image/xdyk05.png" alt=""></p><h3 id="弱磁控制"><a href="#弱磁控制" class="headerlink" title="弱磁控制"></a>弱磁控制</h3><h4 id="电压极限椭圆"><a href="#电压极限椭圆" class="headerlink" title="电压极限椭圆"></a>电压极限椭圆</h4><p>受逆变器容量的限制，定子电流极限值$|i<em>s|&lt;|i_s|</em>{max}$，带入电压并忽略定子电阻压降，得：</p><script type="math/tex; mode=display">\begin{gather*}(e_0+x_di_d)^2+(\rho x_di_q)^2<|u_s|_{max}^2 \\或:\,\,(\psi_f+L_di_d)^2+(\rho L_di_q)^2<(\frac{|u_s|_{max}}{\omega_r})^2\\其中:\,\,凸极系数\rho=\frac{L_q}{L_d}\end{gather*}</script><p>得到<strong>电压极限椭圆</strong>：电压极限圆的两轴长度与电机转子角速度成反比，即随着速度的增大形成了逐渐变小的一簇套装椭圆（对于表贴式而言还是圆）</p><p><img src="/image/xdyk06.png" alt=""></p><p>定义：</p><ul><li><p>基速：空载电动势$e_0$达到电压极限值时的转子速度</p><ul><li><script type="math/tex; mode=display">\omega_{rb}=\frac{|u_s|_{max}}{L_mi_f}</script></li></ul></li><li><p>转折速度：在恒转矩运行区，当定子电流为额定值，定子电压达到极限值时的转子速度</p><ul><li><script type="math/tex; mode=display">\omega_{rt}=\frac{|u_s|_{max}}{\sqrt{(L_mi_f)^2+(L_si_{sN})^2}}</script></li></ul></li></ul><p><img src="/image/xdyk07.png" alt=""></p><ol><li><p>A-C段：电流调节器不饱和</p><p>电流矢量指令$is$处在电压椭圆之内，此时逆变器直流电压大于电机线电压，电流可控逆变器（通过电流调节器）迫使实际电流$is$跟随指令电流$is^*$。</p></li><li><p>A点：电流调节器饱和</p><p>电流矢量指令$i_s^*$处在电压椭圆之上，逆变器直流电压等于电机线电压，电流调节器饱和，逆变器失去电流控制能力</p></li><li><p>A-B段：调节器脱离饱和，<strong>弱磁控制</strong></p><p>$i_q$逐渐减小，<strong>负向的$i_d$逐渐增大，此时$i_d$起去磁作用，转速逐渐上升</strong></p><p>在极限时刻，$i_q$减小至0，最大转速可由电压极限椭圆方程计算得出：</p><script type="math/tex; mode=display">\omega_{r\,max}=\frac{|u_s|_{max}}{L_{md}i_f-L_d|i_d|}</script></li></ol><p>通常$|i<em>d|$不可能太大，一是受电流极限圆的限制，二是防止对磁钢的去磁；其次，$i_f&gt;|i_d|$，$L</em>{md}$与$L_d$近似相等。因此，电机转速不会增至无穷大，一般为<strong>基速的2~3 倍</strong>左右。</p><h4 id="弱磁控制方式"><a href="#弱磁控制方式" class="headerlink" title="弱磁控制方式"></a>弱磁控制方式</h4><p><strong>电流控制型：</strong></p><div class="table-container"><table><thead><tr><th></th><th>查表法</th><th>梯度下降法</th><th>负直轴电流补偿</th></tr></thead><tbody><tr><td>实现方式</td><td>根据磁链、转矩和电流之间的关系来实现弱磁控制</td><td>通过电压极限椭圆的电压递减方向和恒转矩运行曲线方向之间的夹角大小来确定电机的弱磁区域</td><td>根据PI电流环输出的参考电压矢量幅值和给定电压幅值的差值，经PI调节器之后产生d轴弱磁电流，来达到弱磁效果</td></tr><tr><td>图片</td><td></td><td><img src="/image/xdyk08.png" alt=""></td><td><img src="/image/xdyk09.png" alt=""></td></tr></tbody></table></div><p><strong>电压控制型：</strong></p><div class="table-container"><table><thead><tr><th></th><th>固定交轴电压单电流调节器</th><th>变交轴电压单电流调节器</th></tr></thead><tbody><tr><td>实现<br/>方式</td><td>交轴电压uq为定值，取代了交轴电流调节器的作用，根据电机的负载大小引入固定电压值</td><td>在定交轴电压法基础上进行优化，将定交轴电压的固定值变为随着实际转速与负载转矩变化的变化值</td></tr><tr><td>图片</td><td><img src="/image/xdyk10.png" alt=""></td><td><img src="/image/xdyk11.png" alt=""></td></tr></tbody></table></div><p><strong>相角控制型：超前角弱磁控制</strong></p><ul><li>通过控制超前角β的大小来实现弱磁控制</li><li><img src="/image/xdyk12.png" alt=""></li><li>当电机转速小于基速时，参考电压幅值低于给定电压幅值时，弱磁环节未发生作用，超前角为0，系统运行在恒转矩模式，此时相当于id=0控制；</li><li>当超过给定电压幅值时，弱磁环节开始作用，超前角值为负，此时d轴参考电流为负，进行弱磁控制</li></ul><h3 id="弱磁控制框图"><a href="#弱磁控制框图" class="headerlink" title="弱磁控制框图"></a>弱磁控制框图</h3><h4 id="负直轴电流补偿"><a href="#负直轴电流补偿" class="headerlink" title="负直轴电流补偿"></a>负直轴电流补偿</h4><p><img src="/image/xdyk13.png" alt=""></p><ul><li><strong>本质：通过电压环VT（PI）计算补偿电流$i_0$</strong></li></ul><p>详细解释一下，正常的MTPA是通过$T_e^<em>$输出$i_d^</em>$和$i_q^<em>$。而PMSM的弱磁控制需要给他增加额外的负直轴电流，那新增的这部分电流肯定是<strong>通过电压环VT(PI)来实现</strong>的，所以有这么一个<strong>“最大电压 - 观测电压 → PI环节”得到负直轴电流的环节</strong>。然后把这部分电流拿去减原本的$i_d^</em>$得到真正的$i_d^<em>$，并通过限幅得到真正的$i_q^</em>$。</p><h1 id="直接转矩控制"><a href="#直接转矩控制" class="headerlink" title="直接转矩控制"></a>直接转矩控制</h1><ul><li>矢量控制从理论上解决了交流调速系统的静、动态性能问题 ，其动态性能好，调速范围宽。</li><li>但实际应用中，转子磁链难以准确观测，系统特性受电动机参数影响较大，另外在模拟直流电动机控制过程中所用矢量旋转变换的复杂性（当时算力还不够）使得实际控制效果难以达到理论分析的结果。</li><li>转矩和磁链的控制采用Bang—Bang控制器，并在PWM逆变器中直接用这两个控制信号产生电压的PWM波形，从而避开了将定子电流分解成转矩和磁链分量，省去了矢量旋转变换和电流控制。</li><li>选择<strong>定子磁链</strong>作为被控量，而不像FOC系统那样选择转子磁链，计算磁链的电压模型<strong>不受转子参数变化的影响</strong>。</li></ul><h2 id="异步电机DTC"><a href="#异步电机DTC" class="headerlink" title="异步电机DTC"></a>异步电机DTC</h2><ul><li>说明：根据个人的理解，定子电压六边形向量的具体位置是跟电压源逆变器的结构、电压矢量的规定方向有关的：<ul><li>在年珩的《电机控制》中：电压源逆变器的<strong>开关值分别为E和0</strong>，电压矢量a相与$\alpha$轴重合，画的是相电压。</li><li>在孙丹的课件PPT中：电压源逆变器的<strong>开关值分别为E/2和-E/2</strong>，电压矢量$V_{ab}$与$\alpha$轴重合，画的是线电压。</li></ul></li><li>本教程以年珩《电机控制》中的六边形电压向量图为准：</li></ul><p><img src="/image/xdyk14.png" alt=""></p><p>在忽略定子压降的情况下，定子磁链和电压的关系可以表示为：<strong>定子磁链的变化就是定子电压×作用时间</strong></p><script type="math/tex; mode=display">\psi_s=\int(u_s-R_si_s)\text dt\Rightarrow\Delta \psi_s=u_s\Delta t</script><p><strong>电磁转矩的公式</strong>：（<strong>书里没有二分之三，应该是他写错了</strong>，但是不重要）</p><script type="math/tex; mode=display">T_e=\frac 32p(\psi_{s\alpha}i_{s\beta}-\psi_{s\beta}i_{s\alpha})=\frac{K_T}{L_m}\psi_s\psi_r\sin\theta</script><p>其中：$\psi_s$走走停停， $\psi_r$均速运行，夹角不断变化，电磁转矩脉动。但是一般可以认为：在一个开关周期内，转子磁链$\psi_r$变化很小，近似不变，所以直接调节定子磁链$\psi_s$。</p><h3 id="定子磁链观测"><a href="#定子磁链观测" class="headerlink" title="定子磁链观测"></a>定子磁链观测</h3><p>与交流电机矢量控制中的转子磁链定向类似，DTC的定子磁链也有相应的观测器</p><div class="table-container"><table><thead><tr><th></th><th>电压模型观测器</th><th><strong>电流模型观测器</strong></th></tr></thead><tbody><tr><td>输入</td><td><strong>定子电压 $u<em>{s\alpha\beta}$、定子电流 $i</em>{s\alpha\beta}$</strong></td><td><strong>定子电流 $i_{s\alpha\beta}$、电机转速 $\omega_r$</strong></td></tr><tr><td>过程</td><td>$\begin{gather<em>}\psi<em>{s\alpha}=\frac1p(u</em>{s\alpha}-R<em>si</em>{s\alpha}) \\psi<em>{s\beta}=\frac1p(u</em>{s\beta}-R<em>si</em>{s\beta})  \end{gather</em>}$</td><td>跟转子磁链定向一样<br/>$\begin{gather<em>}\psi<em>{r\alpha}=\frac{1}{T_rp+1}[L_mi</em>{s\alpha}-\omega T<em>r\psi</em>{r\beta}]\\psi<em>{r\beta}=\frac{1}{T_rp+1}[L_mi</em>{s\beta}+\omega T<em>r\psi</em>{r\alpha}]  \end{gather</em>}$</td></tr><tr><td>输出</td><td>$\begin{gather<em>}\psi<em>{s\alpha}\ \psi</em>{s\beta}\end{gather</em>}$</td><td>$\begin{gather<em>}\psi<em>{s\alpha}= \sigma L_si</em>{s\alpha}+\frac{L<em>m}{L_r}\psi</em>{r\alpha}\ \psi<em>{s\beta}= \sigma L_si</em>{s\beta}+\frac{L<em>m}{L_r}\psi</em>{r\beta} \end{gather</em>}$</td></tr><tr><td>优点</td><td>中高速准确</td><td>中低速准确</td></tr><tr><td>缺点</td><td>对电机参数变化敏感</td><td>对电机参数变化敏感</td></tr></tbody></table></div><h3 id="控制框图-2"><a href="#控制框图-2" class="headerlink" title="控制框图"></a>控制框图</h3><p><img src="/image/xdyk16.png" alt=""></p><p>其中<strong>换向逻辑</strong>的推导方式如下：</p><p><img src="/image/xdyk15.png" alt=""></p><ul><li><p>正转换向逻辑：</p><ul><li><script type="math/tex; mode=display">\begin{gather*}S_{\psi a}=S_c\\S_{\psi b}=S_a\\S_{\psi c}=S_b\end{gather*}</script></li></ul></li><li><p>反转换向逻辑</p><ul><li><script type="math/tex; mode=display">\begin{gather*}S_{\psi a}=S_a\\S_{\psi b}=S_b\\S_{\psi c}=S_c\end{gather*}</script></li></ul></li><li><p>其中：$S<em>a$表示逆变器a相的开关状态，$S</em>{\psi a}$表示a相磁链经过滞环控制器后的状态</p></li></ul><h3 id="恒转矩与恒功率控制"><a href="#恒转矩与恒功率控制" class="headerlink" title="恒转矩与恒功率控制"></a>恒转矩与恒功率控制</h3><p>与交流电机的普通变频控制一致，DTC也遵循<strong>基频以下恒转矩（磁通保持不变），基频以上恒功率（磁通随频率减小）</strong>的基本原则。</p><h4 id="基频以下"><a href="#基频以下" class="headerlink" title="基频以下"></a>基频以下</h4><ul><li><p>此时定子磁链保持恒定值不变，频率$f&lt;f_N$，磁链幅值的计算方式为：</p><ul><li><script type="math/tex; mode=display">\psi_s=U_NT_s=\frac{U_N}{2\pi f_N}</script></li></ul></li><li><p>当转速刚好等于同步速（基频）时，磁链形成六边形，每个电压空间矢量正好轮流作用六分之一个周期</p></li><li><p>但是，当转速小于同步速时，如果仍然这么做，那么<u>定子磁链速度（基频）将会快过转速（转子磁链速度）</u>，两磁链运行速度不同，根据电磁转矩的公式，只能有脉动转矩</p></li><li><p>因此，必须在6个电压空间矢量运行的过程中，<strong>加入零电压矢量，主动调节定子磁链的运行速度</strong>。</p></li></ul><h4 id="基频以上"><a href="#基频以上" class="headerlink" title="基频以上"></a>基频以上</h4><ul><li>基频以上之后，如果保持定子磁链幅值不变，那么由于电压无法增大，它走一圈的周期仍然是同步速周期。此时<u>转速（转子磁链速度）将会快过定子磁链速度（基频）</u>，同样无法形成有效电磁转矩。</li><li>所以，为了让定子磁链转动的更快，必须让他幅值变小（<strong>定子磁链轨迹是个圆，电压空间矢量在圆周上一直以基频运动，圆半径变小，运行周期就变短了</strong>）</li><li>变化方式：恒功率，所以直接和速度成反比</li></ul><h4 id="自动切换"><a href="#自动切换" class="headerlink" title="自动切换"></a>自动切换</h4><p>我看不懂</p><h3 id="圆形磁链轨迹控制"><a href="#圆形磁链轨迹控制" class="headerlink" title="圆形磁链轨迹控制"></a>圆形磁链轨迹控制</h3><p>六边形磁链轨迹控制时，磁链的切换是通过<strong>换向逻辑进行开环控制</strong>，而现在则需要通过<strong>滞环的磁链环FT进行闭环控制</strong>。</p><ul><li><p>将磁链给定值和磁链观测值作差：</p><ul><li><script type="math/tex; mode=display">\Delta \psi_s>\varepsilon_{\psi_s}\Rightarrow S_{\psi}=1\Rightarrow 需要减小磁链幅值</script></li><li><script type="math/tex; mode=display">\Delta \psi_s<\varepsilon_{\psi_s}\Rightarrow S_{\psi}=0\Rightarrow 需要增大磁链幅值</script></li></ul></li><li><p>由此<strong>得到$4\times6$的逆变器开关状态表</strong>：</p><ul><li>4列：由磁链滞环控制信号$S_{\psi}$（2状态）和转矩滞环控制信号$S_T$（2状态）组合</li><li>6行：定子磁链的扇区，每个扇区匹配的定子电压空间矢量自然是不同的</li></ul></li><li><p><img src="/image/xdyk18.png" alt=""></p><ul><li>当然这里变成$6\times6$的了，是他把转矩滞环控制信号$S_T$拓展成了3状态，本质差不多。</li></ul></li></ul><h2 id="永磁同步电机DTC"><a href="#永磁同步电机DTC" class="headerlink" title="永磁同步电机DTC"></a>永磁同步电机DTC</h2><p>类似的，有：</p><script type="math/tex; mode=display">T_e=\frac32\frac1{L_s}p\,\psi_s\psi_f\sin\theta</script><p>若保持定子磁链幅值$|\psi_s|$恒定，则永磁同步电机电磁转矩与$\sin\theta$成正比。即可通过控制定子磁链幅值恒定，改变定子磁链旋转速度和方向来瞬时调整转矩角，实现转矩的动态控制，这正是直接转矩控制的基本思想</p><p>不是我™搞不明白同样的东西她PPT里放两遍干嘛</p><h3 id="空间矢量调制DTC"><a href="#空间矢量调制DTC" class="headerlink" title="空间矢量调制DTC"></a>空间矢量调制DTC</h3><ul><li><p>原本：逆变器只提供八个基本电压空间矢量，且在一个甚至多个采样周期中逆变器开关状态始终保持不变。</p></li><li><p>现在：引入了空间矢量调制方法（SVM），根据实际需要的电压矢量，对逆变器提供的八个基本矢量进行调制，即采用两种以上有效空间矢量及零矢量，按需要的时间长短作用，以最终获得所期望的空间矢量</p></li><li><p>基本原理：把任意一个<strong>电压矢量分解为矢量所在扇区相邻的两个开关电压矢量和零矢量</strong></p><ul><li><p><img src="/image/xdyk19.png" alt=""></p></li><li><script type="math/tex; mode=display">\vec {u_s}=\frac{T_1}T\vec {u_1}+\frac{T_2}T\vec{u_2}</script></li></ul></li><li><p>由于这个时候需要准确的磁链位置来使系统能够计算所需的电压，因此<strong>使用普通的转矩环(PI)和磁链环来代替滞环</strong>。（所以这个时候没有滞环了）</p></li></ul><p><img src="/image/xdyk20.png" alt=""></p><h1 id="开绕组与双三相电机"><a href="#开绕组与双三相电机" class="headerlink" title="开绕组与双三相电机"></a>开绕组与双三相电机</h1><p>这部分考试基本不考，仅做了解（因为我们这届被国庆冲了一节课，没冲的话不好说）</p><h2 id="开绕组PMSM"><a href="#开绕组PMSM" class="headerlink" title="开绕组PMSM"></a>开绕组PMSM</h2><p>大概拓扑就是：三相变压变流器 - 电机 - 三相变压变流器（把原本电机中连在一起的三相绕组中性点打开，Y连接的连接处换成了三相变压变流器），能达到更大的功率，并放开零序电流。</p><ul><li>多种控制方法<ul><li>电压二分法</li><li>交替钳位法</li><li>统一空间矢量调制法</li><li>共直流母线型</li></ul></li></ul><p>常规的控制方式就是在原有FOC/DTC的基础上，将$u<em>{\alpha}/u</em>{\beta}$经过开关控制输入到逆变器这一环节复制一份，形成两份开关表，分别送到电机两端的两个三相变压变流器（逆变器）中。</p><h2 id="双三相PMSM"><a href="#双三相PMSM" class="headerlink" title="双三相PMSM"></a>双三相PMSM</h2><p>低压大功率输出</p><h1 id="永磁同步电机模型预测控制MPC"><a href="#永磁同步电机模型预测控制MPC" class="headerlink" title="永磁同步电机模型预测控制MPC"></a>永磁同步电机模型预测控制MPC</h1><ul><li>优势：控制思想直观、处理多约束能力强、动态响应快、多目标优化灵活</li><li>思路：预测模型、滚动优化、反馈校正</li><li>分类：与永磁同步电机的FOC策略与DTC策略结合<ul><li>MPCC：使用模型预测控制器代替FOC中的电流环PI控制器</li><li>MPTC：使用模型预测控制器的定量控制代替DTC中滞环控制器的定性控制</li><li>MPFC：使用模型预测控制器的定量控制代替DTC中定子磁链滞环控制器的定性控制</li></ul></li><li>本质：对系统<strong>未来状态变量的预测</strong>；在系统当前状态的基础上，根据<strong>代价函数最小化</strong>原则，在<strong>控制集范围内</strong>对控制结果进行评估，从而得到最优控制量（施加的电压矢量）并输出</li><li>控制：将传统控制器输出得到的<strong>Reference值($\,^*$)</strong>和模型预测得到的<strong>k+1时刻值</strong>共同<strong>输入到objFcn优化评估</strong>中。</li></ul><h2 id="代价函数-Cost-Fcn"><a href="#代价函数-Cost-Fcn" class="headerlink" title="代价函数 Cost Fcn"></a>代价函数 Cost Fcn</h2><p>一般采用常规的权重法来平衡这一多目标优化问题：</p><script type="math/tex; mode=display">J=\sum_k\lambda_kJ_k</script><p>常见的代价函数采用<strong>预测值和给定值的一阶范数</strong>：</p><p><img src="/image/xdyk21.png" alt=""></p><h2 id="不同MPC控制策略"><a href="#不同MPC控制策略" class="headerlink" title="不同MPC控制策略"></a>不同MPC控制策略</h2><h3 id="PMSM-MPCC"><a href="#PMSM-MPCC" class="headerlink" title="PMSM-MPCC"></a>PMSM-MPCC</h3><p>在转子磁场定向下建立的d-q坐标系，其中$\psi<em>{rd}=\psi_r，\psi</em>{rq}=0$，对电机的电流状态方程式进行欧拉离散，得到预测方程</p><script type="math/tex; mode=display">i_{sq}(k+1)=f(i_{sd}(k),i_{sq}(k),u_{sq}(k))\,\,\,(i_{sd}类似)</script><p>得到以电流为控制目标的目标函数：</p><script type="math/tex; mode=display">J=|i_d^*(k+1)-i_d(k+1)|+|i_q^*(k+1)-i_q(k+1)|</script><p><img src="/image/xdyk22.png" alt=""></p><p>说明：</p><ul><li>这里应该是表贴式PMSM，所以采用了$i_d=0$的FOC，如果要用MTPA的话也差不多</li><li><strong>一次模型预测控制要计算7次</strong>，即分别带入7个电压开关矢量去（6个有效电压矢量+1个零矢量）计算代价函数$J$的大小并比较。</li></ul><h3 id="PMSM-MPTC"><a href="#PMSM-MPTC" class="headerlink" title="PMSM-MPTC"></a>PMSM-MPTC</h3><p>根据电机基本方程，选取状态变量$i<em>{s\alpha},i</em>{s\beta},\psi<em>{s\alpha},\psi</em>{s\beta}$ ，并假定$\omega(k)=\omega(k+1)$，可以得到电机定子磁链、电流和电磁转矩的欧拉离散公式：</p><script type="math/tex; mode=display">\begin{gather*}\psi_{s\alpha}(k+1)=f(\psi_{s\alpha}(k),i_{s\alpha}(k),u_{s\alpha}(k))\,\,\,(\beta一样)\\i_{s\alpha}(k+1)=f(\psi_{s\alpha}(k),i_{s\alpha}(k),i_{s\beta}(k),u_{s\alpha}(k),u_{s\beta}(k))\,\,\,(\beta一样)\end{gather*}</script><p>得到以磁链和转矩为控制目标的目标函数：</p><script type="math/tex; mode=display">J_1=|T_e^*-T_e^{k+1}|+K_{\psi}|\psi_s^*-\psi_s^{k+1}|</script><p><img src="/image/xdyk23.png" alt=""></p><p>同样，<strong>一次模型预测控制要计算7次</strong>，即分别带入7个电压开关矢量去（6个有效电压矢量+1个零矢量）计算代价函数$J$的大小并比较。需要调节因子系数整定工作；对系统参数依赖大。</p><h3 id="PMSM-MPFC"><a href="#PMSM-MPFC" class="headerlink" title="PMSM-MPFC"></a>PMSM-MPFC</h3><p>改进评估函数，消除调节因子系数，提出模型预测磁链控制</p><script type="math/tex; mode=display">\varPsi_{s,dq}^*=\psi_f+j(L_qT_e^*/1.5N_p\psi_f) \triangleq \psi_d+j\psi_q \\J=|\varPsi_{s,dq}^*-\varPsi_{s,dq}^{k+1} |</script><p>传统MPTC中转矩、定子磁链幅控制目标可以转化为对定子磁链矢量的单一控制</p><h1 id="并网逆变器-网侧PWM-控制"><a href="#并网逆变器-网侧PWM-控制" class="headerlink" title="并网逆变器(网侧PWM)控制"></a>并网逆变器(网侧PWM)控制</h1><div class="table-container"><table><thead><tr><th><img src="/image/xdyk24.png" alt=""></th><th><img src="/image/xdyk25.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>假设三相电网电压对称，将坐标系<strong>d轴定向于电网电压矢量</strong>，稳态时各状态变量的导数等于零，得到：</p><script type="math/tex; mode=display">\begin{gather*}u_{gd}=& \sqrt{\frac32}U_g&=Ri_{gd}-\omega_1Li_{gq}+v_{gd}\\u_{gq}=& 0&=Ri_{gq}+\omega_1Li_{gd}+v_{gq}\end{gather*}</script><p>负载电流：</p><script type="math/tex; mode=display">i_{load}=(S_di_{gd}+S_qi_{gq})-C\frac{\text dV_{dc}}{\text dt}</script><ul><li>并网逆变器的主要的功能是保持<strong>直流母线电压$V_{dc}$的稳定</strong>、<strong>输入电流正弦</strong>和<strong>控制输入功率因数</strong>。</li><li>并网逆变器的控制本质是控制瞬间流入流出的<strong>有功和无功功率</strong><ul><li>对交流侧有功功率 $P$ 的控制实际上就是对输入电流有功分量 $i_{gd}$ 的控制</li><li>对交流侧无功功率 $Q$ 的控制实际上就是对输入电流有功分量 $i_{gq}$ 的控制</li></ul></li><li>整个网侧PWM变换器的控制系统可以分为两个环节：<strong>电压外环控制</strong>及<strong>电流内环控制</strong></li></ul><script type="math/tex; mode=display">\begin{gather*}\begin{bmatrix} P\\Q  \end{bmatrix}=u_{gd}\begin{bmatrix} i_{gd}\\-i_{gq}  \end{bmatrix}\end{gather*}</script><h2 id="矢量控制VOC"><a href="#矢量控制VOC" class="headerlink" title="矢量控制VOC"></a>矢量控制VOC</h2><ul><li>将VSC网侧交流电流分解成有功、无功分量，采用2个PI电流调节器控制2分量电流，实现有功、无功功率的间接控制</li><li>在网侧PWM变换器的电流控制中，以电网电压矢量d轴定向的电压电流双闭环控制最为广泛</li><li>缺点：<ul><li>有复杂的坐标旋转变换</li><li>电流调节器整定难，特性受运行状态变化大</li><li><u>电网电压不平衡时</u>必须分解成正负序两套系统下实施d-q解耦控制</li><li>PI为线性控制器难满足非线性系统的优化控制</li></ul></li></ul><p><img src="/image/xdyk26.png" alt=""></p><h2 id="直接功率控制DPC"><a href="#直接功率控制DPC" class="headerlink" title="直接功率控制DPC"></a>直接功率控制DPC</h2><ul><li>根据：<ul><li>瞬时有功、无功功率的误差 </li><li>VSC交流侧电压矢量的空间位置</li></ul></li><li>采取二位滯环调节器，从优化的开关表中选择VSC三相开关状态（即电压空间矢量），直接控制产生的瞬时功率大小，达到消除功率误差的目的</li><li>优点：<ul><li>功率调节动态响应快</li><li>无需矢量旋转变换、线性PI调节器及其引发缺陷</li><li><u>能适应不平衡电压下的控制</u></li></ul></li><li>缺点：<ul><li>静态性能优劣取决滯环调节器带宽，有静动态特性矛盾</li><li>VSC开关频率不恒定，带来滤波器设计困难、电流波形畸变、损耗发热及冷却有问题</li><li>动态性能还与电网、负载及运行工况有关</li></ul></li></ul><script type="math/tex; mode=display">\begin{gather*}\text p\begin{bmatrix}P_s\\Q_s \end{bmatrix}=\frac32\frac1{L_s}\omega_1\psi_{sd}\,\,\text p\begin{bmatrix}-\psi_{cq}\\\psi_{cd} \end{bmatrix}=\frac32\frac1{L_s}\omega_1\psi_{sd}\,\,\begin{bmatrix}-V_{cq}\\V_{cd} \end{bmatrix}\end{gather*}</script><ul><li>控制所施加的电压矢量, 可控制VSC磁链$\psi_c$的变化；</li><li>磁链矢量沿所施加的电压矢量方向运动， 运动速度正比于电压矢量的大小</li><li>查表</li></ul><p><img src="/image/xdyk32.png" alt=""></p><h2 id="模型预测控制MPVOC"><a href="#模型预测控制MPVOC" class="headerlink" title="模型预测控制MPVOC"></a>模型预测控制MPVOC</h2><ul><li>优点：<ul><li>直接计算最优开关状态，没有内环PI调节器和调制器的延迟，因此动态响应极快</li><li>多目标控制、处理约束方便</li></ul></li><li>缺点：<ul><li>计算负担重、没有固定的开关频率</li><li>依赖模型精度，对电机参数变化敏感</li></ul></li></ul><p>根据在k时刻的瞬时电压、电流，可得k+1时刻的瞬时电压、电流。目标函数可<strong>以电压、电流的指令值与反馈值的误差平方为基础</strong>：</p><script type="math/tex; mode=display">G=\lambda_1[i_L(k+1)-i_{L,ref}]^2+\lambda_2[u_c(k+1)-u_{c,ref}]^2</script><p><img src="/image/xdyk33.png" alt=""></p><h2 id="模型预测控制MPDPC"><a href="#模型预测控制MPDPC" class="headerlink" title="模型预测控制MPDPC"></a>模型预测控制MPDPC</h2><p>直接功率控制DPC当然是要直接控制系统功率，所以代价函数为有功指令值与反馈值误差的平方、无功指令值与反馈值误差的平方之和。其中系统有功指令是直流母线PI控制器的输出与母线电压的乘积，无功功率为0。</p><script type="math/tex; mode=display">G=\lambda_1[p_{ref}-p(k+1)]^2+\lambda_2[0-q(k+1)]^2</script><p>通过<strong>对代价函数推算求得最优电压矢量</strong>，将最优电压矢量送入SVPWM 模块，实现了功率内环的最优控制</p><p><img src="/image/xdyk34.png" alt=""></p><h1 id="参数辨识与无传感器控制"><a href="#参数辨识与无传感器控制" class="headerlink" title="参数辨识与无传感器控制"></a>参数辨识与无传感器控制</h1><p>主要讲<strong>离线</strong>辨识</p><h2 id="定子电感——高频信号注入法"><a href="#定子电感——高频信号注入法" class="headerlink" title="定子电感——高频信号注入法"></a>定子电感——高频信号注入法</h2><p>将转子堵转，并向定子注入高频旋转电压信号，根据高频电流响应提取定子电感</p><p>向定子通入高频电压矢量$U_{sh}$，频率较高时，忽略电阻压降，将转子堵转，使反电势为0。通过提取电流的正负序分量可以分别计算得到直轴和交轴电感</p><h2 id="定子磁链——反电势提取法"><a href="#定子磁链——反电势提取法" class="headerlink" title="定子磁链——反电势提取法"></a>定子磁链——反电势提取法</h2><p> 根据空载恒转速条件下反电势与转子磁链的线性关系计算转子磁链</p><p>空载时，可近似认为端电压等于反电势。采用矢量控制方案使电机以恒定转速空载运行，测量此时的给定电压指令，计算出转子磁链：</p><script type="math/tex; mode=display">\psi_f=u_s/\omega_e</script><h2 id="转动惯量"><a href="#转动惯量" class="headerlink" title="转动惯量"></a>转动惯量</h2><h3 id="人工轨迹法"><a href="#人工轨迹法" class="headerlink" title="人工轨迹法"></a>人工轨迹法</h3><p>在恒负载条件下，忽略摩擦系数，给定两个不同的转矩电流，可以得到两个机械运动方程。</p><p>设置控制器参数使电机进行匀加速或匀减速运动，计算不同转矩下的加速度，通过离散化作差可以计算出转动惯量。</p><h3 id="自由减速法、限转矩幅加速度法"><a href="#自由减速法、限转矩幅加速度法" class="headerlink" title="自由减速法、限转矩幅加速度法"></a>自由减速法、限转矩幅加速度法</h3><p>转动惯量的离线辨识都是特定的条件下测量转速的响应，再根据机械运动方程实现辨识，三种方法原理类似</p><h2 id="高频信号注入法-旋转高频电压"><a href="#高频信号注入法-旋转高频电压" class="headerlink" title="高频信号注入法 - 旋转高频电压"></a>高频信号注入法 - 旋转高频电压</h2><p>在电机出线端注入一个<strong>三相平衡的高频电压（或电流）信号</strong>，利用电机内部固有的或人为的（如对电机进行改造）不对称性，使电机产生一个<strong>可检测的磁凸极</strong>，通过检测对应的高频电流（或电压）响应来获取转子位置和速度信息。</p><ul><li>高频信号注入法的特点：<ul><li>在观测器的带宽内，观测器对转动惯量的误差不敏感，因此跟踪观测器<u>必须有足够的带宽</u></li><li>凸极模型为一个<u>相位和估计的转子位置角（电角度）有关的单位矢量</u>，凸极跟踪过程与负相序高频电流分量的幅值大小没有直接的关系，因此对<u>电机参数的变化不敏感</u></li><li>观测器的机械系统模型中电磁转矩的前馈输入使得观测器在跟踪过程中没有滞后，即具有<u>零滞后</u>特性</li></ul></li></ul><p><img src="/image/xdyk27.png" alt=""></p><p>经过一通化简，反正得到：<strong>只有负相序高频电流分量的相位中包含转子位置信息</strong></p><script type="math/tex; mode=display">i_{qdi}=i_{ip}e^{(\theta_i(t)-\pi/2)}+i_{in}e^{(2\theta_r-\theta_i(t)+\pi/2)}</script><p>把高频电流矢量通过坐标变换，变换到一个<u>与注入的高频电压矢量同步旋转的参考坐标系</u>中，<strong>正相序高频电流矢量变成直流</strong>，通过常规的高通滤波器予以滤除。下图是<strong>嵌入式PMSM</strong>的旋转高频电压注入法<strong>矢量控制</strong>框图</p><p><img src="/image/xdyk28.png" alt=""></p><p><img src="/image/xdyk29.png" alt=""></p><p>过程解释如下：</p><ol><li>在<strong>定子</strong>电压中注入高频<strong>旋转</strong>电压信号(dq)</li><li>从定子<strong>电流检测值</strong>中进行读取</li><li>经过<strong>带通滤波器BPF</strong>得到高频旋转电流信号$i_{qds_i}^i$</li><li>经过<strong>同步轴系高通滤波器SPF</strong>得到电流的<strong>负序</strong>分量$i_{qds_in}^i$</li><li>从（<strong>转子位置跟踪观测器</strong>）中读取转子转速和位置</li></ol><h2 id="转子位置自检测-参考模型自适应法-MARS"><a href="#转子位置自检测-参考模型自适应法-MARS" class="headerlink" title="转子位置自检测 - 参考模型自适应法(MARS)"></a>转子位置自检测 - 参考模型自适应法(MARS)</h2><p>只根据注入的高频电压和凸极相互作用产生的高频电流信号无法正确区分电机的N极和S极</p><p>MARS法的基本思想：</p><ul><li>具有相同物理意义输出量的模型：同时工作，利用<u>输出量的差值</u>，根据合适的<strong>自适应率</strong>来实时调节可调模型的参数，以达到<u>控制对象输出跟踪参考模型</u>的目的<ul><li>可调模型：含有待估计参数的方程</li><li>参考模型：不含未知参数的方程</li><li>自适应率：比如PI，将差值经自适应率后返回可调模型</li></ul></li><li>优势：<ul><li>模型参考自适应法是基于稳定性设计的参数辨识方法，能保证参数估计的渐进收敛，具有良好的动态性能。适合中高速运行。</li></ul></li><li>劣势：<ul><li>对电机参数的变化比较敏感。低速时会由于电流检测和参数估计精度的限制, 及逆变器非线性的影响，导致转子速度和位置无法精确估计</li></ul></li></ul><h3 id="定子电流数学模型"><a href="#定子电流数学模型" class="headerlink" title="定子电流数学模型"></a>定子电流数学模型</h3><ul><li>参考模型：PMSM电机本体（反馈检测到电流？）</li><li>可调模型：电流模型（采用电阻电感计算到的电流？）</li><li>采用并联型结构辨识转速</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"><img src="/image/xdyk30.png" alt=""></th><th style="text-align:center"><img src="/image/xdyk31.png" alt=""></th></tr></thead><tbody><tr><td style="text-align:center">局部模型</td><td style="text-align:center">整体模型</td></tr></tbody></table></div><ul><li>当然，可以采用中低速时使用高频信号注入、中高速时使用MARS法，中速段用线性变化的权重共同作用的方式控制。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 研究生 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力电子技术</title>
      <link href="/2026/02/24/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/"/>
      <url>/2026/02/24/%E7%94%B5%E5%8A%9B%E7%94%B5%E5%AD%90%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>下文中公式出现 $$$$ ，<code>\</code> 等形式就是没渲染好，最好开翻墙…因为确实有点卡</li><li><strong>整理了PDF版本，内容跟下面差别不大，好处是可以打印而且不会出现渲染问题</strong><ul><li><a href="\myfile\电力电子技术笔记.pdf" target="_blank">电力电子技术笔记PDF</a></li></ul></li><li><strong>由于考试周有另外的事情，时间不够了，中间有内容没整理完的，好像是逆变最后还有哪里来着。</strong></li></ul><h1 id="功率半导体器件"><a href="#功率半导体器件" class="headerlink" title="功率半导体器件"></a>功率半导体器件</h1><h2 id="分类与基本型"><a href="#分类与基本型" class="headerlink" title="分类与基本型"></a>分类与基本型</h2><div class="table-container"><table><thead><tr><th>管子</th><th>分类</th><th>特点</th><th>参数</th></tr></thead><tbody><tr><td>大功率二极管D</td><td>不可控<br />电压驱动</td><td>开通呈电感效应<br />关断：反向电流与电压</td><td>额定电流（正向平均）：$I<em>F$<br />额定电压（反向重复）：$U</em>{RRM}$<br />正向平均电压：$U_F$</td></tr><tr><td>晶闸管SCR</td><td>半控型<br />电流驱动</td><td>三端$(A,K,G)$四层<br />阳极a门极g共同控制<br />1. 关断：$I_a<I_H$<br />2. 正向阻断：一段时间反压</td><td>断态重复峰值电压：$U<em>{DRM}$<br />反向重复峰值电压 ：$U</em>{RRM}$<br />额定电压：$U<em>R=\min{U</em>{DRM},U<em>{RRM}}$<br />额定（通态平均）电流：$I</em>{T(AV)}=\frac{1.5\sim2}{1.57}I_T$<br />维持电流：$I_H$<br />擎住电流：$I_L$</td></tr><tr><td>大功率晶体管GTR</td><td>全控型<br />电流驱动</td><td>相当于一个大三极管<br />一般工作在（准）饱和区和截止区</td><td>集电极额定电压：$U<em>{CEM}$<br />饱和压降：$U</em>{CES}$</td></tr><tr><td>功率场效应晶体管P-MOSFET</td><td>单极型<br />全控型<br />电压驱动</td><td>$g<em>m=\frac{\Delta i_D}{\Delta U</em>{GS}}$<br />当$U<em>{GS}&gt;U</em>{th}$时导通<br />对同一个$U_{GS}$，$i_D$基本相同</td><td>通态电阻：$R_{DS(on)}$</td></tr><tr><td>绝缘栅双极型<br />晶体管IGBT</td><td>全控型<br />电压驱动</td><td>$U<em>G$等效于三极管的$U</em>{be}$<br />但一般在15V附近</td></tr></tbody></table></div><h2 id="各管特性"><a href="#各管特性" class="headerlink" title="各管特性"></a>各管特性</h2><h3 id="晶闸管SCR"><a href="#晶闸管SCR" class="headerlink" title="晶闸管SCR"></a>晶闸管SCR</h3><ul><li>晶闸管是一个三端$(A,K,G)$四层$(P<em>1-N_1-P_2-N_2)$的半导体器件，同时承受正向阳极电压 $V</em>{AK}$ 和正向门极电压 $V_{GK}$ 才能导通。称维持晶闸管从阻断转为导通并撤除 $V_G$ 时的最小电流为<strong>擎住电流</strong> $I_L\approx(2\sim4)I_H$。</li><li>要使晶闸管关断，需使其阳极电流 $I_a$ 降低到<strong>维持电流</strong> $I_H$ （几十毫安）以下。但是要使其真正关断（恢复正向阻断能力），必须加一定时间<strong>反压</strong>（因此导致晶闸管不能应对高频）。</li><li>用 $I<em>T$ 表示晶闸管流过的<strong>电流有效值</strong>，其<strong>额定电流</strong> $I</em>{T(AV)}$ 是有效值转为平均值后的1.5~2倍，故 $I_{T(AV)}=\frac{1.5\sim2}{1.57}I_T$。</li></ul><h3 id="大功率晶体管GTR"><a href="#大功率晶体管GTR" class="headerlink" title="大功率晶体管GTR"></a>大功率晶体管GTR</h3><ul><li>相当于高中学的三极管，一般工作在（准）饱和区和截止区。在关断时，会由于“除去基区超量储存电荷”和 $C_{be}$ 引起一点时间的反向电流。</li><li><strong>二次击穿现象</strong>：考虑 $I<em>C-U</em>{CE}$ 曲线，正常情况下随着 $U<em>{CE}$ 增大，$I_C$ 基本不变，但是当 $U</em>{CE}$ 过大时，会使 $I_{C}$ 开始增大（一次击穿，可逆）然后瞬间击穿三极管使电压大幅减小（二次击穿，不可逆），电流很大。</li></ul><h3 id="场效应晶体管P-MOSFET"><a href="#场效应晶体管P-MOSFET" class="headerlink" title="场效应晶体管P_MOSFET"></a>场效应晶体管P_MOSFET</h3><ul><li>场效应晶体管是多数载流子器件，不存在少数载流子特有的存储效应，因此开关时间短，可高频运行。其 $i<em>D-U</em>{DS}$ 曲线与GTR的 $I<em>C-U</em>{CE}$ 曲线十分接近。</li><li>P-MOSFET时电压控制器件（比电流型简单多了），但是通态压降大，不适用于大功率</li></ul><h3 id="绝缘栅双极型晶体管IGBT"><a href="#绝缘栅双极型晶体管IGBT" class="headerlink" title="绝缘栅双极型晶体管IGBT"></a>绝缘栅双极型晶体管IGBT</h3><ul><li><strong>擎住效应</strong>：当通态集电极电流大于某临界值（静态擎住），或关断过程中电压变化速率过快（动态擎住）会导致寄生晶闸管导通，栅极对器件失控。</li></ul><h1 id="驱动与保护"><a href="#驱动与保护" class="headerlink" title="驱动与保护"></a>驱动与保护</h1><h2 id="晶闸管"><a href="#晶闸管" class="headerlink" title="晶闸管"></a>晶闸管</h2><p>​        晶闸管触发电路的作用是将控制信号 $U_k$ 转变为控制角 $\alpha$ 信号，向晶闸管提供门极电流，以决定各个晶闸管的导通时刻。</p><h3 id="锯齿波同步移相触发器"><a href="#锯齿波同步移相触发器" class="headerlink" title="锯齿波同步移相触发器"></a>锯齿波同步移相触发器</h3><p><img src="/image/电力电子1.jpg" alt=""></p><ol><li><strong>同步检测：</strong>当左下角正弦同步电压 $u<em>{TB}$ 由正变负时，开关管 $V</em>{T2}$ 截止，开始形成锯齿波，此即为“同步”。锯齿波的宽度=电容 $C<em>2$ 的充电时间=开关管 $V</em>{T2}$ 的截止时间。当开关管 $V<em>{T2}$ 左侧的 Q 点被充电到 1.4V 时钳位，开关管导通，因此可以通过调节 Q点的充电时间常数 RC 来调整开关管 $V</em>{T2}$ 的截止时间。</li><li><strong>锯齿波形成：</strong>红色虚线框中近似为恒流源，通过 $C<em>2$ 充电，开关管 $V</em>{T2}$ 放电。充电为恒流源，放电时间极快，因此近似为不连续（具有零电压）的锯齿波。</li><li><strong>移相控制：</strong>通过下方的两个电压 $u_k,u_P$ 来对锯齿波（$0\sim V_M$）进行一个向下的平移（$-\Delta v\sim V_M-\Delta V$）。平移后锯齿波与零的交点不再是原点，这个偏移的角度基本等于移相角（实际上是与 0.7V 的交点，考虑到晶体管 $VT_4$ 的发射极压降）</li><li><strong>脉冲的形成与放大：</strong>当 $VT<em>4$ 开通（锯齿波电压&gt;0.7V）时，A 点低电平，$VT_5$ 关断，后续一系列管子全部导通，使 $u</em>{c8},u<em>B$ 瞬间低电平。后续 $C_3$ 迅速充电使$VT_5$ 导通，后续一系列管子全部关断，$u</em>{c8},u_B$ 重新变高。</li><li><strong>强触发脉冲：</strong>变压器将 $u_B$ 瞬间变化的这一段截出来，得到一个窄脉冲（大概是这样，这块讲的不是很清楚）</li></ol><p><img src="/image/电力电子2.jpg" alt=""></p><h3 id="同步的实现（附例题）"><a href="#同步的实现（附例题）" class="headerlink" title="同步的实现（附例题）"></a>同步的实现（附例题）</h3><p>同步：晶闸管阳极电压和同步电压协调、相互配合工作，我们需要确定同步信号 $u_{Ta}$ 与对应晶闸管阳极电压 $u_a$ 之间的相位关系。下面直接给出结论，表格内是<strong>同步电压 $u_T$ 相对于主电压的相位关系</strong>。</p><div class="table-container"><table><thead><tr><th></th><th>正弦波移相</th><th>锯齿波移相</th></tr></thead><tbody><tr><td><strong>NPN晶体管</strong></td><td>滞后120°</td><td>反相</td></tr><tr><td><strong>PNP晶体管</strong></td><td>超前60°</td><td>同相</td></tr></tbody></table></div><p><img src="/image/电力电子3.jpg" alt=""></p><h4 id="例1-书-P49-例-2-2"><a href="#例1-书-P49-例-2-2" class="headerlink" title="例1. 书 P49 例 2-2"></a>例1. 书 P49 例 2-2</h4><ul><li><p><strong>Q.</strong> 整流变压器（主变压器）为 Y/Y-12 连接组，同步变压器为 $\Delta$/Y-5 连接组，触发器采用NPN晶体管组成的正弦波同步触发电路，阻容滤波滞后30°（即 $u_{T}’$ 滞后 $u_T$ 30°），求主电路阳极电压与触发器同步电压的对应关系。</p></li><li><p><strong>分析：</strong>可以理解为某个电力电子电路有两个输入端，一个接主电路（abc），一个接同步触发电路（TaTbTc），而这两个电路都是从同一个交流电压源 $u_1$ 上接过来的。一般来讲当然是 a 对应 Ta（Ta$’$）或这样，但是为了满足上表的关系，我们不一定能这么接，比如我们需要 a 对应 Tb，这个就叫对应关系表。</p><ol><li><strong>查表</strong>。NPN晶体管组成的正弦波同步触发电路，需要同步电压滞后主电压120°，这里因为有阻容滞后电路，因此对应着表示 $u<em>{Ta}’$ 要滞后 $u_a$ 120°，$u</em>{Ta}$ 要滞后 $u_{a}$ 90°。</li><li>接着来看矢量图（不会画的话回去复习电机学第三章），主变压器 Y/Y-12 表示 $U<em>{AB}$ 与 $U</em>{ab}$ 是同相位的，设为 12 点方向。线电压要超前相电压30°（自己想象一下图），因此 $U_a$ 在 1 点钟方向。</li><li>接下来看同步变压器的矢量图，由于是从同一个交流电压源 $u<em>1$ 上接过来的，因此 $U</em>{TAB}$ 就是 $U<em>{AB}$，也在 12 点钟方向。同步变压器为 $\Delta$/Y-5 连接组，表示 $U</em>{Tab}$ 在 5 点钟方向，因此 $U_{Ta}$ 在 6 点钟方向。</li><li>上面分析了，按理说 $u<em>{Ta}$ 要滞后 $u</em>{a}$ 90°，也就是说 $U<em>{Ta}$ 应该在 4 点钟方向才行，但是现在不在。考虑一下同步信号的其他相5，按照 AZBXCY 的顺序，$U</em>{T(-b)}$ 刚好超前 $U<em>{Ta}$ 60°，也就是说 $U</em>{T(-b)}$ 刚好就在 4 点钟方向。有了阳极电压 $U_a$ 对应的同步电压相，就可以把这个表补充完整如下。</li></ol></li></ul><p><img src="/image/电力电子4.jpg" alt=""></p><h4 id="例2-书-P71-习题11"><a href="#例2-书-P71-习题11" class="headerlink" title="例2. 书 P71 习题11"></a>例2. 书 P71 习题11</h4><ul><li><strong>Q.</strong> （本题以 $\Delta$/Y-1 为例）整流变压器（主变压器）为 Y/Y-12 连接组，同步变压器为 $\Delta$/Y-1 连接组，触发器采用NPN晶体管组成的锯齿波同步触发电路，试选择 RC 滤波（滞后）环节，并求主电路阳极电压与触发器同步电压的对应关系。<ol><li><strong>查表</strong>。NPN晶体管组成的锯齿波同步触发电路，需要同步电压滞后主电压180°（反相），因此对应着表示 $u_{Ta}’$ 要滞后 $u_a$ 180°。</li><li>类似的，主变压器 Y/Y-12 表示 $U<em>{AB}$ 与 $U</em>{ab}$ 是同相位的，设为 12 点方向，因此 $U<em>a$ 在 1 点钟方向。同步变压器为 $\Delta$/Y-1 连接组，表示 $U</em>{Tab}$ 在 1 点钟方向，因此 $U_{Ta}$ 在 2 点钟方向。</li><li>按理说需要 $u_{Ta}$ 在 $u_a$ 的反相，即 7 点钟方向，但是现在在 2 点钟方向。但是这里我们可以发现，因为每相间相差60°，即 2 小时，因此同步变压器的复变对应的每一相都不可能在 7 点钟。所以，我们这个时候要引入 RC 滤波（滞后）电路。滞后 30° 就够了。</li><li>滞后 30° 得到 $U<em>{Ta}’$ 在 3 点钟方向，按照 AZBXCY 的顺序，$U</em>{Tb}’$ 刚好滞后 $U<em>{Ta}’$ 120°，即 $U</em>{Tb}’$ 刚好在 7 点钟方向，这样就得到了对应关系表，把这个表补充完整如下。</li></ol></li></ul><p><img src="/image/电力电子5.jpg" alt=""></p><h3 id="晶闸管的保护"><a href="#晶闸管的保护" class="headerlink" title="晶闸管的保护"></a>晶闸管的保护</h3><div class="table-container"><table><thead><tr><th>类型</th><th>保护方式</th><th>作用</th></tr></thead><tbody><tr><td>串联</td><td>并联均压电阻或阻容</td><td>使同时关断，减小换流反向电流</td></tr><tr><td>并联</td><td>串联均流电感（同名端反向）</td><td>感应出反向电势以减小环流</td></tr><tr><td>过压保护</td><td>1. 变压器星形中心点接地<br />2. 变压器副边阻容接地<br />3. 压敏电阻（稳压二极管）接地<br />4. 在直流侧设置相同的措施</td><td>1. 减小变压器分布电容的瞬时过电压<br />4. 防止感性负载磁场能量的突然释放</td></tr><tr><td>过流保护</td><td>1. 交流进线电抗采用大漏抗变压器<br />2. 电流检测装置，过流时发出信号<br />3. 直流快速开关（2ms）<br />4. 快速熔断器</td><td>1. 利用电抗限制短路电流<br />2. 需一定时间才能相应（0.2s）<br />4. 最后的防线，一般不希望熔断</td></tr><tr><td>电压上升率限制</td><td>1. 电源输入端串交流进线电抗 L~T~<br />2. 每个桥臂上串桥臂电感 Ls</td><td>抑制换流 $\frac{\text du}{\text dt}$</td></tr><tr><td>电流上升率限制</td><td>1. 利用整流变压器漏抗/交流进线电抗<br />2. 每个桥臂上串桥臂电感 Ls<br />3. 整流式阻容保护</td><td>3. 使电容放电电流不经过晶闸管</td></tr></tbody></table></div><h2 id="其他器件典型驱动电路"><a href="#其他器件典型驱动电路" class="headerlink" title="其他器件典型驱动电路"></a>其他器件典型驱动电路</h2><h3 id="贝克箝位电路"><a href="#贝克箝位电路" class="headerlink" title="贝克箝位电路"></a>贝克箝位电路</h3><ul><li>当 GTR 导通后，基极驱动电路应该能提供足够大的基极电流使 GTR 处于（准）饱和状态，以降低导通损耗，保证器件安全。</li><li>当 GTR 导通后，又不希望 GTR 处于深度饱和状态，否则存储时间过长不利于关断和高频响应。</li><li>贝克箝位电路是一种抗饱和电路，可以使 GTR 工作在准饱和状态，$U_{ce}$ 基本等于 1.4V。</li></ul><p><img src="/image/电力电子6.jpg" alt=""></p><h3 id="GTR缓冲电路"><a href="#GTR缓冲电路" class="headerlink" title="GTR缓冲电路"></a>GTR缓冲电路</h3><ul><li>通过错开高电压、大电流出现的时刻，使两者之积（瞬时功率）减小<ul><li>用电容 C 来吸收电压，使关断时刻<strong>电压上升减慢</strong></li><li>用电感 L 来吸收电流，使开通时刻<strong>电流上升减慢</strong></li></ul></li></ul><p><img src="/image/电力电子7.jpg" alt=""></p><h1 id="AC-DC-变换：整流"><a href="#AC-DC-变换：整流" class="headerlink" title="AC-DC 变换：整流"></a>AC-DC 变换：整流</h1><ul><li>这里不做非常细致的推导和详解，只做一些总结，可能不全</li><li>如果物理量有下标 <code>d</code> ，表示平均值，比如 $U<em>d,I_d,I</em>{dT}(晶闸管),I_{dDF}(蓄流二极管)$ 等</li><li>如果物理量没有下标 <code>d</code> ，表示有效值，比如 $U<em>2,I_2,I_T(晶闸管),I</em>{DF}(蓄流二极管)$ 等</li></ul><h2 id="单相与三相整流"><a href="#单相与三相整流" class="headerlink" title="单相与三相整流"></a>单相与三相整流</h2><h3 id="负载电压和负载电流"><a href="#负载电压和负载电流" class="headerlink" title="负载电压和负载电流"></a>负载电压和负载电流</h3><ol><li><p>当带电阻性负载时，负载电压最低下降到 0，这是临界连续点，所以电阻性负载可能出现断续。当带电感性负载时，负载电压可以继续下降到负值。而接上<strong>蓄流二极管</strong>的时候，又和电阻性负载类似的，电压不会过零！</p></li><li><p>负载电压后面的三角函数系数的决定因素是<strong>电压连续还是断续</strong>：</p><ol><li>若<strong>电压连续</strong>，则 $U<em>d=U</em>{d0}\cos\alpha$</li><li>若<strong>电压断续</strong>，则 $U<em>d=U</em>{d0}\frac{1+\cos}2$（也不一定是1，可能是其他值，一般是1）</li></ol><p>断续里面这个 $\frac{1+\cos}2$ 不一定是 $\alpha$，主要看移相角的定义，比如在单相中是 $\alpha$，三相中就是 $\alpha+\frac{\pi}6$</p></li><li><p>负载电压前面的系数可以参考 3.5 节中的公式：$U_d=\frac{\sqrt2m}{\pi}\sin\frac{\pi}mU_s\cos\alpha$，当然这里的三角系数要用上面写的那样做，不一定是 $\cos\alpha$</p><ol><li>单相桥式（$n=2$）：<strong>0.9</strong></li><li>三相半波（$n=3$）：<strong>1.17</strong></li><li>三相桥式（$n=6,U_s=\sqrt3U_2$）：<strong>2.34</strong></li><li>唯一不太一样的就是单相半波，需要额外注意一下是单相桥式的一半</li></ol></li><li><p>不论有没有电感，平均电流都是 $I_d=\frac{U_d}{R_d}$，阻性负载中电流与电压波形一致，阻感性负载中电流 $I=\text{const}$ （除单相半波整流不接蓄流二极管这一特殊情况外）</p></li><li><p>带 阻感-反电势 负载时，平均电流修正为 $I_d=\frac{U_d-E}{R_d}$</p></li></ol><h3 id="其他物理量"><a href="#其他物理量" class="headerlink" title="其他物理量"></a>其他物理量</h3><ol><li><strong>晶闸管平均电流</strong> $I<em>{dT}$ 主要看<strong>晶闸管的导通时间</strong>（由于一般都只考虑阻感性负载（甚至带蓄流二极管）下的 $I_T$，即确保 $I_d=\text{const}$），一般都有 $I</em>{dT}=\frac{\tau}{nT_s}I_d$，也就是说负载电流就是在不同时刻接入不同晶闸管上流过的电流而已。如：<ol><li>单相半波：$I_{dT}=\frac{\pi-\alpha}{2\pi}I_d$</li><li>单相桥式：$I_{dT}=\frac12I_d$（两个桥臂轮流，不管有没有电感都是这样）</li><li>三相半波/三相桥式：$I_{dT}=\frac13I_d$</li></ol></li><li><strong>晶闸管电流有效值</strong> $I_T$，由于一般都只考虑<strong>阻感性</strong>负载（甚至带蓄流二极管）下的 $I_T$，即确保 $I_d=\text{const}$，那么这个时候<strong>有效值的系数就是均值的系数开根号</strong>：$I_T=\sqrt{\frac{\tau}{nT_s}}I_d$（如果是电阻性负载就不能这么写）</li><li><strong>变压器输出电流有效值</strong> $I_2$：这个是线电压的有效值，也就是说我们一般考虑某一相（对三相整流而言），这个相对来讲比较复杂，好像也没有什么通用的公式<ol><li>单相半波：变压器输出电流就是晶闸管电流</li><li>单相桥式：$I<em>2=\sqrt{\frac1{\pi}\int</em>{\alpha}^{\pi}\frac{\sqrt2U_2}{R_d}\sin\omega t}=\frac{U_2}{R_d}\sqrt{\frac1{2\pi}\sin2\alpha+\frac{\pi-\alpha}{\pi}}$</li><li>三相半波：变压器输出电流就是晶闸管电流，即 $I_2=\sqrt{\frac13}I_d$</li><li>三相桥式：由于三相桥式输出的是线电压，因此同一时间有两相导通，故 $I_2=\sqrt{\frac1{2\pi}( \frac{2\pi}3I_d^2+\frac{2\pi}3{(-I_d)}^2}=\sqrt{\frac23}I_d$</li></ol></li></ol><h3 id="波形与总结"><a href="#波形与总结" class="headerlink" title="波形与总结"></a>波形与总结</h3><div class="table-container"><table><thead><tr><th></th><th>单相半波</th><th>单相桥式</th><th>三相半波</th><th>三相桥式</th></tr></thead><tbody><tr><td>电路</td><td><img src="\image\电力电子01.png" alt=""></td><td><img src="\image\电力电子04.png" alt=""></td><td><img src="\image\电力电子07.png" alt=""></td><td><img src="\image\电力电子10.png" alt=""></td></tr><tr><td>阻性</td><td><img src="\image\电力电子02.png" alt=""></td><td><img src="\image\电力电子05.png" alt=""></td><td><img src="\image\电力电子08.png" alt=""></td><td><img src="\image\电力电子11.png" alt=""></td></tr><tr><td>感性</td><td><img src="\image\电力电子03.png" alt=""></td><td><img src="\image\电力电子06.png" alt=""></td><td><img src="\image\电力电子09.png" alt=""></td><td><img src="\image\电力电子12.png" alt=""></td></tr><tr><td>蓄流</td><td><img src="\image\电力电子13.png" alt=""></td><td></td><td></td><td></td></tr><tr><td>反电势</td><td></td><td><img src="\image\电力电子14.png" alt=""></td><td></td></tr></tbody></table></div><h3 id="换流重叠角"><a href="#换流重叠角" class="headerlink" title="换流重叠角"></a>换流重叠角</h3><p>​        在换流时认为两管同时导通，考虑电感影响，输出电压下降为两相电压的平均值（因为在换流时一般情况下电压肯定是升高的，因此现在考虑换流重叠电压会降低）。下降的电压为：</p><script type="math/tex; mode=display">\Delta U_d=\frac{mX_B}{2\pi}I_d</script><p>​        换流重叠角的计算式：</p><script type="math/tex; mode=display">\cos\alpha-\cos(\alpha+\mu)=\frac{2I_dX_B}{\sqrt6U_2}</script><p>​        在计算时，先不考虑换流重叠的影响，计算出原先的直流输出电压 $U_{d0}$，然后考虑换流重叠电压降，计算电流：</p><script type="math/tex; mode=display">I_d=\frac{U_{d0}-\Delta U_d}R\Rightarrow I_d=\frac{U_{d0}}{R+\frac{mX_B}{2\pi}}</script><h2 id="有源逆变"><a href="#有源逆变" class="headerlink" title="有源逆变"></a>有源逆变</h2><p>​        按理说有源逆变不该在这里出现的，但是因为电路图和原理比较像，所以就一起讲掉了。有源逆变能产生的条件有二：</p><ol><li>有一个能使电能倒流的直流电势。<strong>电势的极性与晶闸管单向导电性相同</strong>，且大小稍大于直流平均电压。</li><li>变流电路直流侧能产生负值的直流平均电压（即必须是感性负载）</li></ol><p>​        考虑到第二个条件，一般晶闸管的控制角 $\alpha&gt;\pi$，因此有时也采用 $\beta=\pi-\alpha$ 来代替。需要注意的是，在逆变状态下，电路的 $U_d,E$ 均需代以<strong>负值</strong>。故有：</p><script type="math/tex; mode=display">I_d=\frac{U_d-E}R</script><h3 id="逆变颠覆"><a href="#逆变颠覆" class="headerlink" title="逆变颠覆"></a>逆变颠覆</h3><p>​        在逆变状态下发生以下事故，可能导致逆变颠覆，即直流电势的短路之类。</p><ol><li>晶闸管脉冲丢失或延时，使出现 $U_d&gt;0$ 的情况，交流电压和直流电势顺向串联</li><li>晶闸管故障，正向阻断期误导通，使出现 $U_d&gt;0$ 的情况，形成短路</li><li>交流电压缺相、电源消失等，只有反电势E，使之通过晶闸管短路</li><li>逆变角 $\beta$ 太小，晶闸管承受反压时间不够无法关断。一般要求 $\beta_{min}=30°\sim35°$</li></ol><h2 id="电路谐波及功率因数"><a href="#电路谐波及功率因数" class="headerlink" title="电路谐波及功率因数"></a>电路谐波及功率因数</h2><ul><li><p>定义：</p><ul><li>位移系数：$\cos\varphi<em>1=\frac{P</em>{基波}}{S_{基波}}=\cos\alpha(忽略换流重叠角)$</li><li>畸变系数：$\frac{I_1}I$</li><li>功率因数：$\cos\varphi=\frac PS=\frac{I_1}{I}\cos\varphi_1$</li></ul></li><li><p>单相桥式电路：</p><ul><li>基波分量电流有效值：$I_1=0.9I$</li><li>功率因数：$\cos\varphi=\frac{I_1}{I}\cos\varphi_1=0.9\cos\alpha$</li></ul></li><li>三相桥式整流：<ul><li>功率因数：$\cos\varphi=\frac{I_1}{I}\cos\varphi_1=0.955\cos\alpha$</li></ul></li></ul><p>另外，输出侧的电压平均值为：</p><script type="math/tex; mode=display">U_d=\frac{\sqrt2m}{\pi}\cdot\sin\frac{\pi}m\cdot U_S\cos\alpha</script><h2 id="大功率整流与平衡电抗器"><a href="#大功率整流与平衡电抗器" class="headerlink" title="大功率整流与平衡电抗器"></a>大功率整流与平衡电抗器</h2><div class="table-container"><table><thead><tr><th><img src="\image\电力电子15.png" alt=""></th><th><img src="\image\电力电子16.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>​        带平衡电抗器的双反星型整流电路相当于两个三相半波整流反极性连接，形成一个六脉波的六相半波整流，但是由于电感的作用，现在的输出电压是两个三相半波的均值。即相当于从相电压（$a-z-b-x-c-y$）变成（$az-zb-bx-xc-cy-ya$）。因此有以下几个优点：</p><ol><li>直流电压的脉动情况比三相半波要小</li><li>两组三相半波在任意时刻均有一相导通，因此没有直流磁化</li><li>与六相半波整流相比，变压器副边绕组利用率翻倍</li><li>每个整流元件的工作时间从 $\frac{\pi}3$ 提高到了 $\frac{2\pi}3$，提高了利用率</li></ol><h1 id="AC-AC-变换：变流"><a href="#AC-AC-变换：变流" class="headerlink" title="AC-AC 变换：变流"></a>AC-AC 变换：变流</h1><h2 id="调压电路"><a href="#调压电路" class="headerlink" title="调压电路"></a>调压电路</h2><p>​        调压电路的基本操作有三种，分别是通断、相位和斩波。这里都采用相位的控制方式。</p><p>​        调压电路比整流电路要复杂一些，因为输出端的电压电流会交变</p><div class="table-container"><table><thead><tr><th></th><th>单相+电阻</th><th>单相+阻感</th><th>三相+电阻</th></tr></thead><tbody><tr><td>电路</td><td><img src="\image\电力电子17.png" alt=""></td><td><img src="\image\电力电子18.png" alt=""></td><td><img src="\image\电力电子19.png" alt=""></td></tr><tr><td>波形</td><td><img src="\image\电力电子20.png" alt=""></td><td><img src="\image\电力电子21.png" alt=""></td><td><img src="\image\电力电子22.png" alt=""></td></tr><tr><td>功率因数</td><td>$\cos\varphi=\sqrt{\frac1{2\pi}\sin\alpha+\frac{\pi-\alpha}{\pi}}$</td><td>$\tan\varphi=\frac{\omega L}R$</td><td></td></tr><tr><td>导通角</td><td>$\theta=\pi-\alpha$</td><td>由一超越方程决定</td><td></td></tr><tr><td>输出电压</td><td>$U=U_1\cos\varphi$</td><td></td><td>1. 三个管子导通时，输出相电压<br />2. 两个管子导通时，输出线电压的一半</td></tr><tr><td>备注</td><td></td><td>1. $\alpha&gt;\varphi$ 时正常工作，$i_o$断续，$u_o$为缺块正弦波<br />2. $\alpha=\varphi$ 时变流无效，输入=输出<br />3. $\alpha&lt;\varphi$ 时失控，在脉冲信号来时晶闸管仍承受反压，变成单管整流</td><td>1. 三相中至少两相导通才能构成回路<br />2. 为保证导通，应采用大于60°的宽脉冲<br />3. 导通顺序为1-6，各差60°</td></tr></tbody></table></div><p>注：笔者也看不懂三相调压</p><h2 id="变频电路"><a href="#变频电路" class="headerlink" title="变频电路"></a>变频电路</h2><p>​        变频电路只能降频，是通过对高频输入电路的不断通断控制，形成一个平均等效的低频正弦波输出。要实现变频，必须不断改变晶闸管的触发角 $\alpha$，一般采用余弦交点控制法。</p><p><img src="/image/电力电子23.png" alt=""></p><p>​        加在负载上的电压一共有六种，其幅值相同，相位相差60°，，用 $u<em>1\sim u_6$ 表示。每次比较前后两相电压与余弦参考电压 $u_R$ 的差值，若 $u</em>{i+1}-u<em>R&lt;u_R-u_i$，那么就切换到下一个管子使其导通。即管子切换的临界条件为：$u_R=\frac{u_i+u</em>{i+1}}2$</p><p><img src="/image/电力电子24.png" alt=""></p><p>​        上图中红色的是最终的输出波形。对于上述六脉波变频电路，一般要求输出电压不能高于电网电压的$\frac13\sim\frac12$，即约 20Hz。</p><p>​        晶闸管换流时需要从电网中吸收感性无功，因此输入功率因数一定滞后。理想的输出电压是 $u<em>R=\sqrt2U_1\sin\omega_1t$，实际的输出电压为 $u_i=U</em>{do}\cos\alpha<em>i$，当两者相等时，有 $\cos\alpha_i=\frac{\sqrt2U_1}{U</em>{do}}\sin\omega_1t$，因此定义输出电压比：</p><script type="math/tex; mode=display">\gamma=\frac{\sqrt2U_1}{U_{do}}</script><p>​        $\gamma$ 越小，输出电压越低，半周期内 $\alpha$ 的平均值越接近90°，功率因数越低。</p><h1 id="DC-DC-变换：斩波"><a href="#DC-DC-变换：斩波" class="headerlink" title="DC-DC 变换：斩波"></a>DC-DC 变换：斩波</h1><p>​        DC-DC变换的机制就是靠着电容和电感的储能来实现电压的升降（电容实际上是为了稳定输出电压，核心的电压升降还是靠电感的储能），因此分析DC-DC最直接的两个原则就是：</p><ol><li>电感伏秒平衡</li><li>电容安秒平衡</li></ol><h2 id="基本DC-DC变换器"><a href="#基本DC-DC变换器" class="headerlink" title="基本DC-DC变换器"></a>基本DC-DC变换器</h2><div class="table-container"><table><thead><tr><th></th><th>Buck</th><th>Boost</th></tr></thead><tbody><tr><td>电路</td><td><img src="/image/电力电子25.png" alt=""></td><td><img src="/image/电力电子27.png" alt=""></td></tr><tr><td>波形</td><td><img src="/image/电力电子26.png" alt=""></td><td><img src="/image/电力电子28.png" alt=""></td></tr><tr><td>变比</td><td>$\frac{U_o}{U_i}=\frac{I_i}{I_o}=D$</td><td>$\frac{U_o}{U_i}=\frac{I_i}{I_o}=\frac1{1-D}$</td></tr><tr><td>断续临界值</td><td>$I<em>{LB}=\frac12i</em>{LP}=\frac12\frac{(U<em>i-U_o)t</em>{on}}{L}=\frac{ET_s}{2L}D(1-D)$</td><td>$I<em>{LB}=\frac12i</em>{LP}=\frac12\frac{U<em>it</em>{on}}{L}=\frac{U<em>oT_s}{2L}D(1-D)$<br />$I</em>{oB}=(1-D)I_{LB}=\frac{U_oT_s}{2L}D(1-D)^2$</td></tr><tr><td>断续变比</td><td>$(U_i-U_o)DT_s-U_o\delta T_s=0$<br />$\frac{U_o}{U_i}=\frac D{D+\delta}$</td><td>$U_iDT_s+(U_i-U_o)(1-D)T_s=0$<br />$\frac{U_o}{U_i}=\frac{D+\delta}{\delta}$</td></tr><tr><td>电流纹波</td><td>$\Delta I_L=\frac{U_o}{L}(1-D)T_s$</td><td>$\Delta I_L=\frac{U_iDT_s}{2L}$</td></tr><tr><td>电压纹波</td><td>$\Delta U_o=\frac{\Delta Q}{C}=\frac{\frac{I_L}2\cdot\frac{T_s}2}{2C}=\frac{U_o(1-D)T_s^2}{8LC}$</td><td>$\Delta U_o=\frac{I_oDT_s}L$</td></tr></tbody></table></div><ul><li>解释一下<strong>电压纹波</strong>的计算方法，计算电压纹波时认为<strong>输出电流平直，没有纹波</strong>，因此输出电压纹波 $\Delta U_o$ 实际上就是<strong>电容上的电压纹波 $\Delta U_c$</strong><ul><li>对于Buck电路，电容与电感始终是连接在一起的，所以电容的电压纹波<strong>直接由电感电流纹波产生</strong>，与输出电流无关（说的是输出电流平直，<strong>不是电感电流平直</strong>）</li><li>对于Boost电路，电感与电容在 $t_{on}$ 时断开，因此电容的电压纹波是由<strong>电容恒流放电产生</strong>，与电感纹波无关</li><li>两者计算方法不同，切勿搞混</li></ul></li></ul><h2 id="其他DC-DC变换器"><a href="#其他DC-DC变换器" class="headerlink" title="其他DC-DC变换器"></a>其他DC-DC变换器</h2><h3 id="Buck-Boost与Cuk"><a href="#Buck-Boost与Cuk" class="headerlink" title="Buck-Boost与Cuk"></a>Buck-Boost与Cuk</h3><div class="table-container"><table><thead><tr><th></th><th>Buck-Boost</th><th>Cuk</th></tr></thead><tbody><tr><td>说明</td><td>1. 输入输出电压反极性<br />2. 输入输出位置不变，但是可升压可降压</td><td>1. 输入输出电压反极性<br />2. 输入输出位置不变，但是可升压可降压</td></tr><tr><td>电路</td><td><img src="/image/电力电子29.png" alt=""></td><td><img src="/image/电力电子30.png" alt=""></td></tr><tr><td>变比</td><td>$\frac{U_o}{U_i}=\frac{I_i}{I_o}=\frac D{1-D}$</td><td>$\frac{U<em>o}{U_i}=\frac{I_i}{I_o}=\frac D{1-D}$<br />$\frac{U</em>{c1}}{U<em>i}=\frac1{1-D}~,~\frac{U</em>{c1}}{U_o}=\frac1D$</td></tr><tr><td>电流纹波</td><td>$\Delta I_L=\frac{EDT_s}L$</td><td>$\Delta I<em>{L1}=\frac{EDT_s}{L_1}~,~\Delta I</em>{L2}=\frac{EDT_s}{L_2}$</td></tr><tr><td>电压纹波</td><td>$\Delta U_o=\frac{I_oDT_s}C$</td><td>$\Delta U<em>{c1}=\frac{I(1-D)T_s}{C_1}~,~\Delta U</em>{c2}=\frac{DET_s^2}{8L_2C_2}$</td></tr></tbody></table></div><h3 id="晶闸管斩波"><a href="#晶闸管斩波" class="headerlink" title="晶闸管斩波"></a>晶闸管斩波</h3><div class="table-container"><table><thead><tr><th><img src="/image/电力电子31.png" alt=""></th><th><img src="/image/电力电子32.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><ol><li>VT1导通，电源电压E直接加到负载</li><li>VT2导通，C、L1、VT2 谐振使电容C电压反向充电到 -E，电源电压E直接加到负载</li><li>VT1受反压关断，谐振回路电流为0（LC谐振电压最大时电流为0），谐振结束，VT2也关断</li><li>C、L1、VD1、L2、VD2 构成谐振回路，电容重新充电到 E，负载电压=电源电压E - 电容电压</li><li>VDF蓄流，等待步骤1的响应</li></ol><h4 id="斩波变阻"><a href="#斩波变阻" class="headerlink" title="斩波变阻"></a>斩波变阻</h4><p><img src="/image/电力电子33.png" alt=""></p><script type="math/tex; mode=display">R^*=R_d+(1-D)R_{ex}</script><h3 id="双向DC-DC"><a href="#双向DC-DC" class="headerlink" title="双向DC-DC"></a>双向DC-DC</h3><p>​        双向DC-DC与Boost-Buck电路的区别在于：</p><ol><li>双向DC-DC是恒定一边电压高，一边电压低，但是输入和输出可以不断交换（比如电池-电网回路就是双向DC-DC，电网电压要高于蓄电池，但是电能流向会根据需求改变）</li><li>Buck-Boost电路是输入和输出端固定不变，但是输入到输出可以降压也可以升压</li></ol><p><img src="/image/电力电子34.png" alt=""></p><p>​        其中 V1、VD2 构成Buck降压电路，V2、VD1 构成Boost升压电路。电路图中<strong>电机电压比电网电压要小</strong>。</p><ul><li>桥式可逆斩波比较简单，不想写了，自己看《电机控制》的书。</li></ul><h1 id="DC-AC-变换：逆变"><a href="#DC-AC-变换：逆变" class="headerlink" title="DC-AC 变换：逆变"></a>DC-AC 变换：逆变</h1><p>鉴于很多负载（电机）经常需要不同频率的电流，因此变频是电力电子变换当中一个比较重要的课题。一般的变频分为两种：交-交变频和交-直-交变频，前者在AC-AC中已经讲过，后者的后半部分就是DC-AC的重要应用之一。</p><p>此外直流电源向交流负载供电就需要逆变结构，比如带储能的电网，从储能到电网的电能流动就需要逆变。</p><h2 id="逆变电路的分类"><a href="#逆变电路的分类" class="headerlink" title="逆变电路的分类"></a>逆变电路的分类</h2><div class="table-container"><table><thead><tr><th>类别</th><th>电压源型</th><th>电流源型</th></tr></thead><tbody><tr><td>图片</td><td><img src="/image/电力电子35.png" alt=""></td><td><img src="/image/电力电子36.png" alt=""></td></tr><tr><td>电压波形</td><td>矩形波（方波）</td><td>正弦波</td></tr><tr><td>电流波形</td><td>正弦波</td><td>矩形波（方波）</td></tr><tr><td>储能元件</td><td>大电容</td><td>大电感</td></tr><tr><td>导通方式</td><td>180° （互补）</td><td>120°</td></tr><tr><td>结构与保护</td><td>过电流保护困难，复杂</td><td>抗电流冲击力强，容易保护</td></tr><tr><td>适用</td><td>稳频稳压电源、不可逆电力拖动系统，多电机传动</td><td>可逆运行，电力拖动系统制动，频繁加减速正反转</td></tr><tr><td>四象限运行</td><td>电压极性固定，换向不方便</td><td>电流极性固定，换向容易，仅需改变触发角</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>电网换流</th><th>负载谐振式换流</th><th>强迫换流</th></tr></thead><tbody><tr><td>电网电压自动过零变负，晶闸管关断，自然换流</td><td>利用回路谐振使电流过零，要求电流超前电压（容性）</td><td>附加换流环节，利用储能元件释放脉冲电流关断晶闸管</td></tr></tbody></table></div><h2 id="并联负载谐振式"><a href="#并联负载谐振式" class="headerlink" title="并联负载谐振式"></a>并联负载谐振式</h2><p><img src="/image/电力电子37.png" alt=""></p><p><img src="/image/电力电子38.png" alt=""></p><ul><li><p><strong>基本工作原理：</strong>原先 VT14 导通，电路如图(a)所示运行。在 $t<em>2$ 时刻触发导通 VT23；对比 VT1 和 VT3，可以认为 $u</em>{T3}&gt;u<em>{T1}$，因此 VT3 会导通钳位，将 VT1 截止，其电压 $u</em>{T1}=-E$。对VT2和VT4同理。于是 VT14 电流迅速下降，VT23 电流迅速上升，四个晶闸管重叠导通，构成换流时间 $t_{\mu}$</p></li><li><p><strong>换流相关分析：</strong>换流时间为 $t<em>{\mu}$，晶闸管关断时间为 $t</em>{q}$。为保证晶闸管可靠关断，晶闸管必须在换流结束之后承受 $t<em>{\beta}&gt;t_q$ 时间的反压。负载电流为 VT14 和 VT23 电流的叠加，因此电流在换流开始后的 $\frac{t</em>{\mu}}2$ 关闭，电压需要在 $t<em>{\mu}+t</em>{\beta}$ 之后关断，因此功率因数角所对应的<strong>电流超前电压的时间为</strong>：</p><script type="math/tex; mode=display">t_{\varphi}=\frac{t_{\mu}}2+t_{\beta}~;~\varphi=\omega\,t_{\varphi}</script></li><li><p><strong>电路与负载特性：</strong>此图为电流源型逆变器，因此电流近似方波，电压近似正弦波。若认为 $\omega L\gg R$，则有 $Z=\frac LC\frac{1}{R+j(\omega L-1/\omega C)}$，要求电路呈现容性，必须有 $\omega&gt;\omega_0=\frac1{\sqrt{LC}}$。再考虑可靠换流，则有：</p><script type="math/tex; mode=display">t_{\varphi}=\frac{\varphi}{\omega}=\frac1{\omega}\left( \frac{\frac1{\omega C}-\omega L} R\right)>t_q</script></li><li><p><strong>电路参数：</strong></p><ul><li>基波电流有效值：$I_{o1}=\frac{2\sqrt2}{\pi}I_d$</li><li>输出电压有效值：$U_o=\frac{\pi}{2\sqrt2}\frac E{\cos\varphi \cos\mu}\approx1.11\frac E{\cos\varphi}$</li></ul></li></ul><h2 id="强迫换流"><a href="#强迫换流" class="headerlink" title="强迫换流"></a>强迫换流</h2><p><img src="/image/电力电子39.png" alt=""></p><ul><li><strong>基本工作原理：</strong>设 VT56 导通，电容 $C_5$ 被充电至左-右+。触发导通 VT1 后，电容 $C_5$ 的电压使 VT1 导通钳位，VT5 承受反压关断。输入端恒流给等效电容 $\frac32C$ 充电，直到 VD1 导通（与 VD5 同时导通），此时谐振回路（$2L\times\frac32C$）形成，A相电流上升，C相电流下降。</li><li><strong>电路特性：</strong><ul><li>每个晶闸管导通120°（三分之一周期），同一时间只有2个晶闸管导通</li><li>换向发生在上或下桥臂的元件组之间，即 VT1/3/5 之间和 VT2/4/6 之间</li><li>换向使引起大自感电势 $e_L=L\frac{\text di}{\text dt}$，因此电感 L 不要太大</li><li>最终每相都输出六阶梯波</li></ul></li></ul><h2 id="电压源型逆变"><a href="#电压源型逆变" class="headerlink" title="电压源型逆变"></a>电压源型逆变</h2><h3 id="单相桥式逆变"><a href="#单相桥式逆变" class="headerlink" title="单相桥式逆变"></a>单相桥式逆变</h3><p><img src="/image/电力电子35.png" alt=""></p><p>有两种工作方式：</p><ol><li>14相同，23相同，两组之间互补，$U_o=\frac{2\sqrt2}{\pi}U_d$ 不可调压</li><li>12互补，34互补，但是3滞后1 $\theta\in(0,\pi)$，可调压。$\theta$ 越大电压越大</li></ol><h3 id="三相桥式逆变"><a href="#三相桥式逆变" class="headerlink" title="三相桥式逆变"></a>三相桥式逆变</h3><div class="table-container"><table><thead><tr><th>电路图</th><th>输出波形</th></tr></thead><tbody><tr><td><img src="/image/电力电子44.png" alt=""></td><td><img src="/image/电力电子45.png" alt=""></td></tr></tbody></table></div><p><a href="#多电平化">Return 多电平化</a></p><blockquote><p>至于为什么是 $\frac13E和\frac23E$，因为原本负载各相对电源中点 $O’$ 的电压幅值是 $\frac E2$，</p><p>而负载中性点对电源中性点的电压 $u<em>{OO’}=\frac13\sum u</em>{PO’}$（P为各相），所以是一个 3 倍频，幅值为 $\frac E6$的电压</p><p>两者合起来就是 $\frac E2-\frac E6=\frac13E~,~\frac E2+\frac E6=\frac23E$</p></blockquote><ul><li>电路参数<ul><li>线电压基波幅值：$u<em>{AB1m}=1.1 E$，基波有效值：$u</em>{AB1}=0.78E$</li><li>相电压基波幅值：$u<em>{AO1m}=0.637 E$，基波有效值：$u</em>{AO1}=0.45E$</li></ul></li></ul><h2 id="多重化及多电平化"><a href="#多重化及多电平化" class="headerlink" title="多重化及多电平化"></a>多重化及多电平化</h2><ul><li>电路的多重化和多电平化的目的都是改善逆变器的波形，使之更接近正弦波，但是两者的实现方式不同。<ul><li>多重化通过变压器实现，来将多组逆变器输出错开一定的相位后再相连</li><li>多电平化通过几个电平台阶合成阶梯波以逼近正弦波</li></ul></li></ul><h3 id="多重化"><a href="#多重化" class="headerlink" title="多重化"></a>多重化</h3><p>多重化分为串联和并联两种：串联多重化是将几个逆变器的输出串联起来，多用于电压源型；并联多重化是将及格逆变器的输出并联起来，多用于电流源型逆变器。</p><div class="table-container"><table><thead><tr><th>电路图</th><th>输出波形</th></tr></thead><tbody><tr><td><img src="/image/电力电子40.png" alt=""></td><td><img src="/image/电力电子41.png" alt=""></td></tr></tbody></table></div><ol><li>易看出该电路由两个三相电压源型逆变器组成，每个逆变器输出的都是六阶梯波，各相之间相差60°，两组之间完全相同</li><li>但是两组的变压器不同，第一组是 $\Delta/Y-12$ 连接，第二组是 $\Delta/Z-1$ 连接，即第二组的输出要滞后输入30°，但是第二组是线电压第一组是相电压，线电压又要超前相电压30°，所以两组的相位就相同了。</li></ol><blockquote><p>注：我不能理解书上的话，我觉得图 5-21 怎么数怎么是一个十阶梯波。而且我也不是很理解变压器为什么会，或者说为什么要输出同相位，我觉得就是要相位相差30°这个电路才能正常工作（原本各阶梯之间差60°，现在两个相差30°的叠在一起，不就阶梯数翻倍了吗？）书上166页倒数第二段也说了依次错开 $\frac{\pi}{3m}$ 的相位。</p><p>所以我觉得书上画的那种不是通用的正常的形式，而是另一个可行的形式。不然按理说两个逆变器就应该都输出六阶梯波。</p></blockquote><h3 id="多电平化"><a href="#多电平化" class="headerlink" title="多电平化"></a>多电平化</h3><div class="table-container"><table><thead><tr><th>电路图</th><th>输出波形</th></tr></thead><tbody><tr><td><img src="/image/电力电子42.png" alt=""></td><td><img src="/image/电力电子43.png" alt=""></td></tr></tbody></table></div><ol><li>以A相为例，原本的电路是 VT1 和 VT4 互补，并且在一周期内均工作120°，中间有120°时间的空（60°×2）</li><li>引入新的晶闸管，VT1’与 VT4 互补，VT4’与 VT1 互补，也就是说这两个管子在一周期内要工作240°，中间有120°的重合（60°×2）</li><li>这样<a href="#三相桥式逆变">原本的六阶梯波</a>就由 ($\frac E2,0,-\frac E2$) 构成，两相之间相差120°，变成有 $E,\frac E2,0,-\frac E2,-E$ 的阶梯波</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电力系统稳态分析笔记</title>
      <link href="/2026/02/24/%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E7%A8%B3%E6%80%81%E5%88%86%E6%9E%90/"/>
      <url>/2026/02/24/%E7%94%B5%E5%8A%9B%E7%B3%BB%E7%BB%9F%E7%A8%B3%E6%80%81%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><ul><li>下文中公式出现$$等形式就是没渲染好，最好开翻墙…因为确实有点卡</li><li><strong>整理了PDF版本，内容跟下面差别不大，好处是可以打印而且不会出现渲染问题</strong><ul><li><a href="\myfile\稳态期末复习.pdf" target="_blank">电力系统稳态期末复习</a></li></ul></li><li>推荐一个98的老前辈的帖子，整理的很全也有一份样卷：<ul><li>【学习天地】电力系统稳态分析知识点整理 样卷 <a href="https://www.cc98.org/topic/4901089">https://www.cc98.org/topic/4901089</a> 复制本链接，打开【CC98】微信小程序，直接查看本帖！</li></ul></li><li>第一章自己看书</li></ul><h2 id="电力系统元件数学模型"><a href="#电力系统元件数学模型" class="headerlink" title="电力系统元件数学模型"></a>电力系统元件数学模型</h2><h3 id="三相电力线路"><a href="#三相电力线路" class="headerlink" title="三相电力线路"></a>三相电力线路</h3><h4 id="电路参数"><a href="#电路参数" class="headerlink" title="电路参数"></a>电路参数</h4><p>在集总参数模型中，我们可以用四个量来表示电路，即L,R,C,G。</p><ul><li><strong>分裂导线：</strong><ul><li>每相导线的分裂导线的根数：n</li><li>三相导线几何间距：$D<em>m =\sqrt[3]{D</em>{12}D<em>{23}D</em>{13}}$；分裂导线内部导线等值半径：$r<em>{eq} =\sqrt[n]{rd</em>{12}d<em>{13}\cdots d</em>{1n}}$</li></ul></li><li><p><strong>电感：</strong></p><ul><li>架空线路正序电感：$x_1=2\pi fL_1=0.06283\text{ln}\frac{D_m}r+0.0157\,(\Omega/km)$</li><li>分裂导线正序电感：$x<em>1 =2\pi fL_1=0.06283\text{ln}\frac{D_m}{r</em>{eq}}+\frac{0.0157}n\,(\Omega/km)$</li></ul></li><li><p><strong>电纳：</strong></p><ul><li>架空线路正序电纳：$b_1=2\pi fC_1=\frac{17.45}{\text{ln}\frac{D_m}r}\times10^{-6}(s/km)$</li><li>分裂导线正序电纳：$b<em>1=2\pi fC_1=\frac{17.45}{\text{ln}\frac{D_m}{ r  </em>{eq}} }\times10^{-6}(s/km)$</li></ul></li><li><p>电晕临界电压：$U_{cr}\propto r\text{lg}\frac{D_m}r$</p></li></ul><h4 id="等值电路"><a href="#等值电路" class="headerlink" title="等值电路"></a>等值电路</h4><p><strong>基本知识：</strong></p><ul><li><p>单位长度等值阻抗：$Z_1=r_1+jx_1$</p></li><li><p>单位长度等值导纳：$Y_1=g_1+jb_1$</p></li><li><p>波阻抗（特性阻抗）：$Z_c=\sqrt{Z_1/Y_1}\,(\Omega)$；传播系数：$\gamma=\sqrt{Z_1Y_1}=\alpha+j\beta$</p></li><li><p>当电路达成<strong>匹配</strong>（$Z_c=Z_2$）和<strong>无损耗</strong>（$g_1=r_1=0$）时，有：</p><script type="math/tex; mode=display">\begin{gather}\begin{bmatrix}U \\ I \end{bmatrix}=e^{j\alpha x}\begin{bmatrix}U_2 \\ I_2 \end{bmatrix}\end{gather}</script></li><li><p><img src="\image\稳态01.png" alt=""></p></li></ul><p><strong>结论：</strong></p><script type="math/tex; mode=display">\begin{gather}\begin{cases}（中）100-300km的架空线或100km以内的电缆线：&\begin{cases}Z=Z_1l\\Y=Y_1l\end{cases}\\（长）超300km的架空线或超100km的电缆线：&\begin{cases}Z=K_ZZ_1l\\Y=K_YY_1l\end{cases}&\begin{cases}K_Z=1+\frac{Z_1Y_1}6l^2\\K_Y=1-\frac{Z_1Y_1}{12}l^2\end{cases}\\（短）小于100km且电压低于35kV的架空线：&将\pi型等效电路的两个导纳删了\end{cases}\end{gather}</script><h3 id="变压器"><a href="#变压器" class="headerlink" title="变压器"></a>变压器</h3><h4 id="双绕组变压器"><a href="#双绕组变压器" class="headerlink" title="双绕组变压器"></a>双绕组变压器</h4><p>根据变压器内部的量值大小关系，简化双绕组变压器的电路图如下图所示：</p><p><img src="\image\稳态02.png" alt=""></p><p>也就是说，我们需要求出R,X,G~m~,B~m~四个量。下面给出变压器的基本参数和求解方法。</p><p><strong>变压器参数：</strong>哪些东西是我们事先知道的</p><ul><li>变压器四个额定值：输入$U<em> {1N},I</em>{1N}$，输出$U<em>{2N},I</em> {2N}$</li><li>变压器额定容量：$S<em>N=\sqrt3U</em> {1N}I<em>{1N}=\sqrt3U</em> {2N}I_ {2N}$</li><li>原理：输出有功功率跟电感、电容大小无关，因此通过这个可以知道电阻、电导的大小；已知电阻、电导远小于电抗、电纳，因此电压降基本只和电抗、电纳有关，通过求电压降得到电感、电容大小。</li></ul><p><strong>短路实验求R,X：</strong></p><ul><li>输出端短路$U<em>2=0$，使左边达到额定电流$I</em>{1N}$，记下此时的电压$U_{k}$和输出功率$P_k$</li><li>$R=\frac{P<em> k}{3I</em>{1N}^2}=\frac{P<em>k}{1000}\frac{U</em>{1N}^2}{S _ {N}^2}\,(\Omega)$</li><li>$X=\frac{U <em>k}{\sqrt3I</em> {1N}}=U<em>k\frac{U</em> {1N}}{S<em> N}=(\frac{U _k}{U</em>{1N}})\frac{U<em> {1N}^2}{S _N}=\frac{U_k\%}{100}\frac{U</em> {1N}^2}{S _N}(\Omega)$</li></ul><p><strong>开路实验求G,B：</strong></p><ul><li>输出端断路$I<em>2=0$，使左边达到额定电压$U</em>{1N}$，记下此时的电流$I_0$和输出功率$P_0$</li><li>$G <em>m=\frac{P</em> 0}{U _{1N}^2}\times 10^{-3}(s)$</li><li>$B<em> m=\frac{\sqrt3I_0}{U </em>{1N}}=(\frac{I <em>0}{I</em> {1N}})\frac{S <em>N}{U</em> {1N}^2}=\frac{I<em>k\%}{100}\frac{S _N}{U</em> {1N}^2}(s)$（<strong>一定要取负号！这个B~m~只是大小，感纳为负</strong>）</li></ul><h4 id="三绕组变压器"><a href="#三绕组变压器" class="headerlink" title="三绕组变压器"></a>三绕组变压器</h4><p>三绕组变压器的公式与双绕组完全一样，但是多了两步。</p><p><img src="\image\稳态03.png" alt=""></p><p><strong>P和U的必要归算：</strong></p><ul><li>因为三绕组每次短路只能选两个端口，因此有三个电压和损耗功率，并且是由两条支路的数据平分。</li><li><img src="\image\稳态04.png" alt=""></li><li>电压（$U_k%$）写法一模一样。</li></ul><p><strong>因为额定容量不同导致的归算：</strong></p><ul><li>以100/50/100为例，仅有1-3侧能达到额定容量，剩下两个都只有一般的额定电压。因此<strong>要将$U$乘上2，$P$乘上4</strong>。</li></ul><p><strong>G和B：</strong></p><ul><li>不需要上面这么麻烦的算，直接整就好。见课本例题。</li></ul><p><strong>最大短路损耗：</strong></p><ul><li>有些厂家只提供了P~kmax~，那么就把这个当成<strong>容量最大的两个支路一起提供的损耗</strong>。然后<strong>电阻按照容量大小反向分配</strong>，即100/100/50就是两个100的电阻等大平分，50那组的电阻值大小就是100的两倍。比如：$R<em>1=R_2=\frac12\frac{P</em>{kmax}}{1000}\frac{U_{1N}^2}{S_N^2}\,;\,R_3=2R_1$</li></ul><h4 id="自耦变压器"><a href="#自耦变压器" class="headerlink" title="自耦变压器"></a>自耦变压器</h4><p><img src="\image\稳态05.png" alt=""></p><ul><li>变比：$k<em> {12}=\frac{U </em>{1N}}{U_ {2N}}=1+\frac{\omega _s}{\omega _c}$</li><li>效益系数：$k<em> b=\frac{I</em> {com}}{I<em>2}=1-\frac1{k </em>{12}}$</li><li>通过磁耦合传递的最大功率（标准容量、设计容量）：$S_{st}=K_bS_N$</li><li>其用铜量、短路损耗都是普通变压器的$K_b$倍，其等值电路与普通变压器相同。</li><li>三相自耦变压器，公共绕组不过载的条件：$S<em> {com}=\sqrt{(K _bP_1+P _3)^2+(K _bQ_1+Q _3)^2}&lt;K</em> b S _N$</li><li>三侧不过载条件：$S_i&lt;\eta S_N$（$\eta=\frac{容量}{最大容量}$）</li></ul><h3 id="同步发电机和调相机"><a href="#同步发电机和调相机" class="headerlink" title="同步发电机和调相机"></a>同步发电机和调相机</h3><h4 id="同步发电机"><a href="#同步发电机" class="headerlink" title="同步发电机"></a>同步发电机</h4><p><img src="\image\稳态06.png" alt=""></p><p><strong>参数：</strong></p><div class="table-container"><table><thead><tr><th>定子空载相电势</th><th>每相绕组电阻</th><th>定子纵轴、横轴同步电抗</th><th>功率角（$U$和$E_q$的夹角）</th></tr></thead><tbody><tr><td>$E_q$或$jE_q$</td><td>$r$</td><td>$x_d,x_q$</td><td>$\delta$（注意和功率因数角区分！）</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th>参数</th><th>隐极发电机$(x_d=x_q)$</th><th>凸极发电机</th></tr></thead><tbody><tr><td>电压</td><td>$U=jE_q-(r+jx_q)I$</td><td>$U=jE_q-j(x_d-x_q)I_d-(r+jx_q)I$</td></tr><tr><td>有功</td><td>$P=\frac{E_qU}{x_d}\text{sin}\delta$</td><td>爬</td></tr><tr><td>无功</td><td>爬</td><td>爬</td></tr></tbody></table></div><ul><li>其中，r，x~d~，x~q~可能会提供标么值、两种形式的百分值等。其转换如下（都一样的，以r为例）：<ul><li>$r=r_*\frac{U_N^2}{S_N}=\frac{r%}{100}\frac{U_N^2}{S_N}$</li></ul></li></ul><h4 id="无功补偿设备"><a href="#无功补偿设备" class="headerlink" title="无功补偿设备"></a>无功补偿设备</h4><div class="table-container"><table><thead><tr><th></th><th>调相机</th><th>并联电容</th><th>并联电抗</th><th>静止补偿器</th></tr></thead><tbody><tr><td>电压方程</td><td>$U=E_q-jx_dI$</td><td></td><td></td><td></td></tr><tr><td>无功功率</td><td>$Q=UI=\frac{U(E_q-U)}{x_d}$</td><td>$Q=U^2B_C$</td><td>$Q=</td><td>U^2B_L</td><td>$</td><td>$Q=Q_C+Q_L=U^2(\frac1{x_C}-\frac1{x_L})$</td></tr></tbody></table></div><h4 id="多级电力系统"><a href="#多级电力系统" class="headerlink" title="多级电力系统"></a>多级电力系统</h4><p>方法：设定基本级——用实际变比归算到基本级——解归算后的网络——解耦至原级</p><script type="math/tex; mode=display">U'=kU;I'=\frac{I}k;Z'=k^2Z;Y'=\frac Y{k^2}</script><h4 id="标幺值"><a href="#标幺值" class="headerlink" title="标幺值"></a>标幺值</h4><div class="table-container"><table><thead><tr><th>三相功率</th><th>线电压</th><th>阻抗</th><th>导纳</th><th>电流</th></tr></thead><tbody><tr><td><strong>基准值$S_B$</strong></td><td><strong>基准值$U_B$</strong></td><td>$Z_B=\frac{U_B^2}{S_B}$</td><td>$Y_B=\frac{S_B}{U_B^2}$</td><td>$I_B=\frac{\sqrt3S_B}{U_B}$</td></tr></tbody></table></div><ul><li>方法：将<strong>基本级</strong>的<strong>基准值</strong>归算到各级（实际上只用归算U），然后用这个U和S~B~来计算各级的阻抗、导纳。</li></ul><h4 id="非标准变比"><a href="#非标准变比" class="headerlink" title="非标准变比"></a>非标准变比</h4><p><img src="\image\稳态07.png" alt=""></p><ul><li><p>用变压器标准变比来归算（从基本级到各级），代价是把变压器的$\tau$型等值电路变成了$\pi$型，要复杂一点</p></li><li><p>书里的图片不好，不应该用k，容易引起误导，应该用$k^<em>$（从1到2是$1:k^</em>$，注意顺序）</p><ul><li><script type="math/tex; mode=display">\frac{k^*}1\cdot\frac{U_{2B}}{U_{1B}}(标准变比)=\frac{U_{2T}}{U_{1T}}(实际变比)\Rightarrow k^*=\frac{U_{2T}/U_{1T}}{U_{2B}/U_{1B}}</script></li></ul></li></ul><h2 id="电力系统潮流计算"><a href="#电力系统潮流计算" class="headerlink" title="电力系统潮流计算"></a>电力系统潮流计算</h2><h3 id="手算公式"><a href="#手算公式" class="headerlink" title="手算公式"></a>手算公式</h3><h4 id="电力线路"><a href="#电力线路" class="headerlink" title="电力线路"></a>电力线路</h4><p><img src="\image\稳态08.png" alt=""></p><div class="table-container"><table><thead><tr><th>$\Delta U$</th><th>$\delta U$</th><th>$\frac B2$损耗S(等于Q)</th><th>$Z$上损耗S(P+jQ)</th></tr></thead><tbody><tr><td>$\frac{PR+QX}{U_j}$</td><td>$\frac{PX-QR}{U_j}$</td><td>$-jU_i^2\frac B2$和$-jU_j^2\frac B2$</td><td>$\frac{P_j^2+Q_j^2}{U_j^2}(R+jX)$</td></tr></tbody></table></div><ul><li>一些简化：一般而言X远大于R，$\Delta U$对电压的影响远大于$\delta U$</li></ul><div class="table-container"><table><thead><tr><th>电压降落</th><th>电压损耗</th><th>电压偏移</th><th>电压调整</th><th>输电效率</th></tr></thead><tbody><tr><td>$\Delta U+j\delta U$</td><td>$\frac{U_1-U_2}{U_N}\times100\%$</td><td>$\frac{U_{1/2}-U_N}{U_N}\times100\%$</td><td>$\frac{U<em>{20}-U_2}{U</em>{20}}\times100\%$</td><td>$\frac{P_2}{P_1}\times100\%$</td></tr></tbody></table></div><h4 id="变压器-1"><a href="#变压器-1" class="headerlink" title="变压器"></a>变压器</h4><ul><li>$\Delta P=\frac{P^2+Q^2}{U_j^2}R_T+U_i^2G_T$</li><li>$\Delta Q=\frac{P^2+Q^2}{U_j^2}X_T+U_i^2B_T$</li></ul><h4 id="手算潮流"><a href="#手算潮流" class="headerlink" title="手算潮流"></a>手算潮流</h4><ul><li><p>辐射型网络：功率推算过去，电压推算回来</p></li><li><p>两端供电网：</p></li></ul><p><img src="\image\稳态09.png" alt=""></p><ul><li>环形供电网：<ul><li>单电压级：任一点解环，用两端供电网求解，dU=0</li><li>多电压级：阻抗端解环，$\text dU=U_A(\frac1{k_1}-\frac1{k_2})$</li></ul></li></ul><h3 id="电算潮流"><a href="#电算潮流" class="headerlink" title="电算潮流"></a>电算潮流</h3><h4 id="数理基础推导"><a href="#数理基础推导" class="headerlink" title="数理基础推导"></a>数理基础推导</h4><ul><li><strong>节点电压方程（原方程）</strong>：$\dot I<em>i=\sum_j y</em>{ij}(\dot U_i-\dot U_j)$</li><li><p>节点导纳矩阵：$Y=[y<em>{ij}]$，其中$Y</em>{ij}=-y<em>{ij}\,;\,Y</em>{ii}=\sum<em>{j=0} y</em>{ij}$</p><ul><li>得：$\dot I<em>i=\sum</em>{j=1}Y_{ij}\dot U_j$，$\dot I=Y\dot U$</li></ul></li><li><p>对地支路导纳只影响$y_{ii}$，变压器节点要注意使用非标准变比的变压器$\pi$型等值电路等效，注意$1:k^*$的方向</p></li><li><p><strong>功率方程：</strong>$\widetilde S<em>i=P_i+jQ_i=\dot U_i I^*=\dot U_i\sum</em>{j=1}Y_{ij}^<em>U_j^</em>$</p></li></ul><h4 id="G-S计算法"><a href="#G-S计算法" class="headerlink" title="G-S计算法"></a>G-S计算法</h4><ul><li><strong>公式推导：</strong></li></ul><script type="math/tex; mode=display">\begin{gather*}P_i+jQ_i=\dot U_i\sum_{j=1}Y_{ij}^*U_j^*=\dot U_i(Y_{ii}^*U_i^*+\sum_{j\neq i}Y_{ij}^*U_j^*)\\\Rightarrow \begin{cases}PQ:&\dot U_i=\frac1{Y_{ii}}(\frac{P-jQ}{U_i^*}-\sum_{j\neq i}Y_{ij}\dot U_j)\\PV:&Q_p=\text{Im}(\dot U_p\sum_k Y_{pj}^*U_j^*)\end{cases}\end{gather*}</script><p>[注]：PV节点也需要列写上面的电压修正方程，但是最后只修正相角不修正电压幅值。</p><h4 id="N-R计算法"><a href="#N-R计算法" class="headerlink" title="N-R计算法"></a>N-R计算法</h4><ul><li><p>N-R方程：$y=f’(x_0)(x-x_0)+f(x_0)=0\Rightarrow x =x_0-\frac{f(x_0)}{f’(x_0)}$</p></li><li><p><strong>理论依据：</strong>$P<em>i+jQ_i=\dot U_i\sum</em>{j=1}Y_{ij}^<em>U_j^</em>$</p></li></ul><script type="math/tex; mode=display">\begin{gather*} \Rightarrow\begin{cases}P_i=U_i\sum_jU_j(G_{ij}cos_{ij}+B_{ij}sin_{ij})\\Q_i=U_i\sum_jU_j(G_{ij}sin_{ij}-B_{ij}cos_{ij})\\\end{cases}\\\Rightarrow\begin{cases}\Delta P_i=\sum_j(\frac{\partial\Delta P}{\partial \theta_j}\Delta\theta_j+\frac{\partial\Delta P}{\partial U_j}\Delta U_j)=\sum_j(H_{ij}\Delta\theta_j+N_{ij} \Delta U_j/U_j)\\\Delta Q_i=\sum_j(\frac{\partial\Delta Q}{\partial \theta_j}\Delta\theta_j+\frac{\partial\Delta Q}{\partial U_j}\Delta U_j)=\sum_j(J_{ij}\Delta\theta_j+L_{ij} \Delta U_j /U_j)\\\end{cases}\\\begin{bmatrix}\Delta P\\\Delta Q  \end{bmatrix}=\begin{bmatrix}H&N\\J&L \end{bmatrix}=\begin{bmatrix}\Delta\theta\\U^{-1}\Delta U \end{bmatrix}\end{gather*}</script><p><img src="\image\稳态10.png" alt=""></p><ul><li>直角坐标形式：</li></ul><p><img src="\image\稳态11.png" alt=""></p><p>要把PV节点的方程换成：$f<em>{Ui}=U</em>{is}-e^2-f^2$</p><h4 id="P-Q分解法"><a href="#P-Q分解法" class="headerlink" title="P-Q分解法"></a>P-Q分解法</h4><script type="math/tex; mode=display">\begin{gather*}简化：\begin{cases}cos\theta_{ij}\approx1\\G_{ij}sin\theta_{ij}<<B_{ij}\\Q_i(互导纳)<<U_i^2B_i(自导纳)\\\end{cases}\Rightarrow \begin{cases} H_{ij}= L_{ij}\approx U_iU_jB_{ij}\\N_{ij}=L_{ij}\approx0 \end{cases}\\\Rightarrow \begin{cases}\Delta P=UB'U\Delta\theta\\\Delta Q=UB''\Delta U\end{cases}\end{gather*}</script><ul><li><p>好处：用一个n-1和一个n-m-1阶的方程组代替2(n-1)-m阶的方程组</p></li><li><p>其中，<strong>$B’$是去掉平衡节点的节点导纳矩阵（的虚部），$B’’$是去掉平衡节点和PV节点的节点导纳矩阵（的虚部）</strong>，$U$是对角矩阵</p></li></ul><h4 id="直流潮流法"><a href="#直流潮流法" class="headerlink" title="直流潮流法"></a>直流潮流法</h4><script type="math/tex; mode=display">\begin{gather*}继续简化：\begin{cases}g_{ij}=0,b_{ij}=-\frac1{x_{ij}}\\U_i=1\\sin_{ij}=\theta_i-\theta_j \end{cases}\Rightarrow\begin{cases} \theta=(-B')P\\P_{ij}=\frac{\theta_i-\theta_j}{x_{ij}}\end{cases}\end{gather*}</script><h2 id="有功与频率调整"><a href="#有功与频率调整" class="headerlink" title="有功与频率调整"></a>有功与频率调整</h2><ul><li>基本方程：<ul><li>$\frac{T_j}{\omega}\cdot\frac{\text d\omega}{\text dt}=P_T-P_E$</li><li>$发电机发电P_G=线路网损P_L+负载损耗P_D$</li></ul></li></ul><h3 id="频率调节效应系数（单位调节功率）"><a href="#频率调节效应系数（单位调节功率）" class="headerlink" title="频率调节效应系数（单位调节功率）"></a>频率调节效应系数（单位调节功率）</h3><ul><li><p>负荷：</p><ul><li>$P_D=a_0P+a_1P(\frac{f}{f_e})+\dots+a_nP(\frac f{f_e})^{n-1}$，负载消耗有功与频率同向变化，小范围内近似为直线</li><li>$K<em>D=\frac{\Delta P_D}{\Delta f}=\sum ia_i$，为曲线斜率，$K</em>{D*}=\frac{\Delta P_D/P_N}{\Delta f/f_N}$</li></ul></li><li><p>发电机：</p><ul><li>发电机输出有功与频率反向变化，近似为直线</li><li>$K<em>G=-\frac{\Delta P_G}{\Delta f}$，为曲线斜率的负数（绝对值），$K</em>{G*}=\frac{\Delta P_G/P_N}{\Delta f/f_N}$</li></ul></li><li><p>整个电力系统：</p><ul><li>$K<em>S=K_G+K_D$（三个都是正数，建议使用有名值而非标幺值）$K=K</em>*\frac{P_N}{f_N}$</li></ul></li></ul><h3 id="一次与二次调频"><a href="#一次与二次调频" class="headerlink" title="一次与二次调频"></a>一次与二次调频</h3><p>一次调频：调速器。二次调频：调频器。</p><p><img src="\image\稳态12.png" alt=""></p><ul><li>一次调频：$\Delta P_D=(K_G+K_D)\Delta f’=K_S\Delta f’$，即$f_0’=f_0-\frac{\Delta P_D}{K_S}$（这里的$P_D$就是上图中的$P_L$，表示负荷而非网损）</li><li><p>二次调频：$\Delta P_D-\Delta P_G=K_S\Delta f’’$，即$f_0’’=f_0-\frac{\Delta P_D-\Delta P_G}{K_S}$</p></li><li><p>联合调频：就是相当于变成了一个系统，调节系数和功率消耗都相加——$\Delta f=\frac{\Delta P_a+\Delta P_b}{K_a+K_b}$</p><ul><li>$\Delta P_{ab}=\frac{K_a\Delta P_b-K_b\Delta P_a}{K_a+K_b}$</li></ul></li></ul><h3 id="有功的经济分配"><a href="#有功的经济分配" class="headerlink" title="有功的经济分配"></a>有功的经济分配</h3><ul><li>等微增率原则：（目标：$minF$）</li></ul><script type="math/tex; mode=display">\begin{gather*}不考虑网损：\begin{cases}\sum P_{Gi}=P_D\\\frac{\partial F_i(P_{Gi})}{\partial P_{Gi}} =\lambda\end{cases}\Rightarrow考虑网损：\begin{cases}\sum P_{Gi}=P_D+P_L\\\frac{\partial F_i(P_{Gi})}{\partial P_{Gi}}\frac1{1-\frac{\partial P_L}{\partial P_{Gi}}}=\lambda\end{cases}\end{gather*}</script><ul><li>先计算，后验算。若有$P<em>{Gi}&gt;P</em>{Gi\,max}$则取其为最大值，对剩下的系统再次用等微增率原则进行分配。最小值同理。</li></ul><h2 id="无功与电压调整"><a href="#无功与电压调整" class="headerlink" title="无功与电压调整"></a>无功与电压调整</h2><p><img src="\image\稳态13.png" alt=""></p><h3 id="变压器调压"><a href="#变压器调压" class="headerlink" title="变压器调压"></a>变压器调压</h3><p><img src="\image\稳态14.png" alt=""></p><p><img src="\image\稳态15.png" alt=""></p><p>遇到这种问题不要急也不用硬背公式，先画电路图再写电压方程，慢慢转化，把k换成额定变比，记住我们最终要求的量是1侧的额定电压。</p><p><img src="\image\稳态16.png" alt=""></p><h3 id="无功补偿装置调压"><a href="#无功补偿装置调压" class="headerlink" title="无功补偿装置调压"></a>无功补偿装置调压</h3><p>由$U<em>1\approx U_2’+\frac{PR+QX}{U_2’}=kU</em>{2R}+\frac{PR+(Q-Q<em>C)X}{kU</em>{2R}}$，得到$Q<em>C\approx\frac{kU</em>{2R}}X(kU_{2R}-U_2’)$</p><ul><li>最小补偿容量$Q_C$：（与变压器分接头共同调节）</li></ul><div class="table-container"><table><thead><tr><th>步骤</th><th>调相机</th><th>并联电容器</th></tr></thead><tbody><tr><td>$Q_{Cmin}$</td><td>$-K<em>QQ</em>{CN}$（取K=0.5）</td><td>$0$</td></tr><tr><td>1</td><td>将最大最小Q带入公式联立<br />$k=\frac{U<em>{2Rmax}U’</em>{2max}+2U<em>{2Rmin}U</em>{2min}’}{U<em>{2Rmax}^2+2U</em>{2Rmin}^2}$</td><td>最小负荷下选分接头<br />$U<em>{1t}=\frac{U</em>{1min}-\Delta U}{U<em>{2Rmin}}U</em>{2t}$</td></tr><tr><td>2</td><td>求得变比K后选择最近的分接头，求$Q_{CN}$并验算</td><td>按上述$Q_C$公式确定补偿容量并验算</td></tr></tbody></table></div><h3 id="串联电容调压"><a href="#串联电容调压" class="headerlink" title="串联电容调压"></a>串联电容调压</h3><p>上面是改变Q，这个是改变X：$U<em>1\approx U_2+\frac{PR+QX}{U_2}=U</em>{2R}+\frac{PR+Q(X-X<em>C)}{U</em>{2R}}$，得到$X<em>C\approx\frac{U</em>{2R}}Q(U_{2R}-U_2)$</p><p>设串联了$n$组电容，每“组”电容由$m$个电容器并联而成，则：</p><ul><li>$m=I<em>{Cmax}/I</em>{CN}$，$n=X<em>C/(\frac{X</em>{CN}}m)$，$Q=3mnQ_{CN}$</li></ul><h3 id="无功的经济分配"><a href="#无功的经济分配" class="headerlink" title="无功的经济分配"></a>无功的经济分配</h3><ul><li>等微增率原则：（目标：$minP_L$）</li></ul><script type="math/tex; mode=display">\begin{gather*}考虑无功网损：\begin{cases}\sum Q_i=Q_L+Q_D\\\frac{\partial P_L}{\partial Q_{i}}\frac1{1-\frac{\partial Q_L}{\partial Q_{i}}}=\lambda\end{cases}\end{gather*}</script>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电机学笔记（总）</title>
      <link href="/2026/02/24/%E7%94%B5%E6%9C%BA%E5%AD%A6/"/>
      <url>/2026/02/24/%E7%94%B5%E6%9C%BA%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li><strong>整理了PDF版本，内容跟下面差别不大，好处是可以打印而且不会出现渲染问题</strong><ul><li>为了防止电机学课程总结作业的查重（那啥x），老版本带了一点点水印，应该不影响阅读</li><li><a href="\myfile\电机学笔记_水印版.pdf" target="_blank">电机学笔记(Watermark)</a></li><li><a href="\myfile\电机学笔记.pdf" target="_blank">电机学笔记</a></li></ul></li><li>字太多了，难免有打错的，大家见谅（找到问题跟我说一句谢谢）</li></ul><h1 id="导论与数理基础"><a href="#导论与数理基础" class="headerlink" title="导论与数理基础"></a>导论与数理基础</h1><div class="table-container"><table><thead><tr><th></th><th>势能</th><th>场强</th><th>流</th><th>介质</th><th>阻</th><th>欧姆定律</th></tr></thead><tbody><tr><td>电</td><td>电动势$U=\oint E\text dl$</td><td>电场强度E</td><td>电流I</td><td>$\varepsilon$</td><td>$R=\frac{\rho l}A$</td><td>$i=\frac u R$</td></tr><tr><td>磁</td><td>磁动势$F=\oint H\text dl$</td><td>磁场强度H</td><td>磁通$\phi$</td><td>$\frac1{\mu}$</td><td>$R_m=\frac l{\mu A}$</td><td>$\phi=\frac F{R_m}$</td></tr></tbody></table></div><ol><li><p>全电流定律</p><script type="math/tex; mode=display">\oint H\text dl=\Sigma i=Ni</script></li><li><p>基尔霍夫定律</p><script type="math/tex; mode=display">\begin{gather*}对任意节点（封闭曲面），流之和为0：&\Sigma\phi=0\\对任意回路，势之和为0：&\Sigma F=\Sigma Ni=\Sigma Hl=\Sigma \phi R_m\end{gather*}</script></li><li><p>电磁感应定律</p><script type="math/tex; mode=display">e=-\frac{\partial\Psi}{\partial t}=-N\frac{\text d\phi}{\text dt}</script></li></ol><h1 id="直流电机"><a href="#直流电机" class="headerlink" title="直流电机"></a>直流电机</h1><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><script type="math/tex; mode=display">\begin{gather*}\begin{cases}静止部分：定子\begin{cases}机座：支撑、构成磁极间的磁通回路\\主磁极：产生气隙磁场\begin{cases}励磁绕组：用于产生励磁磁场 \\主磁极铁芯\end{cases}\\电刷装置：将电枢绕组和外电路联通\\换向极：改善两换向器间Gap性能\end{cases}\\\\转子（电枢）\begin{cases}电枢铁芯：用来放电枢绕组，由硅钢片叠成\\电枢绕组：机电能量转换，绕成定性线圈嵌在电枢铁芯内\\换向器\end{cases}\end{cases}\end{gather*}</script><p>注：<strong>电枢</strong>和<strong>励磁</strong>究竟谁是定子谁是转子，依据不同的情况来看。直流电机中以上述为主，同步电机中则相反（即电枢变成了定子）。</p><ul><li>额定功率$P_N$<ol><li>发电机输出电功率：$P=EI=2Blv\cdot I=2BIlv$</li><li>电动机输出机械功率：$P=T\cdot\Omega=2F\cdot\frac D2\cdot\frac{2\pi n}{60}=2BIlv$</li></ol></li></ul><h2 id="电枢绕组"><a href="#电枢绕组" class="headerlink" title="电枢绕组"></a>电枢绕组</h2><p>​        每一匝绕组元件$i$始于一个换向片$i$，然后其上元件边通过槽$i$，下元件边通过槽$j$，最终另一个端口终于另一个换向片$k$。一个换向片连着两个绕组元件，一个始，一个终。可以看到，一个绕组元件我们用了三个量来表示，因此一个绕组元件的三个特征值就是$i,j,k$。</p><p>​        对于叠绕组，一定有$k=i+1$，波绕组则是$k&gt;j&gt;i$。在绕组连接表中，一根实线+一根虚线代表了一个绕组元件，其三个端点正好对应着上文的三个值：起始片\&amp;上元件边$i$,下元件边$j$,终止片$k$。</p><script type="math/tex; mode=display">元件数S=虚槽数Z_u=换向片数K</script><ul><li>Def：主磁极极对数：P（P对，2P个）</li><li>在这里，“槽数”变相的成为了一种单位。</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>叠绕组</th><th>波绕组</th></tr></thead><tbody><tr><td>极距$\tau$：一个主磁极跨度所占据的槽数</td><td>$\tau=\frac{Z_u}{2P} =\frac K{2P}$</td><td>$\tau=\frac{Z_u}{2P} =\frac K{2P}$</td></tr><tr><td>换向器节距$y_k$=合成节距$y=y_1+y_2$</td><td>$y=\pm1$</td><td>$y=\frac{K-1}P$</td></tr><tr><td>第一节距$y_1$：同一线圈上下元件边跨过槽数</td><td>$y_1=\lfloor\tau\rfloor$</td><td>$y_1=\lfloor\tau\rfloor$</td></tr><tr><td>第二节距$y_2$：上一线圈下层边 - 下一线圈上层边</td><td>$y_2=y-y_1$</td><td>$y_2=y-y_1$</td></tr><tr><td>电刷数（相当于截断）</td><td>2P</td><td>理论2，实际2P</td></tr><tr><td>并联支路数</td><td>2P个，P对<br />每一级构成一条支路</td><td>2个<br />同一极性(N/S)一条支路</td></tr></tbody></table></div><ul><li><strong>两者唯一有区别的就是合成节距的算法</strong>，其他的都一样。</li></ul><h2 id="直流电机磁场"><a href="#直流电机磁场" class="headerlink" title="直流电机磁场"></a>直流电机磁场</h2><p>​        直流电机一共有两个磁场，一个是定子通电提供的定子励磁磁场，一个是转子的电枢磁场。<strong>励磁磁场</strong>相对简单，会在空间中产生<strong>励磁磁动势$F_f$（起主要作用）</strong>；<strong>电枢磁场</strong>会在空间中产生电枢磁场磁动势$F_a$，对励磁磁场产生影响；两者叠加产生<strong>气隙磁场（带载磁场）</strong>。</p><h3 id="励磁磁场-F-f"><a href="#励磁磁场-F-f" class="headerlink" title="励磁磁场$F_f$"></a>励磁磁场$F_f$</h3><p><strong>分类：</strong></p><ol><li>他励：励磁绕组和电枢绕组用不同的独立电源供电</li><li>并励：励磁绕组和电枢绕组并联供电</li><li>串励：励磁绕组和电枢绕组串联供电</li><li>复励：有两个励磁绕组，并+串；积复励/差复励</li></ol><p><strong>磁场特点：</strong></p><ol><li><p>在空载时，电枢电流$I_a=0$，不产生磁场。因此空载时直流电机的磁场分布，就是励磁磁场。</p></li><li><p><strong>励磁磁场由主磁极的主磁通产生</strong>，因为存在严重的饱和，因此在主磁极覆盖范围内均水平，在气隙处迅速下降。</p><p><img src="\image\电机学02.png" alt=""></p></li><li><p>总磁动势计算：$F_0=\oint H\text dl=2I_fN_f$，若忽略漏磁通，则$F_0=2F_f\,\,;\,\,F_f=I_fN_f$。</p></li></ol><h3 id="电枢磁场-F-a"><a href="#电枢磁场-F-a" class="headerlink" title="电枢磁场$F_a$"></a>电枢磁场$F_a$</h3><p>​        电枢是转子，<strong>电枢磁场由电枢绕组上的导体通入的电流产生</strong>，而导体均匀分布导致电流近似均匀分布，因此电枢磁场磁动势大小随着坐标$x$线性增大。直到通过换向片处电流反向，此时磁动势大小线性减小。</p><p><strong>(a) 电刷放置在几何中心线上:</strong></p><ol><li><p><strong>磁动势计算</strong>：$F_a={\sum i}=\frac{x}{\pi D_a}Ni_a=\frac{Ni_a}{\pi D_a}x$，并定义电枢表面线负荷$A\triangleq \frac{Ni_a}{\pi D_a}$</p></li><li><p>气隙电枢磁密：$B_{ax}=\mu_0\frac{F}{\delta’}$，先线性增大，超出主磁极范围接近换向片后，由于气隙的急剧增大而急剧减小。</p><p><img src="\image\电机学01.png" alt=""></p></li></ol><p><strong>(b) 电刷不在几何中心线上:</strong></p><ol><li>在实际中，由于误差导致电刷偏离了中心线一个小角度$\beta$，即长度$b_{\beta}=\frac D2\beta$。</li><li>将磁场分解（实际上是将环绕了电枢一圈的电枢电流分解）为交轴磁场和直轴磁场。<ol><li>交轴磁动势：与<strong>原电枢磁动势</strong>很像，以<strong>原电刷位置对称（几何中心线）</strong>，但是三角波的尖头被削平。</li><li>直轴磁动势：与原<strong>励磁磁动势</strong>很像，以<strong>主磁极位置对称</strong>，方向相同或者相反。</li></ol></li></ol><h3 id="电枢反应"><a href="#电枢反应" class="headerlink" title="电枢反应"></a>电枢反应</h3><p>​        电枢反应实际上就是指两个磁场叠加，合起来对电机的工作产生影响。不难看出，<strong>两个磁场都是静止的</strong>：励磁磁场静止是因为定子本来就静止，可以直接看做是不动的永磁体；电枢磁场静止是因为，即使电枢导体的电流在随着转子转动经过换向器不断改变方向，但是<strong>宏观上磁场一直以换向器为中心对称</strong>。</p><p><img src="\image\电机学05.png" alt=""></p><p>​        由于<strong>励磁磁场沿主磁极轴对称，而电枢磁场沿换向片对称，主磁极与电刷正好相差90°电角度</strong>（电刷塞在两磁极中的空隙里），因此一般呈现交轴电枢反应（建议与同步电机一起看）：</p><ol><li>两者相位差90°，电枢磁场使励磁磁场产生畸变</li><li>交轴反应理论不改变总磁通大小，但是由于饱和，增磁处难以增磁，因此磁通一般而言还是会减小</li><li>直轴电枢反应由电刷偏离几何中心线引起，表现为增磁或去磁</li><li><strong>电枢反应的影响一般在题目中会用额外励磁电流 $I_{faq}$ 等效，表示为了“抗衡”电枢反应，需要额外提供的励磁</strong></li></ol><h3 id="感应电动势-amp-电磁转矩"><a href="#感应电动势-amp-电磁转矩" class="headerlink" title="感应电动势&amp;电磁转矩"></a>感应电动势&amp;电磁转矩</h3><script type="math/tex; mode=display">\begin{gather*}E_a=\frac{NP}{60a}\cdot\phi \cdot n\\T=\frac{NP}{2\pi a}\cdot\phi\cdot I_a\end{gather*}</script><h2 id="直流电机模型与特性曲线"><a href="#直流电机模型与特性曲线" class="headerlink" title="直流电机模型与特性曲线"></a>直流电机模型与特性曲线</h2><div class="table-container"><table><thead><tr><th></th><th>发电机</th><th>电动机</th></tr></thead><tbody><tr><td>模型</td><td><img src="\image\电机学04.jpg" alt=""></td><td><img src="\image\电机学03.jpg" alt=""></td></tr><tr><td>电压</td><td>$E_a=U+I_aR_a+2\Delta U_b$</td><td>$U=E<em>a+I_a(R_a+R</em>{aj})$</td></tr><tr><td></td><td>$U=I_f(R_f+R_j)$</td><td>$U=I_f(R_f+R_j)$</td></tr><tr><td>电流</td><td>$I_a=I+I_f$</td><td>$I=I_a+I_f$</td></tr><tr><td>转矩</td><td>$T<em>1=T</em>{em}+T_0$</td><td>$T_{em}=T_2+T_0$</td></tr><tr><td>功率</td><td><img src="\image\电机学061.jpg" alt=""></td><td><img src="\image\电机学062.jpg" alt=""></td></tr></tbody></table></div><p>[注]：在并励发电机功率中也有$p_{cuf}$的铜耗，这里没标注</p><p><a id="ee">同步电机零功率因数负载特性</a></p><div class="table-container"><table><thead><tr><th></th><th><strong>发电机</strong></th><th><strong>电动机</strong></th></tr></thead><tbody><tr><td><strong>负载特性</strong></td><td><img src="\image\电机学20.png" alt=""></td><td><img src="\image\电机学22.png" alt=""></td></tr><tr><td><strong>特点</strong></td><td>对发电机而言，<strong>电枢反应的影响等效为额外的励磁电流$I_{faq}$</strong>，并且由于$I<em>aR_a$电流—端电压”表或曲线时，需要使用$I</em>{f0}=I<em>{fN}-I</em>{faq}$！复励中串联的磁动势需要折算：$\frac{I_sN_s}{N_f}$</td><td>其实没啥好说的，这图应该见过比较多次的。需要注意的就是 $\eta=(1-\frac {\sum p}{P_1})\times 100\%$，在可变损耗$I_a^2R_a$=不变损耗$p_0$时取到效率最大值</td></tr><tr><td><strong>外特性</strong></td><td><img src="\image\电机学21.png" alt=""></td><td><img src="\image\电机学23.png" alt=""></td></tr><tr><td><strong>特点</strong></td><td>对于并励发电机，除了上图的$U_0=f(I_f)$外还需要满足$U_0=I_f(R_f+R_j)$，<strong>两者的交点即为空载端电压</strong>。因此其自励是需要满足<strong>剩磁+励磁电阻大小合适</strong>两个条件（当然接法要正确）</td><td>方程：$n=\frac{U-I<em>aR_a}{C_e\phi}=\frac{U}{C_e\phi}-\frac{R_a}{C_eC_T\phi^2}T</em>{em}$。这条最基础的方程就揭示了三个调速方法：<strong>调压</strong>（向下平移）、<strong>串阻</strong>（向下倾斜）、<strong>弱磁</strong>（向上平移+向下倾斜）</td></tr></tbody></table></div><h2 id="电动机的调节"><a href="#电动机的调节" class="headerlink" title="电动机的调节"></a>电动机的调节</h2><script type="math/tex; mode=display">n=\frac{U-I_aR_a}{C_e\phi}=\frac{U}{C_e\phi}-\frac{R_a}{C_eC_T\phi^2}T_{em}</script><h3 id="起动"><a href="#起动" class="headerlink" title="起动"></a>起动</h3><p>​        起动的要求是具有足够小的电流$I<em>{st}$与足够大的启动转矩$T</em>{st}$。由电动机的机械特性（即上表中的外特性），可以得到：</p><div class="table-container"><table><thead><tr><th></th><th>降压起动</th><th>串电阻起动</th></tr></thead><tbody><tr><td><strong>起动电流</strong></td><td>$I_{st}=\frac{U’}{R_a}$</td><td>$I<em>{st}=\frac{U_N}{R_a+R</em>{aj}}$</td></tr><tr><td><strong>起动转矩</strong></td><td>$T_{st}=\frac{U’C_T\phi}{R_a}$</td><td>$T<em>{st}=\frac{U_NC_T\phi}{R_a+R</em>{aj}}$</td></tr></tbody></table></div><h3 id="调速"><a href="#调速" class="headerlink" title="调速"></a>调速</h3><div class="table-container"><table><thead><tr><th></th><th>调压调速</th><th>串电阻调速</th><th>弱磁调速</th></tr></thead><tbody><tr><td><strong>特点</strong></td><td>只能降转速，特性曲线一样硬</td><td>只能降转速，特性曲线变软，耗能，轻载时不明显</td><td>只能增转速，用于恒转矩负载时$I_a=\frac{T}{C_T\phi}$变高，适用于恒功率负载</td></tr></tbody></table></div><h3 id="制动"><a href="#制动" class="headerlink" title="制动"></a>制动</h3><table style="text-align: center;">        <tr>        <th rowspan=2> 分类 </th> <th colspan=2> 反接制动 </th><th rowspan=2>能耗制动</th><th colspan=2>回馈制动</th>    </tr>    <tr>        <th>电压反向(II)</th><th>电动势反向(IV)</th><th>电压反向(IV)</th><th>电压不反向(II)</th>    </tr>    <tr>        <th>实现 </th><td>电枢电压UN反向并串限流电阻</td><td>串一个极大的电阻Raj</td><td>断开电源并串限流电阻Raj</td><td>电压反向的反接制动，n=0不停机，Tem=0时切除电阻使匀速下放</td><td>电车下坡时具有同向转矩，转速冲过y轴</td>    </tr>    <tr>        <th>特点</th><td>快速停机，需要在n=0时手动停机</td><td>特性曲线极软，适用于位能型负载</td><td>恒转矩负载：自动停机<br>位能型负载：反向起动</td><td>位能型负载的匀速下放</td><td>电车下坡</td>    </tr>    <tr>        <th>能流方向</th><td colspan=2>电源给电机供能，同系统动能一起消耗在电阻上</td><td>电源断开无输入，动能消耗在电阻上</td><td>匀速下放阶段将势能转成电能回给电网</td><td>能量回馈制动状态</td>    </tr></table><h1 id="变压器"><a href="#变压器" class="headerlink" title="变压器"></a>变压器</h1><h2 id="等效电路与物理量"><a href="#等效电路与物理量" class="headerlink" title="等效电路与物理量"></a>等效电路与物理量</h2><div class="table-container"><table><thead><tr><th>T型等效</th><th>$\tau$型等效</th></tr></thead><tbody><tr><td><img src="\image\电机学07.png" alt=""></td><td><img src="\image\电机学08.png" alt=""></td></tr></tbody></table></div><p>根据小学二年级学的基尔霍夫，我们可以很容易的写出电路关系：（物理量的等效关系不再赘述，反正就是$k$或者$k^2$倍）</p><ol><li>$E_1=\sqrt2\pi fN\phi_m$</li><li>$\dot U<em>1=(-\dot E_1)+\dot I_1(R_1+jX</em>{1\sigma})\approx-\dot E_1$</li><li>$\dot U<em>2’=\dot E_2’-\dot I_2’(R_2’+jX</em>{2\sigma}’)$</li><li>$\dot I_m=\dot I_1-(-\dot I_2)$</li><li>$\dot E_1=\dot E_2’=-\dot I_m(R_m+jX_m)$</li><li>$\dot U_2’=\dot I_2’Z_L’$</li></ol><div class="table-container"><table><thead><tr><th>励磁参数$(R_m+jX_m)$</th><th>绕组电阻、漏电抗$(R<em>1+jX</em>{1\sigma})$</th></tr></thead><tbody><tr><td>励磁参数反映了<strong>主磁通</strong>对变压器的影响，其中<strong>励磁电阻反映铁耗$p_{Fe}$</strong>，励磁电抗反映电磁效应。因为其反映磁通关系，因此其值<strong>随着饱和程度的增加而减小</strong>。<strong>励磁阻抗远大于漏阻抗</strong>。</td><td>漏阻抗（绕组电阻和漏电抗）反映了<strong>漏磁通</strong>对变压器的影响，其影响主要体现在<strong>产生了一段压降</strong>$E<em>{1\sigma}$，其中**绕组电阻$R_1/R_2$还反映了铜耗$p</em>{cu1}/p_{cu2}$<strong>。其值</strong>基本恒定**不会变化。漏阻抗远小于励磁阻抗。</td></tr><tr><td><strong>空载试验</strong>——$R_L\rightarrow\infty$，令非开路端$U=U_N$，记录非开路段空载电流$I_0$和损耗$p_0$，有：$R_m=\frac{p_0}{I_0^2};Z_m=\frac{U_N}{I_0}$</td><td><strong>短路试验</strong>——$R_L\rightarrow0$，令非短路端$I=I_N$，记录非短路端短路电压$U_k$和损耗$p_k$，有：$R_k=\frac{p_k}{I_N^2};Z_k=\frac{U_k}{I_N}$</td></tr><tr><td>哪端不开路，参数归算到哪端</td><td>哪端不短路，参数归算到哪端</td></tr></tbody></table></div><ul><li>注：$R_k=R_1+R_2’=R_1+k^2R_2$，$Z$和$L$同理。</li></ul><h3 id="恒磁通、自跟随"><a href="#恒磁通、自跟随" class="headerlink" title="恒磁通、自跟随"></a>恒磁通、自跟随</h3><p>这六个字的含义是<strong>从空载到负载时</strong>，电路中物理量的变化法则，在交流电机中也会用到。</p><ul><li><p>恒磁通：可以认为$-\dot E_1\approx\dot U_1$，在输入电压不变的情况下，$\phi_m=\frac{E_1}{4.44fN}$应该保持不变，即主磁通恒定</p><ul><li><img src="\image\电机学11.png" alt=""></li></ul></li><li><p>自跟随：当主磁通不变时，合成磁动势$\dot F_m=\dot F_1+\dot F_2=\dot I_1N_1+\dot I_2N_2=\dot I_0N_1$也应该保持不变，那么在接入负载出现$I_2$时，$I_1$将会自动修正，即$\dot I_1=\dot I_0-\frac{N_2}{N_1}\dot I_2=\dot I_0-\frac{1}{k}\dot I_2$。其意义就是，变压器原副边通过<strong>磁动势平衡</strong>相关联，因此在副边电流变化的时候，原边会自动调节电流和输入功率以满足输出功率的要求。</p><ul><li><img src="\image\电机学12.png" alt=""></li></ul></li></ul><h3 id="工作特性"><a href="#工作特性" class="headerlink" title="工作特性"></a>工作特性</h3><p>当变压器对外接通时，就像一个带小电阻的电压源，随着外电流的上升，输出电压缓慢下降，故$\Delta U=\frac{U<em>{2N}-U_2}{U</em>{2N}}\times100\%=1-U_2*$</p><p>变压器的效率随着外电流的增大先增加后减小，当不变损耗=可变损耗（$p_0=I_2^{*2}p_k$）时取到最大值</p><script type="math/tex; mode=display">\begin{gather*}\Delta U=I_2^*(R_k^*\text{cos}\varphi_2+Z_k^*\text{sin}\varphi_2)\times100\%\\\eta=(1-\frac{p_0+I_2^{*2}p_k}{I_2^*S_N\text{cos}\varphi_2+ p_0+I_2^{*2}p_k})\times100\%\end{gather*}</script><h2 id="三相变压器"><a href="#三相变压器" class="headerlink" title="三相变压器"></a>三相变压器</h2><p><strong>空载电势波形判断方法和原则：</strong></p><ul><li>当主磁通为正弦变化时，由于饱和的原因，励磁电流必须为尖顶波，可分解为正弦波+各次谐波分量<ol><li>如果电流的谐波分量可以在副边流通，那么副边仍然会产生正弦磁通，可以运行</li><li>若不行，那么副边电流正弦，磁通将会变成平顶波，可分解为正弦波+各次谐波分量</li><li>如果磁通的谐波分量可以被消除，那么磁通仍表现为正弦形式，可以运行；否则无法运行</li></ol></li><li>Y型接法无法流通<strong>电流</strong>谐波分量，△型接法无法流通<strong>磁势</strong>谐波分量（实际上是<strong>去磁</strong>）</li><li>组式变压器不会去磁，而芯式变压器会去磁</li></ul><p><img src="\image\电机学09.jpg" alt=""></p><p><strong>结论：</strong></p><script type="math/tex; mode=display">\begin{gather*}原边\begin{cases}Y&看副边\\Y_0/\Delta &√\end{cases}\rightarrow副边\begin{cases}Y/Y_0&看磁路\\\Delta&√ \end{cases}\rightarrow磁路\begin{cases}组式&×\\芯式&√  \end{cases}\end{gather*}</script><h1 id="交流电机的一般理论"><a href="#交流电机的一般理论" class="headerlink" title="交流电机的一般理论"></a>交流电机的一般理论</h1><h2 id="交流电机的物理量"><a href="#交流电机的物理量" class="headerlink" title="交流电机的物理量"></a>交流电机的物理量</h2><div class="table-container"><table><thead><tr><th>电角度</th><th>槽距角</th><th>每极每相槽数</th><th>相带</th><th>极距</th></tr></thead><tbody><tr><td>$机械角度\times P$</td><td>$\alpha=P\frac{360°}{Z_1}$</td><td>$q=\frac{Z_1}{m\cdot2P}$</td><td>$q\cdot \alpha$</td><td>$\tau=\frac{\pi D}{2P}=\frac{Z_1}{2P}$</td></tr></tbody></table></div><p><strong>连接法的几点注意事项：</strong></p><ol><li>单层绕组（每个槽只放一层元件边）并联支路数最大为$\alpha<em>{max}=P$，双层绕组$\alpha</em>{max}=2P$。根据并联支路数选择串并联。</li><li>单层绕组中，槽数=导体数=线圈数 * 2；双层绕组中，槽数=导体数 / 2=线圈数</li><li>不管怎么连接，每一极最终都只会引出两条线：A/X，B/Y，C/Z</li><li><strong>叠绕组</strong>：先计算出$y_1$，且叠绕组$y=1$。从每个线圈组的第一条导体（上层边）开始，先右移$y_1$（下层边），然后左移$y_1-1$（上层边），共$2P=\frac{Z_1}{mq}$个线圈组。这样每个线圈组都会引出两条线，然后根据<strong>首连首、尾连尾</strong>的法则和并联支路数的要求，进行串并联。叠绕组的优点是可以节约用铜，能得到较多的并联支路数，但是连接困难。</li><li><strong>波绕组</strong>：先计算出$y_1$和$y_2$。波绕组把所有同级（N或S）下的导体全部串起来，根据并联支路数$a=1还是2$确定串并联。从每级的第一条导体（上层边）开始，先右移$y_1$（下层边），然后右移$y_2=y-y_1$（上层边），共2个线圈组（N一个，S一个）。当绕完一圈后，需要人为退一个槽。波绕组的短距不能节约用铜。</li></ol><p><img src="\image\电机学10.jpg" alt=""></p><h2 id="电动势与磁动势"><a href="#电动势与磁动势" class="headerlink" title="电动势与磁动势"></a>电动势与磁动势</h2><div class="table-container"><table><thead><tr><th></th><th>磁动势</th><th>电动势</th><th></th></tr></thead><tbody><tr><td>整距线圈</td><td>$F=\frac{2\sqrt2}{\pi}I_cN_y$</td><td>$E<em>{c\nu}=\frac{\sqrt2}2\pi f\phi</em>{\nu}$</td><td>单根导体</td></tr><tr><td>线圈组（整距）</td><td>$k_{q\nu}=\frac{\text{sin}q\frac{\nu\alpha_1}2}{q\text{din}\frac{\nu\alpha_1}2}$（$\times q$）</td><td>$E<em>{t\nu}=2E</em>{c\nu}N<em>yk</em>{y\nu}$</td><td>单个线圈</td></tr><tr><td>双层短距修正</td><td>$k_{y\nu}=\text{sin}(\frac{\nu y_1}{\tau}90°)$</td><td>$\times2$是线圈有2根导体</td><td></td></tr><tr><td>一相绕组(脉振)</td><td>$F<em>{\varphi \nu}=0.9\frac{IN}p k</em>{w\nu}$</td><td>$k_{q\nu}$（$\times q$）</td><td>线圈组</td></tr><tr><td>三相绕组(旋转)</td><td>$F<em>{\nu}=\frac m2 F</em>{\varphi \nu}$</td><td>$ E<em>{\phi\nu}=4.44fN\phi k</em>{w\nu} $</td><td>一相绕组</td></tr></tbody></table></div><ul><li>$I_c=\frac Ia$为线圈电流（$I$是相电流），$N_y$是线圈匝数</li><li>记：<strong>每相串联匝数：</strong>$N=\frac{2PqN_y}a(双层)=\frac{PqN_y}2(单层)$</li><li>最后的公式（<strong>一相脉振磁动势、三相旋转磁动势和一相绕组相电动势</strong>）直接记，都是根据上面一步步演化来的，主要推导的难点就是每相串联匝数的公式和单层、双层修正中是否需要乘2。</li></ul><h3 id="谐波的计算"><a href="#谐波的计算" class="headerlink" title="谐波的计算"></a>谐波的计算</h3><p>​        一般我们见到的就是同步谐波，这里讲一下同步谐波的特点和计算：</p><ul><li>同步谐波跟着基波一起旋转，他是傅里叶变换里面出来的，因此在基波走完一个周期的时候同步谐波可以走$\nu$个周期。因此同步谐波的数据满足：<ol><li>转速与基波转速相等：$n_{\nu}=n_1$</li><li>频率比基波频率要高：$f_{\nu}=\nu f_1$</li><li>极距比基波极距要小：$\tau_{\nu}=\frac{\tau}{\nu}$</li><li>级数比基波级数要大：$P_{\nu}=\nu P$</li></ol></li><li>所以在计算同步谐波幅值的时候，需要对上面的公式做以下几点修正：<ol><li>两个修正系数都要变，一个变成$\nu\alpha$，一个变成$\nu y_1$，可能出现负值</li><li>公式中的频率要进行修正成 $\nu f$</li><li>由于磁通 $\phi=B\tau l$，如果题中没有说明磁场的关系（$\frac{B<em>{\nu}}{B_1}$），就按照 $B</em>{\nu}=\frac1{\nu}B<em>1$ 的关系修正，否则按照题目的规定；同时修正极距 $\tau</em>{\nu}=\frac1{\nu}\tau$</li><li>因此在默认情况下且不考虑修正系数 $k_{w\nu}$，谐波的幅值是基波幅值的$\frac1{\nu}$</li></ol></li></ul><h3 id="磁动势谐波的计算"><a href="#磁动势谐波的计算" class="headerlink" title="磁动势谐波的计算"></a>磁动势谐波的计算</h3><ul><li>上述对磁动势不适用，磁动势谐波的特点为：<ol><li>频率与基波频率相等：$f_{\nu}=f_1$（即角频率）</li><li>转速比基波转速要小：$n_{\nu}=\frac1{\nu}n_1$（$n=\frac{60f}p$）</li><li>极距比基波极距要小：$\tau_{\nu}=\frac{\tau}{\nu}$</li><li>级数比基波级数要大：$P_{\nu}=\nu P$</li></ol></li><li>所以在计算<strong>磁动势</strong>的谐波幅值的时候，需要对上面的公式做以下几点修正：<ol><li>两个修正系数都要变，一个变成$\nu\alpha$，一个变成$\nu y_1$，可能出现负值</li><li>在默认情况下且不考虑修正系数 $k_{w\nu}$，谐波的幅值是基波幅值的$\frac1{\nu}$</li><li>写具体表达式的时候，由于电角度受极数的影响，故$\theta_{\nu}=\nu\theta$</li></ol></li></ul><h3 id="削弱谐波的影响"><a href="#削弱谐波的影响" class="headerlink" title="削弱谐波的影响"></a>削弱谐波的影响</h3><ol><li><p>短距绕组：令$k_{y\nu}=\text{sin}(\frac{\nu y_1}{\tau}90°)=0\Rightarrow y_1=\frac{2k\tau}{\nu}$，由于$\nu$一定是奇数，因此想要消除$\nu$次谐波，就令$2k=\nu-1$</p><p>注：可以同时消除次数相邻的两个谐波，如要消除$\nu=5/7$，则令$2k=6$</p></li><li><p>分布绕组：令$k_{q\nu}=\frac{\text{sin}q\frac{\nu\alpha_1}2}{q\text{din}\frac{\nu\alpha_1}2}$减小，即增大极对数$q$，一般取$q\in[2,6]$</p></li></ol><h1 id="异步电机"><a href="#异步电机" class="headerlink" title="异步电机"></a>异步电机</h1><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>异步电机的参数定义及公式如下：</p><div class="table-container"><table><thead><tr><th>参数</th><th>符号</th><th>定义</th><th>表达式</th></tr></thead><tbody><tr><td>同步速</td><td>$n_1$</td><td>旋转磁场（磁动势）的绝对转速</td><td>$n_1=\frac{60f}p$</td></tr><tr><td>转差率</td><td>$s$</td><td>转子转速与同步速之差的百分比</td><td>$s=\frac{n_1-n}{n_1}$</td></tr><tr><td>转子频率</td><td>$f_2$</td><td>转子绕组感应电动势的频率（切割）</td><td>$f_2=sf_1$</td></tr><tr><td>功率因数角</td><td>$\varPsi_2$</td><td>$\text{cos}\varPsi_2$为转子绕组的功率因数</td><td>$\text{cos}\varPsi<em>2=\frac{R_2’/s}{\sqrt{(R_2’/s)^2+X</em>{2\sigma}’^2}}$</td></tr></tbody></table></div><p>关于异步电机的工作原理有以下几个特点需要说明：</p><ol><li>定子侧的三相电流产生了转速为同步速的旋转磁场（见上一节），由切割产生的电磁转矩带动转子，因此为了保持转差，一般电动机$n<n_1$但是十分接近，故$s\rightarrow 0$，一般认为$s_N\approx2-5\%$。当$s<0$时作发电机运行，$s>1$时作电磁制动运行。</li><li>定子磁动势的转速是$n_1$，不论转子有无旋转，<strong>转子的磁动势一定与定子相对静止</strong>。</li><li>仍然满足<strong>恒磁通，自跟随</strong>的原理（具体见上），即在空载到负载（或堵转到旋转）的变化中，主磁通不变，原边电流随着副边电流的变化而自动调节。</li></ol><p>转子在堵转与转动的情况下，异步电机各参数的变化：</p><div class="table-container"><table><thead><tr><th>堵转</th><th>$n=0$</th><th>$\Delta n=n_1$</th><th>$f_2=f_1$</th><th>$E<em>2=4.44f_1N_2k</em>{w2}\phi_m$</th><th>$X<em>{2\sigma}=2\pi f_1L</em>{2\sigma}$</th><th>$\varPsi<em>2=\text{atan}\frac{X</em>{2\sigma}}{r_2}$</th></tr></thead><tbody><tr><td><strong>旋转</strong></td><td>$n\rightarrow n_1$</td><td>$\Delta n=sn_1$</td><td>$f_2=sf_1$</td><td>$E_{2s}=sE_2$</td><td>$X<em>{2\sigma s}=sX</em>{2\sigma}$</td><td>$\varPsi<em>2=\text{atan}\frac{sX</em>{2\sigma }}{r_2}$</td></tr></tbody></table></div><h2 id="等效电路图"><a href="#等效电路图" class="headerlink" title="等效电路图"></a>等效电路图</h2><p>跟变压器类似，原边和副边两侧的物理量的特性都不尽相同，因此计算麻烦，故用<strong>频率折算+绕组折算</strong>来简化电路图。</p><ul><li>频率折算：将转子频率$f_2$折算成定子频率$f_1$<ol><li>阻抗全部变为$\frac1s$倍，即$r<em>2\rightarrow r_2+\frac{1-s}sr_2~;~X</em>{2\sigma s}\rightarrow X<em>{2\sigma}=2\pi f_1L</em>{2\sigma}$</li></ol></li><li>绕组折算：类似于变压器的折算，电流电压倒数变化，阻抗为平方关系<ol><li>记电流和电压的变比分别为：$k<em>i=\frac{m_1N_1k</em>{w1}}{m<em>2N_2k</em>{w2}}~;~k<em>e=\frac{N_1k</em>{w1}}{N<em>2k</em>{w2}}$</li><li>注意两者是不一样的，因为电流是从磁动势（$0.9\frac m2\frac{INk_w}{p}$）推出，电压是从电动势（$4.44fNk_w\phi_m$）推出。但是对于大部分电机，原副边的相数是一样的（三相电机），因此有$k_i=k_e$</li><li>$I_2’=\frac1{k_i}I_2~;~E_2’=k_eE_2~;~Z_2’=k_ik_eZ_2$</li></ol></li></ul><p>得到的等效电路图如下：</p><div class="table-container"><table><thead><tr><th>$T$型等效电路</th><th>$\tau$型等效电路</th></tr></thead><tbody><tr><td><img src="\image\电机学13.png" alt=""></td><td><img src="\image\电机学14.png" alt=""></td></tr></tbody></table></div><p>根据小学二年级学的基尔霍夫，我们可以很容易的写出电路关系：（可以看到跟变压器的电路是非常像的）</p><ol><li>$\dot U<em>1=-\dot E_1+\dot I_1(R_1+jX</em>{1\sigma})$</li><li>$\dot E<em>1=\dot E_2’=\dot I_2’(R_2’+jX</em>{2\sigma}’+\frac{1-s}sR_2’)$</li><li>$\dot E_1=\dot E_2’=\dot I_m(R_m+jX_m)$</li><li>$\dot I_m=\dot I_1+(-\dot I_2’)$</li></ol><h2 id="运行特性"><a href="#运行特性" class="headerlink" title="运行特性"></a>运行特性</h2><h3 id="功率与转矩平衡"><a href="#功率与转矩平衡" class="headerlink" title="功率与转矩平衡"></a>功率与转矩平衡</h3><p>关于电机的功率关系式，只需要记住下面这一张图即可：</p><p><img src="\image\电机学15.jpg" alt=""></p><p>下面给出各个功率的物理表达式：</p><div class="table-container"><table><thead><tr><th>$P<em>1=m_1U</em>{1\varphi}I_{1\varphi}\text{cos}\varphi_1$</th><th>$p<em>{cu1}=m_1I</em>{1\varphi}^2R_1$</th><th>$p<em>{Fe}=m_1I</em>{m}^2R_m$</th><th>$p_{cu2}=m_1I_2’^2R_2’$</th><th>$p_{mec}=m_1I_2’^2\frac{1-s}sR_2’$</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p><strong>电磁转矩</strong>是最重要的转矩，下面给出它的4种表达式：</p><ol><li>$T<em>{em}=\frac{P</em>{mec}}{\Omega}=\frac{P<em>{mec}}{(1-s)\Omega_1}=\frac{P</em>{em}}{\Omega_1}$</li><li>$T<em>{em}=\frac{m_1E_2’I_2’\text{cos}\varPsi_2}{\Omega_1} =\frac{m_1\sqrt2\pi f_1N_1k</em>{w1}\phi_1I_2’\text{cos}\varPsi_2}{2\pi f_1/p}=C_M\phi_1I_2’\text{cos}\varPsi_2$<ol><li>其中$C<em>M=(pm_1N_1k</em>{w1})/\sqrt2$为常数</li><li>这个公式跟直流电机的电磁转矩公式很像，只是多了一个功率因数角（直流电机恒为1）</li></ol></li><li>$T<em>{em}=\frac{m_1pU_1^2\frac{R_2’}s}{2\pi f_1[(R_1+\frac{R_2’}s)^2+(X</em>{1\sigma}+X_{2\sigma})^2]}$</li><li>$T_{em}=\frac2{\frac s{s_m}+\frac{s_m}s}T_m\approx \frac{2T_m}{s_m}s$，工程上的近似算法，一般会给出$K_M$和$s_N$两者</li></ol><p>于是我们就可以画出他的<strong>机械特性</strong>如下：</p><p><img src="\image\电机学16.png" alt=""></p><ol><li>A点（同步运行点/空载点）<ol><li>$s=0,n=n_1$</li></ol></li><li>B点（最大转矩点）<ol><li>$s<em>m\approx \frac{R_2’}{X</em>{1\sigma}+X_{2\sigma}’}$</li><li>$T<em>m=\frac{m_1pU_1^2}{4\pi f(R_1+X</em>{1\sigma}+X_{2\sigma}’)}$</li></ol></li><li>C点（起动点）<ol><li>$s=1,n=0$</li><li>$T<em>{st}=\frac{m_1pU_1^2R_2’}{2\pi f_1[(R_1+R_2’)^2+(X</em>{1\sigma}+X_{2\sigma}’)^2]}$</li></ol></li><li>记：<ol><li>$k<em>{st}=\frac{T</em>{st}}{T_N}$</li><li>$k_M=\frac{T_m}{T_N}$</li></ol></li></ol><h3 id="工作特性-1"><a href="#工作特性-1" class="headerlink" title="工作特性"></a>工作特性</h3><p>他的工作特性跟变压器还是比较像的，所以就直接贴图吧</p><p><img src="\image\电机学17.png" alt=""></p><ol><li>计算效率时，可变损耗为$p<em>{cu1,cu2}$，不变损耗为$p</em>{Fe,ad,mec}$，同样可变损耗=不变损耗时，取到效率的最大值</li><li>转速随着输出功率的上升略有下降，转差率跟转速互补</li><li>电磁转矩$T_{em}=T_0+\frac P{\Omega}$，近似有截距的一次函数，但是由于转速的下降，转矩曲线略微上翘</li></ol><h2 id="起动-1"><a href="#起动-1" class="headerlink" title="起动"></a>起动</h2><p>一般要求电机起动的时候具有较大的转矩$T<em>{st}$和较小的起动电流$I</em>{st}$</p><p><strong>鼠笼式异步电机起动：</strong></p><div class="table-container"><table><thead><tr><th></th><th>定子串电抗</th><th>自耦变压器</th><th>$Y-\Delta$起动</th></tr></thead><tbody><tr><td>原理</td><td>定子上串联电抗$X$分压</td><td>通过变压器降低定子端电压</td><td>先用$Y$起动，之后改为$\Delta$运行</td></tr><tr><td>电压</td><td>$\frac1k$</td><td>$\frac1k$</td><td>$\frac1{\sqrt3}$</td></tr><tr><td>电流</td><td>$\frac1k$</td><td>$\frac1{k^2}$</td><td>$\frac13$</td></tr><tr><td>转矩</td><td>$\frac1{k^2}$</td><td>$\frac1{k^2}$</td><td>$\frac13$</td></tr></tbody></table></div><ul><li>均能够降低起动电流，但是都会以损失启动转矩作为代价，后两者的效果更好。</li><li>$Y-\Delta$起动相当于变压器变比为$\sqrt3$的自耦变压器起动。</li><li>起动电流$I_{st}$指的是电网提供的三相线电流</li></ul><p><strong>绕线式异步电机起动：</strong></p><p>不论是<strong>转子串电阻起动</strong>还是<strong>频敏电阻器起动</strong>，都是类似的，与直流电机电枢回路串电阻起动相似：分级起动，逐渐切除/减小电阻，固有特性逐渐变硬，电流不会超过限制。</p><h2 id="调速-1"><a href="#调速-1" class="headerlink" title="调速"></a>调速</h2><p>原理：由$n=(1-s)\frac{60f}p$，改变$s,f,p$均可完成电机的调速。</p><p>对于$P<em>{em}=P</em>{mec}+p<em>{cu2}=(1-s)P</em>{em}+sP<em>{em}$，调速的本质就是调节机械功率，因此可以通过对电磁功率$P</em>{em}$的调节（变频调速），或对转差功率$sP_{em}$的调节（调压、串电阻调速）完成。</p><script type="math/tex; mode=display">T_{em}=\frac{m_1pU_1^2\frac{R_2'}s}{2\pi f_1[(R_1+\frac{R_2'}s)^2+(X_{1\sigma}+X_{2\sigma})^2]}~;~s_m\approx \frac{R_2'}{X_{1\sigma}+X_{2\sigma}'}~;~T_m=\frac{m_1pU_1^2}{4\pi f(R_1+X_{1\sigma}+X_{2\sigma}')}</script><div class="table-container"><table><thead><tr><th></th><th>变频调速—基频下调</th><th>变频调速—基频上调</th><th>调压调速</th><th>转子串电阻调速</th></tr></thead><tbody><tr><td>要求</td><td>$\frac{U_1}f=\text{const}$</td><td>$U_1=\text{const}$</td><td></td><td></td></tr><tr><td>参数</td><td>$T_{m}\approx \text{const}~,~s_m↑$</td><td>$P_2\approx\text{const}~,~T_m↓~,~s_m↑$</td><td>$s_m=\text{const}~,~T_m↓$</td><td>$s_m↑~,~T_m=\text{const}$</td></tr><tr><td>曲线</td><td>整体向下平移</td><td>往左上方缩以保持$P_2$不变</td><td>整体往左边压缩</td><td>特性变软，曲率往下掉</td></tr><tr><td>特点</td><td>适用于恒转矩负载</td><td>适用于恒功率负载</td><td>对恒$T,P$负载调速范围小$(0,s_m)$<br />适用于通风机负载$(T_Z=kn^2)$</td><td>一般用于恒转矩负载</td></tr><tr><td>求解</td><td>$f=\frac{np}{60}$<br />平移→$\Delta n$不变</td><td></td><td>$T_m$与$U^2$成正比，故<br />$U’=\sqrt{\frac{T_m’}{T_m}}U_N$</td><td>$\frac{r<em>2}s=\frac{r_2+R</em>{\Omega}}{s’}$<br />因$s$与$s_m$成正比，可换成$s_m$和$s_m’$</td></tr></tbody></table></div><p>在解题的时候，多使用经验公式（适用于同一条曲线上的两点）：</p><script type="math/tex; mode=display">\frac{T_{em}}{T_m}=\frac{2K_M}{\frac s{s_m}+\frac{s_m}s}\approx\frac{2K_M}{s_m}\cdot s ~;~\frac{T_a}{T_b}=\frac{s_a}{s_b}</script><p><img src="\image\电机学18.png" alt=""></p><h2 id="制动-1"><a href="#制动-1" class="headerlink" title="制动"></a>制动</h2><table style="text-align: center;">    <tr>        <th rowspan=2> 分类 </th> <th colspan=2> 回馈制动(s<0) </th><th rowspan=2>能耗制动</th><th colspan=2>反接制动(s>1)</th>    </tr>    <tr>        <th>反转向(IV)</th><th>发电机制动(II)</th><th>正接反转(IV)</th><th>正转反接(II)</th>    </tr>    <tr>        <th>实现</th><td>定子电源反相序，并反向起动</td><td>电车下坡冲过n1，或变频/变极降低n1</td><td>定子脱网通直流励磁，使产生静止磁场</td><td>转子回路串大电阻</td><td>定子电源反相序（需限流电阻）</td>    </tr>    <tr>        <th>特点</th><td>n>n1（同向），适用于位能型负载高速下放</td><td>n>n1（同向），常见于电车下坡或变频变极调速</td><td>快速停机或位能负载低速下放</td><td>Tm大小不变，机械特性极度变软。适用于位能型负载</td><td>Tm大小不变，机械特性与原点对称后变软</td>    </tr>    <tr>        <th>能量关系</th><td colspan=2>电磁功率反向，向电网发出有功，吸收无功来建立磁场</td><td>转子动能转化成电能全部消耗于转子电阻中</td><td colspan=2>转子处于能量双馈状态</td>    </tr>    <tr>        <th>例题</th><td>无</td><td>无</td><td>无</td><td>定负载下，下放转速与串接电阻的关系</td><td>初始时刻制动转矩与串接电阻的关系</td>    </tr>    <tr>        <th>计算方法</th><td>无</td><td>无</td><td>无</td><td>先算S和Sm，带入串电阻调速的公式</td><td>先算S'(≈2)，带T和S的经验公式，有2解</td>    </tr></table><p><img src="\image\电机学19.png" alt=""></p><h1 id="同步电机"><a href="#同步电机" class="headerlink" title="同步电机"></a>同步电机</h1><h2 id="结构与运行原理"><a href="#结构与运行原理" class="headerlink" title="结构与运行原理"></a>结构与运行原理</h2><h3 id="同步电机结构"><a href="#同步电机结构" class="headerlink" title="同步电机结构"></a>同步电机结构</h3><p>​        同步电机与直流电机正好相反，定子是电枢，转子是励磁，具有较高且可调的功率因数，也可以发出无功。定转子二者产生的磁场相对静止（均以同步速$n=\frac{60f}p$旋转），并且保证气隙合成磁场恒定（这也是机电能量转换的必要条件）。两磁场之间的相位差决定了电磁转矩$T_{em}$的方向，由此决定的电机的运行状态：</p><script type="math/tex; mode=display">\begin{gather*}\begin{cases}定子：&旋转磁场（电枢磁场）&相位超前时~T_{em}>0&电动机\\转子：&直流励磁（主极、机械磁场）&相位超前时~T_{em}<0&发电机\\&&注：空载时~T_{em}=0&调相机  \end{cases}\end{gather*}</script><p>​        同步电机主要用作发电机（与异步电机主要用作电动机相反），其分类如下：</p><script type="math/tex; mode=display">\begin{gather*}\begin{cases}隐极式：&汽轮发电机&转子大小齿结构，约\frac23开槽&适合高速旋转\\凸极式：&水轮发电机&有可辅助起动抑制震荡的阻尼绕组&低转速 \end{cases} \end{gather*}</script><h3 id="电枢反应-1"><a href="#电枢反应-1" class="headerlink" title="电枢反应"></a>电枢反应</h3><p>​        在空载运行时，同步电机的电动势就是$E_0=-\omega \frac{\text d\phi}{\text dt}=\sqrt2\pi fNk\phi_0$，是一个大小仅与励磁电流$I_f$挂钩、<strong>相位滞后$\phi_0$90°</strong>的量，其特性曲线也就是磁化曲线。与直流电机类似，电枢反应的意思就是接入负载后，电枢产生的磁场影响空载磁场，将气隙合成磁场改变。</p><p>​        电枢反应仍然可以被分解为交轴和直轴。交轴分量产生电磁转矩，直轴分量引起去磁或增磁（一般而言是前者）。下方图片中几个物理量的关系是：$F_{f1}$与$\phi_0$基本近似为同向，$E_0$落后90°，定子电流$I$落后$E_0$内功率因数角$\psi$，定子磁场$F_a$与$I$同向。</p><p><img src="\image\电机学24.png" alt=""></p><p>​        为了下面两小节理解方便，这里定义四个角度：</p><script type="math/tex; mode=display">\begin{gather*}\begin{cases}内功率因数角：&\psi=(\dot E_0\wedge\dot I)&\psi=\varphi+\theta\\功率因数角：&\varphi=(\dot U\wedge\dot I)\\功率角（功角）：&\theta=(\dot E_0\wedge\dot U)\\内功率角：&\theta_i=(\dot E_0\wedge\dot E_{\delta})  \end{cases} \end{gather*}</script><h3 id="隐极与凸极的负载运行"><a href="#隐极与凸极的负载运行" class="headerlink" title="隐极与凸极的负载运行"></a>隐极与凸极的负载运行</h3><p>​        根据做题感受，同步电机的等效电路图是“最不重要”的，更重要的是矢量图。因为涉及到大量的角度，需要画矢量图，用几何的方法图解电动势的关系。</p><div class="table-container"><table><thead><tr><th></th><th>隐极</th><th>凸极</th></tr></thead><tbody><tr><td><strong>矢量图</strong></td><td><img src="\image\电机学25.png" alt=""></td><td><img src="\image\电机学27.png" alt=""></td></tr><tr><td><strong>等效电路</strong></td><td><img src="\image\电机学26.png" alt=""></td><td><img src="\image\电机学28.jpg" alt=""></td></tr><tr><td><strong>特点</strong></td><td>用两个电抗来等效电枢反映压降$\dot E<em>a$和漏抗压降$\dot E</em>{\sigma}$，同步电抗$X<em>t=X_a+X</em>{\sigma}$同时反应了电枢反应和漏磁通的影响</td><td>将$\dot F<em>a$分解为$\dot F</em>{ad}+\dot F<em>{aq}$，分别用$X</em>{ad}&gt;X<em>{aq}$和$\dot I_d,\dot I_q$反映。并把漏抗$X</em>{\sigma}$分到交直轴同步电抗中去</td></tr><tr><td><strong>饱和影响</strong></td><td>此时不能把$E<em>a/E_0$从$E</em>{\delta}$中区分出来<br />故$\dot E<em>{\delta}=\dot U+\dot I(R_a+jX</em>{\sigma})$</td><td>交轴气隙较大，认为不受饱和影响<br />改变$\dot E<em>d$，有$\dot E_d+\dot E</em>{aq}=\dot E_{\delta}$</td></tr><tr><td><strong>注</strong></td><td>计算中$F_a$是正弦波<br />空载特性中$F_a$是方波</td><td>$\dot E_Q$与$\dot E_0$同向，先算$\dot E_Q$<br />$E_Q=E_0-I_d(X_d-X_q)$</td></tr></tbody></table></div><h3 id="工作特性-2"><a href="#工作特性-2" class="headerlink" title="工作特性"></a>工作特性</h3><p><strong>短路特性</strong></p><p>​        在短路时，电压比较小因此磁化曲线一定不饱和，故满足$E_0\propto I_f$且$I_k=\frac{E_0}{X_t}$，故$I_k\propto I_f$，因此短路特性呈一条直线。同时观察短路特性和空载特性，可以得到短路比定义和公式如下：</p><script type="math/tex; mode=display">K_c=\frac{I_{k0}(I_{f0}\rightarrow U_N)}{I_N}=\frac{I_{f0}(U=U_N)}{I_{fk}(I_k=I_N)}=K_{\mu}\frac1{X_d^*}~;~(K_{\mu}>1,是饱和系数)</script><p><strong>零功率因数负载特性</strong></p><p>​        类似于<a href="#ee">直流发电机的负载特性</a>，为了克服直轴去磁磁动势和漏抗压降，往右下方偏移了一部分。</p><p><strong>外特性与调整特性</strong></p><p>​        一般而言电机是感性的，因此即使外电路接纯电阻负载，随着电流的增大，端电压也会减小。接感性负载时端电压下降更加厉害，接容性负载可以抑制端电压的下降，甚至使之上升。</p><h2 id="同步电机的并网运行"><a href="#同步电机的并网运行" class="headerlink" title="同步电机的并网运行"></a>同步电机的并网运行</h2><p>​        同步电机并网之后，电机的输出端电压将会与电网电压完全一致，也就是发电机电压的相序、波形、频率、大小和相位与电网必须保持一致。</p><h3 id="并网连接——三相灯指示"><a href="#并网连接——三相灯指示" class="headerlink" title="并网连接——三相灯指示"></a>并网连接——三相灯指示</h3><div class="table-container"><table><thead><tr><th></th><th>暗灯法（直连）</th><th>旋灯法</th><th>调节方法</th></tr></thead><tbody><tr><td><strong>等频率</strong></td><td>三盏灯明度不再变化</td><td>灯光不再旋转闪烁（或旋转很慢）</td><td>调节发电机转速n</td></tr><tr><td><strong>等电压（大小+相位）</strong></td><td>三盏灯同时熄灭</td><td>灯光1熄灭，2/3亮度相同</td><td>调节发电机电压大小<br />发电机瞬时速度（相位）</td></tr></tbody></table></div><ul><li><strong>自同步法：</strong>励磁绕组不通电接限流电阻，，用原动机拖动直至接近同步转速，先并网然后迅速接通励磁（不要限流电阻）</li></ul><h3 id="平衡方程与功角特性"><a href="#平衡方程与功角特性" class="headerlink" title="平衡方程与功角特性"></a>平衡方程与功角特性</h3><p><img src="\image\电机学29.jpg" alt=""></p><ul><li>电磁功率的表达式如下：</li></ul><script type="math/tex; mode=display">\begin{gather*} P_{em}=P_2(mUI\text{cos}\varphi)+p_{cu2}(mI^2R_a\approx0)\Rightarrow P_{em}\approx P_2\\P_{em}=\frac{mE_0U}{X_d}\text{sin}\theta+\frac{mU^2}2(\frac1{X_q}-\frac1{X_d})\text{sin}2\theta\\P_{em}=mE_0I_q  \end{gather*}</script><h4 id="有功调节与静态稳定"><a href="#有功调节与静态稳定" class="headerlink" title="有功调节与静态稳定"></a>有功调节与静态稳定</h4><p>​        从上文的表达式可以看出来，在<strong>并网之后有功功率仅与空载电动势$E_0$和功率角$\theta$有关</strong>。这就是所谓的“功角特性”——有功功率的大小与功率角紧密关联，而功率角反映的就是交轴电枢反应的影响，是转子主极轴线与气隙合成磁场轴线之间的相差。</p><ul><li><p><strong>自跟随：</strong>为了增加有功，需调大输入功率（力矩），转子瞬间加速使励磁电动势$\dot E<em>0$超前电网电压$\dot U$，增大功率角$\theta$，因此$I_q$增加、电磁制动转矩$T</em>{em}$增加，重新稳定。</p></li><li><p><strong>静态稳定：</strong>由于$P_{em}\propto \text{sin}\theta$，随着功率角的增大输出功率先增加后减小。<strong>只有在$\theta\in[0,90°]$的范围内才能稳定。</strong></p></li><li><p><strong>Def：</strong></p><ul><li>比整步功率$P<em>{syn}=\frac{\text dP</em>{em}}{\text d\theta}=\frac{mE_0U}{X_d}\text{cos}\theta$</li><li>过载能力$K<em>m=\frac{P</em>{max}}{P_N}=\frac1{\text{sin}\theta_N}$</li></ul></li></ul><h4 id="无功调节与V型曲线"><a href="#无功调节与V型曲线" class="headerlink" title="无功调节与V型曲线"></a>无功调节与V型曲线</h4><p>​        在调节无功功率时，需要保持有功功率不变，即$E<em>0\text{sin}\theta=\text{const}$，$I_q=I\text{cos}\varphi=\text{const}$。认为$\text{cos}\varphi=1$，即$I=I</em>{min}$时的状态叫做“正常励磁”，此时不输出无功。</p><ul><li><strong>恒磁通：</strong><ul><li>并网时$U=\text{const}$，因此$E_{\delta}\approx U=\text{const}$，因此气隙合成磁通不会变化</li></ul></li><li><strong>自跟随：</strong><ul><li>当励磁增加，励磁磁动势增加时，电枢反应输出滞后的电流（感性无功），使之去磁</li><li>当励磁减小，励磁磁动势降低时，电枢反应输出超前的电流（容性无功），使之增磁<ul><li>欠励的励磁电流不能过小，否则功角将超过90°进入不稳定区，电枢电流的增磁效应不足以补偿主磁通，产生不了足够的电磁转矩拖住转子，电机失步。</li></ul></li></ul></li></ul><p><img src="\image\电机学30.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电机工程创新实践（短学期）</title>
      <link href="/2026/02/24/%E7%94%B5%E6%9C%BA%E5%B7%A5%E7%A8%8B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5/"/>
      <url>/2026/02/24/%E7%94%B5%E6%9C%BA%E5%B7%A5%E7%A8%8B%E5%88%9B%E6%96%B0%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="电机工程创新实践"><a href="#电机工程创新实践" class="headerlink" title="电机工程创新实践"></a>电机工程创新实践</h1><ul><li>这门课本来应该是在寒假一起修的短学期课程，但是hxy老师把它放到冬学期上了。一周一节，一共四节课左右，剩下的时间自己做大作业。但奈何本人最近一直在实习….</li><li>这门课的要求是设计一个小型电机，体验一下设计流程。不过<strong>真正在工程实践中电机的设计流程并不如此</strong>（以至于黄老师自己都不会用ANSYS），本人也没有进行什么优化，反正看上去还行。本篇文章走一下hxy老师的设计流程。</li><li>课不用怎么听，基本靠自学</li><li><strong>本人不会设计电机</strong></li></ul><h2 id="1-基本电机参数设计"><a href="#1-基本电机参数设计" class="headerlink" title="1. 基本电机参数设计"></a>1. 基本电机参数设计</h2><p>​    这块跟大三下学期学的电机设计区别不太大，不过不需要搞得那么复杂，只需要设计几个基本的参数就行了。黄老师的PPT里有流程示范，基本跟着她那个走就行（顺带一提，黄老师基本不看钉钉但是微信秒回，所以催她发文件最好微信）</p><h3 id="1-1-主要尺寸关系式"><a href="#1-1-主要尺寸关系式" class="headerlink" title="1.1 主要尺寸关系式"></a>1.1 主要尺寸关系式</h3><p>先根据设计要求，找到电机的转矩、转速、电压要求。</p><p>根据电机基本尺寸关系式（分子6.1那个，详见电机设计）计算电枢外径$D_0$。其中：</p><ul><li>A可以取值在15~50 × 10^3^ A/m</li><li>$B_{\delta}$可以取值在0.6~0.8 T</li><li>$\alpha_p$可以取值在0.7左右</li><li>$K<em>{nm}$取值在1.1，$K</em>{dp}$取值在0.92或0.96</li><li>尺寸比$\lambda$可以取得很小（因为我设计的是机器人关节电机，所以取的0.1左右，D比l大很多）</li></ul><p>​    然后确定内转子还是外转子。黄老师设计的是外转子，我是内转子。内转子可以参考电机设计这本书的例程，定子内径（即约为转子外径）大概就是外径的0.6~0.8，反正这个要求不是特别大，最终大概设计出来定子轭部跟定子齿的宽度差不多就行（轭部可以细一点）</p><p>​    这里我的参数大概是80,50（仅供参考）。转子内径要求不大，给转子轭部稍微留点空间。一般设计个30以上吧，这个对电机性能影响很小，尽量让转子轭部薄一点。</p><h3 id="1-2-槽极配合"><a href="#1-2-槽极配合" class="headerlink" title="1.2 槽极配合"></a>1.2 槽极配合</h3><p>​    hxy老师的PPT上有两个表格，分别是不同槽极配合下的绕组系数和谐波与噪声（这两个表横纵坐标反了别看岔），谐波选数字稍微大一点（意思就是谐波小），绕组系数大一些。一般都是分数槽集中绕组，一些比较经典的设计比如12s10p，12s9p等等，对这些槽极配合等比例放大（比如我用的24s20p）也是个不错的选择。我看有人说24s20p的波形没有特别好，他用的好像有三十多极，具体我有点记不清了。反正这么大的电机，极数二三十差不多了，电机越大可以把极对数增大。</p><h3 id="1-3-材料选型"><a href="#1-3-材料选型" class="headerlink" title="1.3 材料选型"></a>1.3 材料选型</h3><p>​    我是不会一点，老师选啥我选啥，抄PPT的</p><h3 id="1-4-槽型设计"><a href="#1-4-槽型设计" class="headerlink" title="1.4 槽型设计"></a>1.4 槽型设计</h3><p>​    我是不会一点，《电机设计》选啥我选啥。把他在第十章设计的槽等比缩放一下（按照电枢直径）就是我的槽了！（免责声明：吴立建上课也是这么说的）</p><p>好的，现在你就非常粗略的设计完电机了（没事，没设计的部分ANSYS会帮你设计的）</p><h2 id="2-RMxprt-建模"><a href="#2-RMxprt-建模" class="headerlink" title="2. RMxprt 建模"></a>2. RMxprt 建模</h2><p>给一个参考链接，可以跟着他做一下建模，数据用自己的就好：<a href="https://www.bilibili.com/video/BV1cN411r7Wu">https://www.bilibili.com/video/BV1cN411r7Wu</a></p><p><img src="\image\hxy1.png" alt=""></p><ul><li>推荐用参数化建模，如左下角红线所示，这样之后做参数扫描比较方便。</li><li>如果一些必填的参数你不知道怎么取，可以参考黄老师PPT中的取法（但也不一定对），这里给点参考：永磁体厚度可以在2mm左右，气隙可以在1mm左右（黄老师取的2mm太大了）</li><li><p>windings的参数设计慎填，因为你可能会设计的一坨屎（没错我一开始就是这样），把必要的几个填一下，比如并联支路数是1还是2，剩下的丢给他自己设计吧，比如匝数、线径啥的。不合适后面再改。</p></li><li><p><strong>黄老师会发一个电机设计报告的word模板，如果第三四节课后还没发，记得找她要。</strong>对着那个报告做会轻松很多。做完上面这几步，你已经可以填写<strong>表1.1和表1.2</strong>了。</p></li></ul><h2 id="3-Maxwell-建模与仿真"><a href="#3-Maxwell-建模与仿真" class="headerlink" title="3. Maxwell 建模与仿真"></a>3. Maxwell 建模与仿真</h2><p>​    使用setup创建Maxwell2D模型，绝大部分仿真都需要在Maxwell里面跑，<strong>原因是RMxprt里面的仿真只能是 <code>Constant Power</code>，但是我们需要的是用电流源来进行仿真</strong>。</p><p>不要立刻进行仿真。</p><h3 id="3-1-磁场：磁密云图、磁力线分布与气隙磁密"><a href="#3-1-磁场：磁密云图、磁力线分布与气隙磁密" class="headerlink" title="3.1 磁场：磁密云图、磁力线分布与气隙磁密"></a>3.1 磁场：磁密云图、磁力线分布与气隙磁密</h3><p>​    ctrl+A 全选，右键选择<code>plot mesh</code>进行剖分，在左侧的Field Overlays里面可以看到剖分图。如果剖分没有出来的话，双击一下电机模型的左下角，有一个Time=0的东西，双击完成就能看到了。然后分别进行A和B的调用。</p><p><img src="\image\hxy4.png" alt=""></p><p><img src="\image\hxy9.png" alt=""></p><p>如下图所示，画一条气隙线，原点在电机圆心，半径刚好穿过气隙。画完后只用保留线，把<code>coverlines</code>删了</p><p><img src="\image\hxy3.png" alt=""></p><p>​    如下图所示，添加气隙磁密。气隙磁密一共两个，径向$B_r$和切向$B_t$，所以一共添加两次，就是在第二步操作中分别选择切向Target和径向Normal，然后分别命名Bt和Br就行。步骤用蓝色标出。</p><p><img src="\image\hxy5.png" alt=""></p><p>​    接着进行仿真设置，右键setup1选择properties进行设置，为了少跑几个周期，可以减小一点总时间。时间设多少随你，大概三个周期就够。上面那个100可以减小点，20,50啥的都行，具体含义自己看英文。</p><p><img src="\image\hxy2.png" alt=""></p><p>​    在仿真之前，非常重要的一部是如下图所示进行设置，从电压源改成电流源。<strong>具体数值要根据设计的电机参数进行更改</strong>。BC相减/加三分之二π就行。一开始I0设置成0模拟空载，n设置成额定转速。</p><p><img src="\image\hxy8.png" alt=""></p><p>开始仿真！</p><p>​    为了查看气隙磁密，分别进行下面两步操作。其中第二张图的7200是取点的数量，越多越慢，我感觉1440之后区别不大了，尽量设成个360的倍数就行。查看气隙磁密并填入<strong>图4.3</strong>中。</p><p><img src="\image\hxy6.png" alt=""></p><p><img src="\image\hxy7.png" alt=""></p><p>在左侧的Field Overlays里面可以看到磁密云图、磁力线分布，填入<strong>图4.1，4.2</strong>中。右键Result选择FFT，如下</p><p><img src="\image\hxy10.png" alt=""></p><p>最后怎么处理的数据自己去查。</p><h3 id="3-2-电场：感应电势与电流"><a href="#3-2-电场：感应电势与电流" class="headerlink" title="3.2 电场：感应电势与电流"></a>3.2 电场：感应电势与电流</h3><p>​    齿槽转矩就是输入电流为0时的点击转矩，可以直接看自带的Torque曲线就行了</p><p>​    感应电压曲线也是。由于本实验要求输入电压最低30V，因此感应电动势<strong>不能超过这个数值</strong>，否则需要额外的控制。如果超过了，则需要减少线圈匝数cond，其可以在左下角的variable里面找到。此外，如果这个比较<strong>不正弦</strong>的话可能需要调整一下其它参数。如果需要减少匝数的话，那就需要增加绕线截面积了（为了确保电流一样）。为了应付教学，可以直接把原来的线径按比例放大（平方关系），但实际中涉及到选型是不能这么做的。</p><p>​    磁链、电感和电阻也是一样的，自己去调一下Result里面的数据（低情商：我也是猜的）</p><p>​    至于怎么调曲线：Result - Create Transient Report - Create Rectangular Report</p><h3 id="3-3-负载特性"><a href="#3-3-负载特性" class="headerlink" title="3.3 负载特性"></a>3.3 负载特性</h3><p>首先先进行参数扫描，如下</p><p><img src="\image\hxy11.png" alt=""></p><p><img src="\image\hxy12.png" alt=""></p><p>​    对新得到的ParameterSetup1进行分析Analyze，由于扫的点数很多，所以可能耗时很久。然后如下图所示进行转矩-电流曲线的扫描。需要注意的是，如果之前更改过cond（匝数），那么他在仿真的时候会把两种cond都仿真一次，所以可以在families里面把cond换成你需要的那个，而不是all</p><p><img src="\image\hxy13.png" alt=""></p><p>​    其他的转矩波形、感应电动势直接调出来就行。需要注意的是要手动把电流设置成额定电流（额定电流从上面的转矩-电流曲线中读出），具体操作方法为：</p><p>​    右键Result中相应的图表 - Modify - Families - 电流改成额定电流</p><p>​    接着，用转矩-电流曲线同样的方法，找到交直轴电感Ld，Lq（记得用Average值）与电流的关系</p><p>​    左下角Variable把输入电流改成额定电流，跑一遍Setup1，再去看电机磁密云图</p><p>​    正常情况下，Maxwell仿真是不包含涡流损耗和永磁损耗的，要主动选择。步骤如下，选择Core loss和Eddy Current loss之后把所有的都勾上。</p><p><img src="\image\hxy14.png" alt=""></p><p>​    不同转速、电流下的数据点下，电机的效率MAP图跟上面的扫描也是类似的，设置类似如下（记得把仿真的间隔调一下，不然得跑很久很久）</p><p><img src="\image\hxy15.png" alt=""></p><h3 id="3-4-过载"><a href="#3-4-过载" class="headerlink" title="3.4 过载"></a>3.4 过载</h3><p>把电机电密调到50，你看下原来的电密，应该会是50的三分之一到二分之一，把电流等比放大就行。然后跑一次。</p><p>电流就是正常的电流</p><p>磁密云图也不用管温度要求了，就是之前的磁密云图</p><p>这个是什么意思呢，就是如果退磁严重的话，需要你把永磁体厚度增厚，也就是说前面重来一遍喵。</p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大四 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电机控制</title>
      <link href="/2026/02/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/"/>
      <url>/2026/02/24/%E7%94%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>PDF看这个：<a href="\myfile\电机控制笔记.pdf" target="_blank">电机控制笔记PDF版本</a></p><h1 id="直流电机的控制"><a href="#直流电机的控制" class="headerlink" title="直流电机的控制"></a>直流电机的控制</h1><h2 id="晶闸管与双闭环调速"><a href="#晶闸管与双闭环调速" class="headerlink" title="晶闸管与双闭环调速"></a>晶闸管与双闭环调速</h2><p><img src="/image/djkz01.png" alt=""></p><ol><li><p><strong>PI调节器的作用：</strong></p><ol><li>速度调节器 ST： <ol><li>调速精度，做到静态无差；使机械特性硬，满足负载要求； </li><li>实现转速快速调节。 </li></ol></li><li>电流调节器 LT：<ol><li>精确满足负载转矩大小要求； </li><li>调速的快速动态特性(转矩的快速响应)。</li></ol></li></ol></li><li><p><strong>电流环在内的原因：</strong> </p><ol><li>时间常数小，响应更快</li><li>引入电流环是为了控制电枢电流</li><li>电流仅与负载转矩有关</li></ol></li><li><p><strong>PI参数的影响：</strong></p><ol><li><p>Kp增大，提高系统动态性能；反之削弱 </p></li><li><p>Ki增大，静态误差减少，但系统容易震荡；   </p><p>Ki减小，积分太弱，稳态误差难以快速减小 </p></li><li><p>Kd过大或过小，增加系统超调和调节时间</p></li></ol></li></ol><p><img src="/image/djkz02.png" alt=""></p><ol><li><p><strong>起动过程特征：</strong></p><ol><li><p><strong>起动：</strong>$i<em>d$ 由 0 上升到 $I</em>{d \,max}$（限幅值）； </p><p>ST、LT 全部饱和限幅，蜕化为限幅器，系统实为速度、电流双开环；</p></li><li><p><strong>加速：</strong>$i<em>d=I</em>{d \,max}$ 恒定（电流调节结果，非限幅）； </p><p>ST 饱和限幅，LT 作 PI 调节，实为电流单闭环系统</p></li><li><p><strong>PI 调节至稳态:</strong> 转速稳定至 $n=n_g$，电流稳定至 $i_d=I_L$（对应 $T_L$）； </p><p>ST、LT 均作 PI 调节，真正速度、电流双闭环工作。</p></li></ol></li></ol><h2 id="PWM调速"><a href="#PWM调速" class="headerlink" title="PWM调速"></a>PWM调速</h2><div class="table-container"><table><thead><tr><th><img src="/image/djkz03.png" alt=""></th><th><img src="/image/djkz05.png" alt=""></th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th></th><th>单极性</th><th>双极性</th></tr></thead><tbody><tr><td>工作<br />方式</td><td>1. VT3关断，VT4导通<br />2. VT1 和 VT2 轮流导通<br />3. 控制电压为负时，13对调，24对调</td><td>1. VT1 和 VT4 同极性<br />2. VT2 和 VT3 同极性<br />3. 两组极性（通断）互补</td></tr><tr><td>负载电压系数</td><td>$\rho=D$</td><td>$\rho=2D-1$</td></tr><tr><td>工作<br />流程</td><td>1. VT1 通，电动运行<br />2. VD2 蓄流，电动运行<br />3. VT2 和 VD4 导通，能耗制动<br />4. VD1 和 VD4 蓄流，再生制动</td><td>1. VT1 和 VT4 导通，电动运行<br />2. VD2 和 VD3 蓄流，电动运行<br />3. VT3 和 VT2 导通，反接制动<br />4. VD4 和 VD1 蓄流，再生制动</td></tr></tbody></table></div><p><img src="/image/djkz04.jpg" alt=""></p><h1 id="异步电机的控制"><a href="#异步电机的控制" class="headerlink" title="异步电机的控制"></a>异步电机的控制</h1><p>调速主经常使用“转差功率不变型”调速方式，即保证 s （$P_s$）不变。如异步电机的变频调速和变极调速均属于这类方式。</p><p>还有“转差功率消耗型”调速方式，通过消耗转差功率 $P_{s}=sP_e$ 来换取转速的下降，如调压调速，串电阻调速。</p><h2 id="变转差调速"><a href="#变转差调速" class="headerlink" title="变转差调速"></a>变转差调速</h2><p><strong>调压调速</strong></p><p><img src="/image/djkz06.jpg" alt=""></p><ul><li>电机电磁转矩：$T_e\propto U^2$</li><li>缺点：调速范围较小（$s\in(0,s<em>m)$）。只能降压调速，且$\phi_m=\frac{U_1}{4.44K</em>{dp}f_1N}$，属于弱磁调速。依靠增大转差频率 s 调速，转子回路消耗的滑差功率增大，机械输出功率减小。</li></ul><p><strong>串级调速</strong></p><p>串级调速是指在转子中引入与转子同频（$sf_1$）的转子电势，以吸收或补充滑差功率，从而进行调速。详见第三章。</p><h2 id="变频调速"><a href="#变频调速" class="headerlink" title="变频调速"></a>变频调速</h2><h3 id="变频调速的理论基础"><a href="#变频调速的理论基础" class="headerlink" title="变频调速的理论基础"></a>变频调速的理论基础</h3><h4 id="基本实现方法"><a href="#基本实现方法" class="headerlink" title="基本实现方法"></a>基本实现方法</h4><p><img src="/image/djkz07.png" alt=""></p><script type="math/tex; mode=display">T_m\propto\frac{U_1^2}{\omega_1}</script><div class="table-container"><table><thead><tr><th></th><th>基频下调</th><th>基频上调</th></tr></thead><tbody><tr><td>要求</td><td>保持气隙磁通 $\phi_m$ 恒定→磁路工作点不变<br />变频中维持 $E_1/f_1$ 为定值<br />适合恒转矩负载</td><td>定子电压 $U<em>1=U</em>{1N}$ <br />属于弱磁调速，适合恒功率负载</td></tr><tr><td>机械特性</td><td><img src="/image/djkz08.png" alt=""></td><td><img src="/image/djkz10.jpg" alt=""></td></tr><tr><td></td><td>$\Delta n$ 不变，s-T向下平移<br />考虑阻感压降，$T_m\propto f$ 下降</td><td>$\Delta n$ 变大，机械特性变软<br />气隙磁通↓ → 电磁转矩↓</td></tr></tbody></table></div><p><strong>基频以下电压补偿控制</strong></p><p><img src="/image/djkz09.jpg" alt=""></p><div class="table-container"><table><thead><tr><th></th><th>恒气隙电势频比 $E_1/f_1$</th><th>恒电压频比 $U_1/f_1$</th><th>恒转子磁通（转子电势） $E_r/f_1$</th></tr></thead><tbody><tr><td>特点</td><td>气隙磁通 $\phi<em>m$ 恒定<br />需要补偿定子阻抗上的压降<br />n-T 曲线纯向下平移<br />低频下 $T</em>{st}$ 大，$I_{st}$ 小<br />临界转差、转矩更硬，机械特性好</td><td>类似前一个，但控制更方便<br />最大转矩 $T_{st}$ 随频率降低而减小</td><td>机械特性 n-T 为直线<br />不同同步速下，为一簇平行线<br />工作特性好，由高性能电机实现</td></tr></tbody></table></div><h4 id="非正弦供电的影响"><a href="#非正弦供电的影响" class="headerlink" title="非正弦供电的影响"></a>非正弦供电的影响</h4><ol><li><p><strong>磁路工作点改变</strong></p><p>高次谐波使气隙磁密幅值增加（$B=B_1+B_5+B_7+\dots&gt;B_1$），功率因数 $\cos\varphi$ 下降，磁路计算和空载试验等需要<strong>提高设计电压</strong></p></li><li><p><strong>定子漏抗减小</strong></p><p>谐波电流使槽电流增大，槽磁漏增加，饱和程度提高 → 定子漏抗 $X_{\sigma1}$ 减小</p></li><li><p><strong>转子集肤效应</strong></p><p>高次谐波转差率 $s_k\approx1$，频率较高，集肤效应强 → <strong>转子电阻增大，转子槽漏抗减小</strong>（等效磁链减小） → 增加转子谐波损耗</p></li><li><p><strong>功率因数下降</strong></p><p>电流有效值增大，气隙磁密增大 → 磁路饱和程度提高，无功励磁电流增加 → 功率因数明显下降</p></li><li><p><strong>损耗与效率</strong></p><p>异步电动机损耗增大，效率下降。主要影响来自于转子谐波损耗，与负载关系不大。</p></li><li><p><strong>谐波转矩的影响</strong></p><ol><li><strong>恒定谐波转矩：</strong>谐波磁场转差率 $s_k\approx1$，内功率因数角 $\psi’=\text{atg}\frac{s_kk\omega_1L_2’}{R_2’}$ 较小，基本都是无功电流 → 同次电流产生较小的异步转矩（可忽略）</li><li><strong>脉动谐波转矩：</strong>不同次数的谐波磁场与基波磁场相互作用，产生高频交变的脉动转矩，平均值为0但幅值较大（如5次负序电流和7次正序电流都会产生6倍基频的脉动转矩）</li></ol></li><li><p><strong>电应力</strong></p><p>高瞬间电压变化梯度 $\frac{\text dv}{\text dt}$ → 浪涌电压尖峰 → 各线圈间电压按分布电容分配 → 约40%电压加在第一个线圈上，易绝缘老化</p></li><li><p><strong>轴电流</strong></p><p>零序电压 $\frac{U_A+U_B+U_C}3\ne0$，产生流过轴承的电流（高频 → 阻抗小 → 电流大）</p><p>可以采用增大气隙、绝缘轴承（即增大阻抗）、经隔离变压器接地等方式消除</p></li></ol><ul><li>电压源型非正弦电源输出，选漏抗大的电机（限制谐波电流）</li><li>电流源型非正弦电源输出，选漏抗小的电机（限制谐波电压）</li></ul><h3 id="静止变频器"><a href="#静止变频器" class="headerlink" title="静止变频器"></a>静止变频器</h3><p>可以看看这个：<a href="https://zju-paradox.top/2024/04/18/电力电子技术/#dc-ac-变换逆变">电力电子技术 | Paradox’s Website (zju-paradox.top)</a></p><h3 id="变频调速实现方法"><a href="#变频调速实现方法" class="headerlink" title="变频调速实现方法"></a>变频调速实现方法</h3><h4 id="正弦脉宽调制-SPWM"><a href="#正弦脉宽调制-SPWM" class="headerlink" title="正弦脉宽调制 SPWM"></a>正弦脉宽调制 SPWM</h4><p><img src="/image/djkz15.jpg" alt=""></p><div class="table-container"><table><thead><tr><th>单极性控制</th><th>双极性控制</th><th>载波比N</th></tr></thead><tbody><tr><td><img src="/image/djkz12.png" alt=""></td><td><img src="/image/djkz14.jpg" alt=""></td><td><img src="/image/djkz13.png" alt=""></td></tr></tbody></table></div><ul><li>具体实现方法：<ol><li>自然采样法：通过一组三相对称的正弦参考信号（调制波）与等腰三角电压信号（载波）进行比较，由交点处控制通断</li><li>制定谐波消去法：解方程</li></ol></li><li>双极性控制：<ol><li>PWM 是 $\pm\frac{U_d}2$ ，得到输出电压 $u_R=(2D-1)\frac{U_d}2$</li><li>线电压 $U_{AB}=U_A-U_B$，由 $\pm U_d,0$ 三种电压选择</li></ol></li><li>电压控制：<ol><li>三角波频率（载波频率）→ 开关频率，越高性能越好</li><li>正弦波频率、幅值 → 输出正弦波频率、幅值</li></ol></li><li>载波比 $N=f_T/f_R$：<ul><li>最好选择 N 为 3 的倍数，这样能保证输出波形<strong>正负半波对称</strong>，且<strong>三相波形互差120°对称</strong></li></ul></li><li>开关死区的影响：<ol><li>由于开关死区，会存在上下两管均关断的情况，因此输出电压幅值下降。平均偏差电压 $U_{ef}=\frac{t_dU_dN}T$</li><li>变频器输出频率越低，死区影响越严重。</li><li>功率因数越大，电压电流同向越久，死区影响越严重。</li></ol></li></ul><h4 id="电流跟踪控制"><a href="#电流跟踪控制" class="headerlink" title="电流跟踪控制"></a>电流跟踪控制</h4><p><img src="/image/djkz16.png" alt=""></p><p>实际上就是一个很简单的滞环控制，以输出接近正弦的定子三相电流为目的。优点是简单，缺点是难以进行频域分析（PWM无规律，不确定）</p><h4 id="磁链跟踪控制-SVPWM"><a href="#磁链跟踪控制-SVPWM" class="headerlink" title="磁链跟踪控制 SVPWM"></a>磁链跟踪控制 SVPWM</h4><h5 id="基本理论"><a href="#基本理论" class="headerlink" title="基本理论"></a>基本理论</h5><p>最终目的是产生圆形的旋转磁场，从而产生恒定的电磁转矩。磁链的改变依靠电压空间矢量作用获得，因此称为电压空间矢量调整 SVPWM。</p><p>可以参考电机建模里的这个：<a href="https://zju-paradox.top/2024/04/02/电机系统建模与分析/#坐标变化基本定义">电机系统建模与分析 | Paradox’s Website (zju-paradox.top)</a>，但是电机建模里面是恒幅值变换，这里是恒功率变换，需要把系数 $\frac23$ 换成 $\sqrt{\frac23}$。</p><script type="math/tex; mode=display">u_s=\sqrt{\frac23}U_m(\cos\omega_1t+\cos(\omega_1t-\frac23\pi)+\cos(\omega_1t+\frac23\pi))=\sqrt{\frac23}U_me^{j\omega_1t}</script><p>电压和磁链的关系式由 $u_s=R_si_s+\text p\psi_s$ 导出，忽略定子电阻的压降，则有：</p><script type="math/tex; mode=display">u_s=\frac{\text d\psi_s}{\text dt}~;~\Delta\psi_s=u_s\cdot\Delta t</script><p>如果电压通过电压源型逆变器供电，那么每相定子电压有 $\pm\frac{U<em>d}2$ 两种状态，分别用 $1,0$ 表示。那么三相定子电压就可以用一组向量 $s</em>{ABC}=(s<em>A,s_B,s_C)$ 表示，一共 $2^3=8$ 种可能。其中 $s</em>{ABC}=(1,1,1)=(0,0,0)$，所表现出的定子电压综合矢量都是 $u_s=0$，剩下6种在空间内均匀分布（间隔60°）。</p><p><img src="/image/djkz17.png" alt=""></p><h5 id="正六边形旋转磁场"><a href="#正六边形旋转磁场" class="headerlink" title="正六边形旋转磁场"></a>正六边形旋转磁场</h5><p>如上图所示，令6个有效电压矢量在一个周期内按顺序工作 $\frac{\pi}3$ 电角度，即 $\Delta t=\frac{\pi}{3\omega_1}$。这样的话磁链就会沿着上图那样的六边形进行旋转，磁链幅值为：</p><script type="math/tex; mode=display">|\psi_s(k)|=|\Delta\psi_s(k)|=\sqrt{\frac23}\frac{\pi}{3\omega_1}U_d</script><p>如“变频调速理论基础”中所说，<strong>基频下调</strong>时需要维持气隙磁通恒定，但是随着频率 $\Omega_1$ 的减小，定子磁链会上升，这时候就要<strong>插入零电压矢量 $u_0$ 或 $u_7$</strong>。有效电压矢量只工作 $\Delta t_1=\frac{\pi}{3\omega_n}&lt;\Delta t$ 的时间，剩下的时间 $\Delta t_0=\Delta t-\Delta t_1$ 用零电压矢量来补。具体用 $u_0$ 还是 $u_7$ 考虑当前电压矢量变到哪个比较方便。</p><script type="math/tex; mode=display">|\psi_s(k)|=|\Delta\psi_s(k)|=|u_s(k)\Delta t_1+0\Delta t_0 |=\sqrt{\frac23}U_d\Delta t_1</script><p>基频以上本来就是弱磁控制，根据公式磁链减小，因此没关系。</p><h5 id="期望电压空间矢量的合成"><a href="#期望电压空间矢量的合成" class="headerlink" title="期望电压空间矢量的合成"></a>期望电压空间矢量的合成</h5><p>通过对空间矢量的细分与组合，可以实现更接近圆形的正多边形。先读取当前定子磁链 $\vec{\psi_s}$，判断所需的定子电压矢量 $\vec{u_s}$。然后根据该电压矢量所处的位置，用临近的两个有效电压矢量和零电压矢量（若需）进行合成如下：</p><p><img src="/image/djkz18.png" alt=""></p><script type="math/tex; mode=display">\vec{u_s}=\frac{t_1}{T_0}\vec{u_1}+\frac{t_2}{T_0}\vec{u_2}+\frac{t_0}{T_0}\vec{u_0}</script><p>其中 $T_0$ 是开关周期，个人感觉应该是“想细分的正多边形边数”$n=\frac T{T_0}=\frac{2\pi}{\omega_1T_0}$</p><h3 id="变频调速系统"><a href="#变频调速系统" class="headerlink" title="变频调速系统"></a>变频调速系统</h3><h4 id="开环调速系统"><a href="#开环调速系统" class="headerlink" title="开环调速系统"></a>开环调速系统</h4><p><img src="/image/djkz20.png" alt=""></p><ul><li>输入的速度给定通过变换得到所需的电机运行频率，以电压 V 的形式呈现：<ul><li>一方面，频率给定经 V/f 变换器（从 V 到 f ）产生了决定<strong>正弦调制波频率</strong>的脉冲，来控制正弦调制波 $u_R$ 的频率</li><li>另一方面，频率给定经<strong>函数发生器</strong>实现了对<strong>正弦调制波幅值</strong>的控制，即基频以下电压降低，保证气隙磁通恒定，最大转矩恒定；基频以上电压恒定，功率恒定</li></ul></li><li><p>至此，正弦波发生器产生频率和幅值都与速度指令相适应的正弦调制波</p><ul><li>一方面，调制波通过调制方式控制器决定<strong>三角波载波的频率</strong></li><li>另一方面，正弦调制波与三角波载波作用，产生用于控制逆变器的 PWM</li></ul></li><li><p>特点：</p><ul><li>无频率反馈，有电压反馈</li><li>频率给定后不变，电机转速会随着负载增大而变小。适合长期稳态运行，调速精度不高的场合</li></ul></li></ul><h4 id="闭环调速系统"><a href="#闭环调速系统" class="headerlink" title="闭环调速系统"></a>闭环调速系统</h4><h5 id="控制原理"><a href="#控制原理" class="headerlink" title="控制原理"></a>控制原理</h5><p><img src="/image/djkz19.png" alt=""></p><ul><li><p>控制原理与方法：</p><script type="math/tex; mode=display">T_e=C_t\phi_mI_2'\cos\psi_2\approx C_t\phi_mI_2'\approx C_t'\phi_m^2\omega_s</script><ul><li><p>也就是说在气隙磁通不变的情况下，<strong>电磁转矩与转差频率成正比</strong>。除了上文函数发生器之外，可以参考书本 p64 的方法来实现更加精确的气隙磁通恒定。</p></li><li><p>开环调速系统可以实现同步速 $\omega_1$ 的控制，因此闭环的关键就是实现对转速和同步速的闭环：</p><script type="math/tex; mode=display">\omega_1(用于调节同步速)=\omega(现在的)+\omega_s(所需的)</script></li></ul></li><li><p>控制框图的另一种画法：</p><ul><li><img src="/image/djkz21.png" alt=""></li></ul></li></ul><h5 id="控制过程"><a href="#控制过程" class="headerlink" title="控制过程"></a>控制过程</h5><p><img src="/image/djkz22.png" alt=""></p><ol><li>起动时 $n=0$，$\omega^*-\omega$ 很大，因此输出 $T<em>{em}=T</em>{m}$，转速沿着最大转矩的铅垂线直线上升</li><li>直到 $\omega$ 接近 $\omega^*$，电磁转矩逐渐减小，逐渐稳定到机械特性与负载转矩的交点</li><li>当给定转速突然减小，电机工作点将从D点移到E点，电磁转矩 $T<em>{em}=-T</em>{m}$，在接近给定转速时再沿着机械特性（？）下降</li></ol><h2 id="高性能控制"><a href="#高性能控制" class="headerlink" title="高性能控制"></a>高性能控制</h2><h3 id="矢量控制"><a href="#矢量控制" class="headerlink" title="矢量控制"></a>矢量控制</h3><h4 id="异步电机数学模型"><a href="#异步电机数学模型" class="headerlink" title="异步电机数学模型"></a>异步电机数学模型</h4><p>坐标变换仍然可以参考电机建模：<a href="https://zju-paradox.top/2024/04/02/电机系统建模与分析/#坐标变化基本定义">电机系统建模与分析 | Paradox’s Website (zju-paradox.top)</a>，但是电机建模里面是恒幅值变换（前面有一章是恒功率变化，那里需要把系数 $\frac23$ 换成 $\sqrt{\frac23}$）。关于 $(\alpha-\beta-0)$ 到 $(d-q-0)$ 的坐标变换方式在文章里已经写的很明白了，这里不再赘述。</p><ul><li><strong>M轴（d）为转子磁链矢量（转子磁场）的方向</strong>，T轴（q）与之垂直。</li><li>为将异步电机等效为直流电机，必须采用<strong>恒转子电动势频比（$\frac{E_r}f=C$）</strong>控制</li><li>仍然满足：<ul><li><strong>旋转电势、转矩、转子电流落在交轴上：$i_{rM}=0$（稳态运行时）</strong></li><li><strong>励磁磁链落在直轴上：$\psi_{rT}=0$</strong></li></ul></li></ul><p><img src="/image/djkz23.jpg" alt=""></p><h4 id="异步电机物理模型"><a href="#异步电机物理模型" class="headerlink" title="异步电机物理模型"></a>异步电机物理模型</h4><ul><li><p>异步电机电感矩阵为 $L=\begin{bmatrix}L<em>{SS}&amp;L</em>{SR}\L<em>{RS}&amp;L</em>{RR} \end{bmatrix}_{6\times6}$，其中：</p><ul><li>各相自感：$L<em>{mm}+L</em>{s\sigma}$ 或 $L<em>{mm}+L</em>{r\sigma}$</li><li>同相间互感（如Aa）：$L_{mm}$</li><li>异相间互感（如AB）：$-\frac12L_{mm}$</li></ul></li><li><p>定子磁链：</p><script type="math/tex; mode=display">\psi_{s}=L_si_s+L_mi_r~~(L_m=\frac32L_{mm},L_s=L_m+L_{s\sigma})</script></li><li><p>转子磁链：</p><script type="math/tex; mode=display">\psi_{r}=L_si_s+L_ri_r~~(L_r=L_m+L_{r\sigma})</script><ul><li><strong>定转子磁链都可以往两个轴（M、T）上分解</strong>，只需要给电流对应加下标就行。</li></ul></li><li><p>电压方程：$u_s=R_si_s+\text p\psi_s+j\omega_1\psi_s~,~u_r=R_ti_r+\text p\psi_r+j\omega_s\psi_r$</p></li><li><p><strong>电磁转矩：</strong></p><script type="math/tex; mode=display">T_e=\frac 32p\frac{L_m}{L_r}\psi_{rM}i_{sT}~~(p是极对数，书上写错了)</script><p>当转子磁链的幅值 $\psi<em>{rM}$ 保持不变的时候，通过调节**定子电流的转矩分量 $i</em>{sT}$ 即可控制电磁转矩**。</p></li><li><p><strong>定子电流：</strong></p><script type="math/tex; mode=display">i_{sT}=\frac{\omega_s\psi_{rM}\tau_r}{L_m}~~(\tau_r=\frac{L_r}{R_r})</script></li><li><p><strong>转子磁链：</strong></p><script type="math/tex; mode=display">\psi_r=\psi_{rM}=\frac{L_m}{1+\tau_rp}i_{sM}</script><ul><li><strong>定子电流的直轴（M轴）分量控制转子磁链，定子电流的交轴（T轴）分量控制电磁转矩，实现解耦</strong></li></ul></li><li><p><strong>转差频率：</strong></p><script type="math/tex; mode=display">\omega_s=\frac{L_mi_{sT}^*}{\tau_r\psi_r^*}=\frac{\tau_rp+1}{\tau_r}\frac{i_{sT}}{i_{sM}}</script></li></ul><h4 id="转子磁场定向技术"><a href="#转子磁场定向技术" class="headerlink" title="转子磁场定向技术"></a>转子磁场定向技术</h4><div class="table-container"><table><thead><tr><th></th><th>磁通检测—电压模型</th><th>磁通检测—电流模型</th><th>转差频率控制式</th></tr></thead><tbody><tr><td>输入</td><td><strong>定子电压 $u<em>{s\alpha\beta}$、定子电流 $i</em>{s\alpha\beta}$</strong></td><td><strong>定子电流 $i_{s\alpha\beta}$、电机转速 $\omega_r$</strong></td><td>$i<em>{sT}^*,\psi</em>{r^*},\omega$</td></tr><tr><td>过程</td><td>$\begin{gather<em>}\psi<em>{r\alpha}=\frac{L_r}{L_mp}[u</em>{s\alpha}-(R<em>s+\sigma L_sp)i</em>{s\alpha}]\\psi<em>{r\beta}=\frac{L_r}{L_mp}[u</em>{s\beta}-(R<em>s+\sigma L_sp)i</em>{s\beta}]  \end{gather</em>}$</td><td>$\begin{gather<em>}\psi<em>{r\alpha}=\frac{1}{\tau_rp}[L_mi</em>{s\alpha}-\omega \tau<em>r\psi</em>{r\beta}]\\psi<em>{r\beta}=\frac{1}{\tau_rp}[L_mi</em>{s\beta}+\omega \tau<em>r\psi</em>{r\alpha}]  \end{gather</em>}$</td><td>$\begin{gather<em>} \omega<em>s=\frac{L_mi</em>{sT}^</em>}{\tau<em>r\psi_r^*}\=\frac{\tau_rp+1}{\tau_r}\frac{i</em>{sT}}{i_{sM}}\end{gather*}$</td></tr><tr><td>输出</td><td>$\begin{gather<em>}\psi<em>r=\sqrt{\psi</em>{r\alpha}^2+\psi<em>{r\beta}^2}\\theta_M=\text{atg}(\psi</em>{r\beta}/\psi_{r\alpha})  \end{gather</em>}$</td><td>$\begin{gather<em>}\psi<em>r=\sqrt{\psi</em>{r\alpha}^2+\psi<em>{r\beta}^2}\\theta_M=\text{atg}(\psi</em>{r\beta}/\psi_{r\alpha})  \end{gather</em>}$</td><td>$\theta_M=\int(\omega_s+\omega)\text dt$</td></tr></tbody></table></div><h4 id="控制系统实例"><a href="#控制系统实例" class="headerlink" title="控制系统实例"></a>控制系统实例</h4><ul><li>Te是带 1.5 这个系数的，下面写错了，他书里也有点问题</li></ul><p><img src="/image/djkz24.jpg" alt=""></p><p><img src="/image/djkz25.jpg" alt=""></p><p>以下是控制框图的注意事项：</p><ol><li><p>控制框图可以拆分为：<strong>物理模型前向通道 + 反馈回路（转子磁场观测）+ 输出</strong></p></li><li><p>物理模型所述的前向通道：</p><p>如上文所述，定子电流的直轴（M轴）分量控制转子磁链，定子电流的交轴（T轴）分量控制电磁转矩</p><p>这个是电机自带的传递函数，控制框图相当于是逆过程，所以：</p><ol><li><strong>通过电磁转矩 $T<em>e^*$ 得到定子电流交轴分量 $i</em>{sT^*}$</strong></li><li><strong>通过转子磁链 $\psi<em>{r}^*$ 得到定子电流直轴分量 $i</em>{sM}^*$</strong></li></ol><p>至于如何得到，方式可以有很多，比如：</p><ol><li>通过PI控制器等 ST 进行输出，需要引入观测量如 $T_e$ 等，如图1</li><li>通过物理模型直接计算，如图2</li></ol></li><li><p>反馈回路（转子磁场观测）：</p><p>观测模型主要注意两点：</p><ol><li>前向通道中是否需要转子磁通 $\psi_r$，若要，则用磁通检测式，如图1；若不要，可用转差频率定向，如图2</li><li>这种观测模型的输入是什么？定子电流、转子磁链？</li></ol></li><li><p>输出：</p><p>输出决定了电源的特性，与控制回路关系不大。<strong>前向通道所得到的一定是定子电流的M和T轴分量的给定值</strong> $i<em>{sM}^*,i</em>{sT}^*$，可以采取如下措施：</p><ol><li>直接做<strong>电流环</strong>控制，得到所需的定子电压给定值</li><li>对电流直接进行变换，利用变频控制中说的<strong>电流跟踪滞环控制</strong>进行控制</li></ol></li><li><p>不需要记具体公式（应该吧），可以用常数、简写等代替。</p></li></ol><h3 id="直接转矩控制"><a href="#直接转矩控制" class="headerlink" title="直接转矩控制"></a>直接转矩控制</h3><ul><li>直接转矩控制将电机和逆变器作为一个整体来考虑，采用电压空间矢量对定子三相电压作综合描述，在定子坐标系中直接控制定子磁链 $\psi_s$ 和电磁转矩 $T_e$。</li></ul><h4 id="数学模型"><a href="#数学模型" class="headerlink" title="数学模型"></a>数学模型</h4><script type="math/tex; mode=display">T_e=\text p\vec \psi_s\times\vec i_s=\text p\frac{L_m}{L_s'L_r}\vec\psi_s\times\vec\psi_r=\text p\frac{L_m}{L_s'L_r}\psi_s\cdot\psi_r\sin\theta_{sr}</script><ul><li>近似认为 $\psi<em>r$ 在匀速旋转（速度为同步速，但是这种直接对磁链进行的控制是可以人为控制频率 $f$ 的），利用 $\Delta\vec\psi_s=\vec u_s\Delta t$ 来控制定子磁链，进而调节 $\theta</em>{sr}$，从而调节电磁转矩。</li></ul><h4 id="磁链与转矩观测器"><a href="#磁链与转矩观测器" class="headerlink" title="磁链与转矩观测器"></a>磁链与转矩观测器</h4><div class="table-container"><table><thead><tr><th></th><th>电压模型定子磁链观测</th><th>电流模型定子磁链观测</th><th>转矩观测</th></tr></thead><tbody><tr><td>输入</td><td>$u<em>{s\alpha},u</em>{s\beta},i<em>{s\alpha},i</em>{s\beta}$</td><td>$i<em>{s\alpha},i</em>{s\beta},\omega_r$</td><td>$i<em>{s\alpha},i</em>{s\beta},\psi<em>{\alpha},\psi</em>{\beta}$</td></tr><tr><td>输出</td><td>$\psi<em>{s\alpha},\psi</em>{s\beta}$ 即 $ \psi<em>s,\theta</em>{\psi s}$</td><td>$\psi<em>{s\alpha},\psi</em>{s\beta}$ 即 $\psi<em>s,\theta</em>{\psi s} $</td><td>$T_e$</td></tr></tbody></table></div><h4 id="六边形磁链轨迹控制系统"><a href="#六边形磁链轨迹控制系统" class="headerlink" title="六边形磁链轨迹控制系统"></a>六边形磁链轨迹控制系统</h4><ul><li><p>他预先设立了一个<strong>换向逻辑</strong>，即：</p><ol><li>采用六边形磁链轨迹控制的时候，某相（abc）磁链的轨迹是一个梯形波</li><li>通过<strong>滞环控制</strong>，将这个梯形波等效成方波（即1和0），方波周期为磁链轨迹周期</li><li>根据磁链和电压图，六种磁链向量（如 $\psi<em>{abc}=101$）会分别对应六种电压向量（如 $u</em>{abc}=011$）</li><li>把第三步的这个对应关系做成一个<strong>换向逻辑</strong>，控制<strong>三相电压开关</strong></li><li>这个只能控制相位，<strong>磁链幅值</strong>需要通过<strong>电磁转矩滞环控制</strong>，来作为上面电压开关的<strong>总开关</strong></li></ol></li><li><p>所以他的控制系统长这样：</p></li></ul><p><img src="/image/djkz26.jpg" alt=""></p><h4 id="变压变频控制-VVVF"><a href="#变压变频控制-VVVF" class="headerlink" title="变压变频控制 VVVF"></a>变压变频控制 VVVF</h4><ul><li>变频调速控制主要通过零电压矢量时间 $t_0$ 和控制有效电压矢量时间 $t_1,t_2$ 来实现<ol><li>基频以下，恒磁通控制：频率 $f$ 降低，周期 $T$ 上升；$t_1,t_2$ 不变令 $t_0$ 增大，使电压、磁通不变</li><li>基频以上，弱磁控制：频率 $f$ 提高，周期 $T$ 减小；令$t_1,t_2$ 减小满足频率变化，相应的电压、磁通要减少</li><li>在基频时，$t_0=0$。</li></ol></li></ul><h1 id="绕线式异步电机控制"><a href="#绕线式异步电机控制" class="headerlink" title="绕线式异步电机控制"></a>绕线式异步电机控制</h1><ul><li>这里主要讲的是变转差调速，即通过调节转差功率 $P<em>{s}=sP</em>{em}$ 来调节转差频率，进而调节转速。</li><li>但是如果在转子上接入电动势，那么转差功率将会被附加电动势吸收转化，回馈电网</li></ul><h2 id="串级调速"><a href="#串级调速" class="headerlink" title="串级调速"></a>串级调速</h2><ul><li>在转子回路中传入一个与转子同频率 $sf_1$ 的附加电动势 $E_f$，取代转子电阻 $R_f$。</li></ul><p><img src="/image/djkz27.jpg" alt=""></p><div class="table-container"><table><thead><tr><th></th><th>$E_f$</th><th>假设</th><th>$P_s$</th><th>转速</th><th>能量</th></tr></thead><tbody><tr><td><strong>亚同步</strong></td><td>$E_f$与$I_2$反相位</td><td>$E_f$↑</td><td>$P<em>s=sP</em>{em}=3I_2^2R_2+3E_fI_2$</td><td>下降↓</td><td>$P_s$从电机流向电网</td></tr><tr><td><strong>超同步</strong></td><td>$E_f$与$I_2$同相位</td><td>$E_f$↑</td><td>$P<em>s=sP</em>{em}=3I_2^2R_2-3E_fI_2$</td><td>上升↑</td><td>$P_s$从电网流向电机</td></tr></tbody></table></div><h3 id="亚同步"><a href="#亚同步" class="headerlink" title="亚同步"></a>亚同步</h3><ul><li><strong>机械特性与电压关系式</strong></li></ul><script type="math/tex; mode=display">\begin{gather*} sE_{d0}-\Delta U_M=U_d=U_{\beta}+R_eI_d=E_{\beta}+\Delta U_s+R_eI_d\\\Rightarrow s=K_1\cos\beta+K_2I_d\\n=n_1(1-s)=n_1(1-K_1\cos\beta-K_2I_d)\end{gather*}</script><ul><li><p>结论：通过改变逆变角 $\beta$ 进行调速，但是转速会随着负载电流的上升而下降，特性较软</p></li><li><p><strong>功率因数问题</strong></p><ul><li><p>逆变器晶闸管换向需要落后的无功，异步电动机也要落后无功，因此功率因数会比较低</p></li><li><p>可以看到下面这幅图（亚同步）里面一部分功率 $P_B$ 经过晶闸管之后逆变回到电网，与上面这个表格是符合的</p></li><li><p>说过附加电动势 $E_f$ 的频率是转子同频，所以频率很低，这个时候不控整流期间就会有严重的换向重叠现象，因此功率因数进一步减小</p></li><li><script type="math/tex; mode=display">\cos\varphi=\frac{P_1-P_{\beta}}{\sqrt{(P_1-P_{\beta})^2+(Q_1+Q_{\beta})^2}}</script></li><li><script type="math/tex; mode=display">\cos\varphi_D=\frac{P_1}{P_1^2+Q_1^2}</script></li></ul></li><li></li></ul><p><img src="/image/djkz28.jpg" alt=""></p><h3 id="超同步-双馈调速与四象限运行"><a href="#超同步-双馈调速与四象限运行" class="headerlink" title="超同步 - 双馈调速与四象限运行"></a>超同步 - 双馈调速与四象限运行</h3><ul><li>亚同步里面转子侧用的不控整流，在双馈调速系统（超同步）里面用的<strong>可控整流</strong>，这样能量才能从电网流向电机（即从右往左流动）</li><li>值得注意的是两个整流桥是反向连接，并且工作状态是互补的（即一个整流另一个逆变）</li><li><p>通过对整流桥电压正负与工作状态的调节，可以实现四象限运行，这四种状态由 2种电压（正负）× 2组状态（整流逆变/逆变整流）构成。可以实现 2种转速（亚/超同步）× 2种能量流动（电动/发电） 这四种状态。</p></li><li><p>双馈调速系统主要通过对整流桥从不控变成可控的改进，能<u>减小装置容量一半，提高功率因数，实现四象限运行</u>。</p></li></ul><h1 id="同步电机控制"><a href="#同步电机控制" class="headerlink" title="同步电机控制"></a>同步电机控制</h1><h2 id="电励磁"><a href="#电励磁" class="headerlink" title="电励磁"></a>电励磁</h2><h3 id="方程式"><a href="#方程式" class="headerlink" title="方程式"></a>方程式</h3><ul><li><p>同步电机的方程看这里：<a href="https://zju-paradox.top/2023/10/07/电机学/#平衡方程与功角特性">电机学笔记（总） | Paradox’s Website (zju-paradox.top)</a>，前面那个叫励磁转矩，后面那个叫同步磁阻转矩。把其他公式带进来，得到电磁转矩如下（前面是电励磁，后面是永磁）：</p><ul><li><script type="math/tex; mode=display">T_e= p~\left[M_fi_fi_q+(L_d-L_q)i_di_q+(M_Di_Di_q-M_Qi_Qi_d) \right]</script></li><li><script type="math/tex; mode=display">T_e=p~(\psi_fi_q+(L_d-L_q)i_di_q)</script></li><li><script type="math/tex; mode=display">T_e=p~\psi_mi_{sT}</script></li></ul></li><li><p>通过励磁磁化电流 $i<em>m$ 使气隙磁链 $\psi_m$ 保持不变，这样通过调节定子电流的转矩 T 分量 $i</em>{sT}$ 来控制电磁转矩</p></li></ul><h3 id="观测器"><a href="#观测器" class="headerlink" title="观测器"></a>观测器</h3><div class="table-container"><table><thead><tr><th></th><th>磁链</th><th>电流给定值</th></tr></thead><tbody><tr><td>输入</td><td>$i_d,i_q,i_f$</td><td>$\theta,\theta<em>0,i_f,i_m^*,i</em>{sT}^*$</td></tr><tr><td>输出</td><td>$\psi_m,\theta,\theta_0$</td><td>$i<em>f^*,i</em>{abc}$</td></tr><tr><td>备注</td><td>$i_{dq}$需要$\theta_r$来进行3s-2r</td><td>$i<em>m$和$i</em>{sT}$控制$T_e$，因此需要控制</td></tr><tr><td></td><td>比正常系统多一个 $i_f$ 的输入</td></tr></tbody></table></div><ul><li>这个空间矢量图比较复杂，需要解释一下：<ol><li>这里有两个运动两相坐标系，一个是<strong>直轴-交轴坐标系 $d-q$</strong>，一个是<strong>磁链-转矩坐标系 $M-T$</strong></li><li>有两个电流，定子电流 $i<em>s$ 可以在 M-T 分解为 $i</em>{sM},i_{sT}$，转子电流就是励磁电流 $i_f$，因为是直轴励磁，因此 $i_f$ 落在 d 轴上</li><li>角度也有两个，其中 d 轴与 a 相的夹角为 $\theta_r$，M 轴与 a 相的夹角为 $\theta_0$，这两个轴之间的夹角为 $\theta$，其中 M 轴要超前 d 轴一点。有：$\theta_r+\theta=\theta_0$</li><li>磁化电流 $i<em>m$ 并不是实际存在的电流，仅是定转子电流在 M 轴（转子磁链轴）上的投影，即：$i_m=i</em>{sM}+i_f\cos\theta_0$</li><li>$\theta_r$ 电机是可以直接输出的，$\psi_f$ 或者 $i_f$ 也是可以有外部可以测量直接输入的</li></ol></li></ul><p><img src="/image/djkz29.jpg" alt=""></p><h2 id="永磁电机"><a href="#永磁电机" class="headerlink" title="永磁电机"></a>永磁电机</h2><ul><li><strong>贴片永磁</strong>的特点是直轴和交轴电感一样，即 $L_d=L_q$，所以电磁转矩为 $T_e=p\,\psi_fi_q$</li><li>还有其他永磁电机，$L_d\ne L_q$</li><li>没有转子电流，但是直轴会多一个磁链 $\psi_f$</li></ul><div class="table-container"><table><thead><tr><th></th><th>基于 $i_d=0$ 的控制</th><th>最大转矩电流比 MTPA 控制</th></tr></thead><tbody><tr><td>$T_e$</td><td>$T_e=p~\psi_fi_q$</td><td>$T_e^<em>=i_q^</em>(1-i_d^<em>)$（</em>是标幺值）</td></tr><tr><td>图解</td><td><img src="/image/djkz30.jpg" alt=""></td><td><img src="/image/djkz31.jpg" alt=""></td></tr><tr><td>注释</td><td>控制极其简单！因为励磁 $\psi_f$ 固定，所以只用控制交轴电流 $i_q $ 即可完成转矩控制。为了定子电流最小，可以直接让 $i_d^*=0$</td><td>控制也很简单，主要思想是在给定转矩下得到最小可用的定子电流</td></tr></tbody></table></div><h1 id="P-S"><a href="#P-S" class="headerlink" title="P.S"></a>P.S</h1><ul><li>所有电机的输入都长这个样子（或者再多加一点）：<ul><li><img src="/image/djkz32.jpg" alt=""></li></ul></li><li>最终得到的<strong>控制量一定是两相电流参考值</strong>，要么是 $i<em>{sM}^*+i</em>{sT}^<em>$，要么是 $i_d^</em>+i_q^*$</li><li>我们经常见到下面这幅图的小模块，他的意思是：<strong>输出 s 能控制输入 a，比如转矩控制转速，电流控制转矩，电流控制磁链，电压控制电流</strong><ul><li><img src="/image/djkz33.jpg" alt=""></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电机系统建模与分析</title>
      <link href="/2026/02/24/%E7%94%B5%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/"/>
      <url>/2026/02/24/%E7%94%B5%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%BB%BA%E6%A8%A1%E4%B8%8E%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Chap1-摘要"><a href="#Chap1-摘要" class="headerlink" title="Chap1. 摘要"></a>Chap1. 摘要</h1><blockquote><p>觉得卡的或者遇到公式渲染不出来的情况请开翻墙，ZJU的校网就是依托。</p><p>若无特殊说明，本文中使用斜体的$p$表示电机极对数，用正体的$\text p$表示海氏算子$\frac{\text d}{\text dt}$</p><p>期中可能会放PDF版本（<a href="\myfile\电机系统建模与分析.pdf" target="_blank">Click Here</a>）</p></blockquote><p><img src="\image\电机建模17.jpg" alt=""></p><h2 id="补：绕组系数"><a href="#补：绕组系数" class="headerlink" title="补：绕组系数"></a>补：绕组系数</h2><p>现在应该是才算是完全搞懂了</p><ul><li>短距系数表征的是“<strong>一个线圈的上下层边</strong>”的电势矢量的合成关系</li><li>分布系数表征的是“<strong>不同线圈之间（只看上层边）</strong>”的电势矢量的合成关系</li></ul><p>求解办法：</p><ol><li>画绕组分布展开图，选其中一相画</li><li>看看一个线圈上下层边跨过了多少电角度（记为$\theta_y$），则短距系数为$\sin(\frac{\theta_y}{\pi}\cdot\frac{\pi}2)$</li><li>看看<strong>所有线圈的上层边</strong>，把他们用矢量图画出来。同极下的直接相加，不同极下的添负号。</li></ol><h1 id="Chap2-微分方程数值解法"><a href="#Chap2-微分方程数值解法" class="headerlink" title="Chap2. 微分方程数值解法"></a>Chap2. 微分方程数值解法</h1><h2 id="一阶微分方程"><a href="#一阶微分方程" class="headerlink" title="一阶微分方程"></a>一阶微分方程</h2><p>设一阶微分方程的一般形式为：</p><script type="math/tex; mode=display">\frac{\text dx}{\text dt}=\text px=f(t,x)</script><p>倘若已知初始时刻的变量值（如：$x(0)$），想要得到下一时刻的值，基本思路是$x_{i+1}=x_i+\text px\cdot \Delta t$</p><p>设等步长，相邻两时刻间的时间差（步长）为$h$，</p><p><strong>四阶龙格-库塔法：</strong></p><script type="math/tex; mode=display">\begin{gather*}K_1=f(t_i,x_i)&\Rightarrow& x_{i+\frac12}^{(1)}=x_i+K_1\frac h2\\K_2=f(t_{i+\frac12},x_{i+\frac12}^{(1)})&\Rightarrow& x_{i+\frac12}^{(2)}=x_i+K_2\frac h2\\K_3=f(t_{i+\frac12},x_{i+\frac12}^{(2)})&\Rightarrow &x_{i+1}^{(1)}=x_i+K_3h\\K_4=f(t_{i+1},x_{i+1}^{(1)})&\Rightarrow&K=\frac{K_1+2K_2+2K_3+K_4}6\\&x_{i+1}=x_i+Kh\end{gather*}</script><h2 id="一阶微分方程组"><a href="#一阶微分方程组" class="headerlink" title="一阶微分方程组"></a>一阶微分方程组</h2><p>一般采用同步梯度的方式求解多变量方程组，这里以两变量为例：</p><script type="math/tex; mode=display">\begin{gather*}K_{1x}=f_x(t_i,x_i,y_i)&K_{1y}=f_y(t_i,x_i,y_i)\\\Rightarrow x_{i+\frac12}^{(1)}=x_i+K_{1x}\frac h2&y_{i+\frac12}^{(1)}=y_i+K_{1y}\frac h2\\K_{2x}=f_x(t_{i+\frac12},x_{i+\frac12}^{(1)},y_{i+\frac12}^{(1)})&K_{2y}=f_y(t_{i+\frac12},x_{i+\frac12}^{(1)},y_{i+\frac12}^{(1)})\\\Rightarrow x_{i+\frac12}^{(2)}=x_i+K_{2x}\frac h2&y_{i+\frac12}^{(2)}=y_i+K_{2y}\frac h2\end{gather*}</script><p>后面不抄了，K3K4一样的，反正意思就是同步更新。</p><h1 id="Chap3-一般化电机模型"><a href="#Chap3-一般化电机模型" class="headerlink" title="Chap3. 一般化电机模型"></a>Chap3. 一般化电机模型</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>一般化电机的基本假设：</p><ol><li>一对级电机（$p=1$），极对数是可以等效的</li><li>绕组是可以等效的，如三相变为两相</li><li>伪静止线圈：构成线圈的导体是运动的（以$\omega$旋转），但是d、q线圈是由电刷所规定的，因此轴线静止。<ol><li>线圈中的电流在空间产生轴线静止的磁场</li><li>导体实际上在旋转，因此还是会有旋转电势</li></ol></li><li>磁路不饱和（可用叠加原理）</li><li>不计剩磁、涡流、磁滞损耗</li><li>气隙磁密按正弦规律分布</li><li>只关心导体分布在哪些槽内，不关心具体的连接方式和整、短距等</li></ol><h2 id="基本方程式"><a href="#基本方程式" class="headerlink" title="基本方程式"></a>基本方程式</h2><h3 id="正方向的规定"><a href="#正方向的规定" class="headerlink" title="正方向的规定"></a>正方向的规定</h3><div class="table-container"><table><thead><tr><th></th><th>原则</th><th>模型</th><th>方程式</th></tr></thead><tbody><tr><td><strong>电动机</strong></td><td>1. 正电流产生正磁链<br />2. 从外向线圈看，电压与电流正方向相同<br />3. 线圈的输入功率为正值</td><td><img src="\image\电机建模04.png" alt=""></td><td>$\begin{gather<em>}\varPsi=Li\U=Ri+e\e=\text p\varPsi\end{gather</em>}$</td></tr><tr><td><strong>发电机</strong></td><td>1. 正电流产生负磁链<br />2. 从线圈向外看，电压与电流正方向相同<br />3. 线圈的输出功率为正值</td><td><img src="\image\电机建模05.png" alt=""></td><td>$\begin{gather<em>}\varPsi=-Li\U=e-Ri\e=\text p\varPsi\end{gather</em>}$</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th></th><th>原则</th><th>方程式</th><th>功率</th></tr></thead><tbody><tr><td><strong>电动机</strong></td><td>1. 电磁转矩正方向就是旋转方向<br />2.负载、阻尼、惯性转矩正方向与之相反</td><td>$T_e=T_L+T_D+J\text p\Omega$</td><td>$P_m=-T_L\Omega$</td></tr><tr><td><strong>发电机</strong></td><td>1. 外施转矩正方向就是旋转方向<br />2.负载、阻尼、惯性转矩正方向与之相反</td><td>$T_m=T_e+T_D+J\text p\Omega$</td><td>$P_m=T_m\Omega$</td></tr></tbody></table></div><h3 id="电磁方程式"><a href="#电磁方程式" class="headerlink" title="电磁方程式"></a>电磁方程式</h3><blockquote><p>电枢（转子）按发电机原则规定正方向</p><p>励磁（定子）按电动机原则规定正方向</p></blockquote><p><img src="\image\电机建模06.png" alt=""></p><script type="math/tex; mode=display">\begin{gather*}\begin{cases}u_d=\text p\varPsi_d-R_di_d-K_q\omega\phi_q(旋转电势e_{dr})\\u_q=\text p\varPsi_q-R_qi_q+K_d\omega\phi_d(旋转电势e_{qr})\\u_{fd}=\text p\varPsi_{fd}+R_{fd}i_{fd}\\u_{kq}=\text p\varPsi_{kq}+R_{kq}i_{kq}\end{cases}\end{gather*}</script><p>根据<a href="#一般化电机旋转电势">对应的推导</a>，旋转电势中：</p><script type="math/tex; mode=display">\begin{gather*}\begin{cases}e_{dr}=-K_q\omega\phi_q=-\omega\varPsi_q\\e_{qr}=K_d\omega\phi_d=\omega\varPsi_d\end{cases}\end{gather*}</script><p>并带入$\varPsi=LI$，得到电磁方程式为：</p><script type="math/tex; mode=display">\begin{gather*}[U]=\text p[L][I]+[R][I]+\omega[G][I]\\\text p[I]=[L]^{-1}({[U]-[R][I]-\omega[G][I]})\end{gather*}</script><p>其中：</p><script type="math/tex; mode=display">\begin{gather*}[L]=\begin{bmatrix}-L_d&0&M_{afd}&0\\0&-L_q&0&M_{akq}\\-M_{fad}&0&L_{fd}&0\\0&-M_{kaq}&0&L_q\end{bmatrix}&,&[G]=\begin{bmatrix}0&L_q&0&-M_{akq}\\-L_d&0&M_{afd}&0\\0&0&0&0\\0&0&0&0\end{bmatrix}\end{gather*}</script><h1 id="Chap4-直流电机仿真"><a href="#Chap4-直流电机仿真" class="headerlink" title="Chap4. 直流电机仿真"></a>Chap4. 直流电机仿真</h1><p>考虑以下他励直流电机：</p><p><img src="\image\电机建模11.jpg" alt=""></p><p>只有直轴励磁和交轴电枢电压，故其方程为：</p><script type="math/tex; mode=display">\begin{gather*}u_q=\text p\varPsi_q+\omega\varPsi_d-R_qi_q\\u_{fd}=\text p\varPsi_{fd}+R_{fd}i_{fd}\end{gather*}</script><p>其中：</p><script type="math/tex; mode=display">\varPsi_d=M_{afd}i_{fd}~;~\varPsi_q=-L_qi_q~;~\varPsi_{fd}=L_{fd}i_{fd}</script><blockquote><p>注：如果认为磁通全部通过磁链，并且定子和转子完全交链，那么有$\phi<em>d=\phi</em>{fd}$</p><p>于是：$\varPsi<em>d=z\phi_d=z\phi</em>{fd}=z\frac{L<em>{fd}i</em>{fd}}{N<em>{fd}}=M</em>{afd}i_{fd}$</p><p>即：$M<em>{afd}=\frac{zL</em>{fd}}{N_{fd}}$</p></blockquote><h2 id="他励直流发电机的突然短路（-R-L-rightarrow0-）"><a href="#他励直流发电机的突然短路（-R-L-rightarrow0-）" class="headerlink" title="他励直流发电机的突然短路（$R_L\rightarrow0$）"></a>他励直流发电机的突然短路（$R_L\rightarrow0$）</h2><h3 id="稳态"><a href="#稳态" class="headerlink" title="稳态"></a>稳态</h3><script type="math/tex; mode=display">\begin{gather*}u_{q0}=\omega_0M_{afd}i_{fd}-R_qi_q=R_{L}i_{q}\\u_{fd}=R_{fd}i_{fd}\\\Rightarrowi_{q0}=\frac{\omega_0M_{afd}u_{fd}}{(R_L+R_q)R_{fd}}\end{gather*}</script><h3 id="条件1-转速瞬时不变"><a href="#条件1-转速瞬时不变" class="headerlink" title="条件1. 转速瞬时不变"></a>条件1. 转速瞬时不变</h3><script type="math/tex; mode=display">\begin{gather*}0=-L_q\text pi_q+\omega_0M_{afd}i_{fd}-R_qi_q\\\Rightarrowi_q=\frac{\omega_0M_{afd}i_{fd}}{R_q}\frac1{\tau\text p+1}~;~(\tau=L_q/R_q)\\\Rightarrow i_q=i_{q0}\frac{R_L+R_q}{R_q}(1-e^{-\frac{t+t_0}{t_0}})\end{gather*}</script><h3 id="条件2-短路时停止提供动力"><a href="#条件2-短路时停止提供动力" class="headerlink" title="条件2. 短路时停止提供动力"></a>条件2. 短路时停止提供动力</h3><script type="math/tex; mode=display">\begin{gather*}\begin{cases}\text pi_q=\frac{\omega M_{afd}i_{fd}-R_qi_q}{L_q}\\T_m=0=M_{afd}i_{fd}i_q+B\omega+J\text p\omega  \end{cases}\Rightarrow \text p\omega=\frac{M_{afd}i_{fd}i_q+B\omega}{-J}\end{gather*}</script><h3 id="条件3-停止原动机时停止励磁"><a href="#条件3-停止原动机时停止励磁" class="headerlink" title="条件3. 停止原动机时停止励磁"></a>条件3. 停止原动机时停止励磁</h3><p>​        此时$i_{fd}=0$,机电解耦！</p><script type="math/tex; mode=display">\text pi_q=-R_qi_q/L_q~,~\text p\omega=-B\omega/J</script><h1 id="Chap5-三相交流电机在相坐标系下的模型"><a href="#Chap5-三相交流电机在相坐标系下的模型" class="headerlink" title="Chap5. 三相交流电机在相坐标系下的模型"></a>Chap5. 三相交流电机在相坐标系下的模型</h1><p>按照<strong>电动机</strong>原则选取正方向，即：</p><ol><li>绕组轴线的方向是磁链正方向，<u>正电流产生正磁链</u></li><li>从外向绕组看，<u>电压与电流正方向同向</u>，输入功率为正</li><li><u>电磁转矩正方向就是转子旋转的方向</u>，负载$T_L$、阻尼$B\Omega$、惯性$Jp\Omega$转矩相反</li></ol><p><img src="\image\电机建模01.png" alt=""></p><p>考虑D轴与Q轴正交解耦，则其<strong>电压平衡式</strong>为：</p><script type="math/tex; mode=display">\begin{gather*}\begin{cases}U_a=\text p\varPsi_a+R_ai_a&（B、C相同理）\\U_f=\text p\varPsi_f+R_fi_f\\U_D=U_Q=0&（阻尼短路绕组）  \end{cases} \end{gather*}</script><p>即：</p><script type="math/tex; mode=display">\begin{gather*}  \begin{bmatrix}u_a\\u_b\\u_c\\u_f\\0\\0\end{bmatrix}=\text p\begin{bmatrix}\varPsi_a\\\varPsi_b\\\varPsi_c\\\varPsi_f\\\varPsi_D\\\varPsi_Q\end{bmatrix}+\begin{bmatrix}R_s&0&0&0&0&0\\0&R_s&0&0&0&0\\0&0&R_s&0&0&0\\0&0&0&R_f&0&0\\0&0&0&0&R_D&0\\0&0&0&0&0&R_Q\end{bmatrix}\begin{bmatrix}i_a\\i_b\\i_c\\i_f\\i_D\\i_Q\end{bmatrix}\end{gather*}</script><p>​        其中磁链矩阵$[\varPsi]$可以表示为$[L][I]$，由于转子励磁旋转导致DQ轴与定子相轴耦合关系改变，电感矩阵$[L]$时变。电感矩阵中各分量结果如下：<a id="三相电感"><a href="#三相交流电机电感矩阵">三相交流电机电感矩阵推导</a></a></p><ol><li><p><strong>定子绕组自感系数</strong></p><script type="math/tex; mode=display">\begin{gather*}L_{aa}=L_{aal}(漏感)+\frac{L_{aad}+L_{aaq}}2+\frac{L_{aad}-L_{aaq}}2cos2\theta\\L_{bb}=L_{aal}(漏感)+\frac{L_{aad}+L_{aaq}}2+\frac{L_{aad}-L_{aaq}}2cos2(\theta-\frac{2\pi}3)\\L_{cc}=L_{aal}(漏感)+\frac{L_{aad}+L_{aaq}}2+\frac{L_{aad}-L_{aaq}}2cos2(\theta+\frac{2\pi}3)\end{gather*}</script><ol><li>对于隐极同步电机（$L<em>{aad}=L</em>{aaq}$），自感系数是常数</li></ol></li><li><p><strong>定子绕组互感系数</strong></p><script type="math/tex; mode=display">\begin{gather*} M_{ab}=-(M_{abl}+\frac{L_{aad}+L_{aaq}}4)+\frac{L_{aad}-L_{aaq}}2cos2(\theta+\frac{2\pi}3)\end{gather*}</script><ol><li>因为三相轴线相差120°，所以互感是负的，说明推导无误</li><li>AB相的互感用C相的角度，其余同理</li></ol></li><li><p><strong>定子与转子之间的互感</strong></p><script type="math/tex; mode=display">\begin{gather*}M_{af}=M_{fa}=M_{af1}cos\theta\\M_{bf}=M_{fb}=M_{af1}cos(\theta-\frac{2\pi}3)\\M_{cf}=M_{fc}=M_{af1}cos(\theta+\frac{2\pi}3) \end{gather*}</script><ol><li>定子绕组自感变化周期是$\pi$，这个是$2\pi$。下同。</li></ol></li><li><p><strong>定子绕组与转子D轴阻尼绕组间互感</strong></p><script type="math/tex; mode=display">M_{aD}=M_{Da}=M_{aD1}cos\theta</script></li><li><p><strong>定子绕组与转子Q轴阻尼绕组间互感</strong></p><script type="math/tex; mode=display">M_{aQ}=M_{Qa}=-M_{aQ1}sin\theta</script></li><li><p><strong>转子绕组自感、互感</strong></p><script type="math/tex; mode=display">\begin{gather*}L_f=L_{fl}+L_{f\delta}\\L_D=L_{Dl}+L_{D\delta}\\L_Q=L_{Ql}+L_{Q\delta}\\M_{fD}=M_{Df}=M_{fDl}+M_{fD\delta}\end{gather*}</script><ol><li>由于DQ轴正交解耦，故不存在互感</li></ol></li></ol><p>由此得到：</p><script type="math/tex; mode=display">\begin{gather*}\begin{bmatrix}\varPsi_a\\\varPsi_b\\\varPsi_c\\\varPsi_f\\\varPsi_D\\\varPsi_Q\end{bmatrix}=\begin{bmatrix}L_{aa}&M_{ab}&M_{ac}&M_{af}&M_{aD}&M_{aQ}\\M_{ba}&L_{bb}&M_{bc}&M_{bf}&M_{bD}&M_{bQ}\\M_{ca}&M_{cb}&L_{cc}&M_{cf}&M_{cD}&M_{cQ}\\M_{fa}&M_{fb}&M_{fc}&L_f&M_{fD}&0\\M_{Da}&M_{Db}&M_{Dc}&M_{Df}&L_D&0\\M_{Qa}&M_{Qb}&M_{Qc}&0&0&L_Q\end{bmatrix}\cdot \begin{bmatrix}i_a\\i_b\\i_c\\i_f\\i_D\\i_Q\end{bmatrix}\end{gather*}</script><p>对应的，其<a id="三相转矩"><strong>转矩平衡式</strong></a>为（<a href="#三相交流电机电磁转矩">电磁转矩的推导过程</a>）：</p><script type="math/tex; mode=display">T_e=\frac p2[I]^T\frac{\partial[L]}{\partial\theta}[I]</script><h1 id="Chap6-坐标变换"><a href="#Chap6-坐标变换" class="headerlink" title="Chap6. 坐标变换"></a>Chap6. 坐标变换</h1><p>一个电机的建模与求解过程应该是下面这样的：</p><p><img src="\image\电机建模07.png" alt=""></p><p>上一章已经展示了，三相交流电机在相坐标（a-b-c Model）下的模型方程是多么复杂，所以要用坐标变换把他等效到更好计算的坐标系（如α-β-0和d-q-0坐标系）下。</p><h2 id="坐标变化基本定义"><a href="#坐标变化基本定义" class="headerlink" title="坐标变化基本定义"></a>坐标变化基本定义</h2><ul><li><p>下面直接不加推导的给出三相坐标系到（二维平面-0）坐标系的<strong>恒相幅值变换</strong>的表达式：</p><ul><li>在三相坐标系中，三个坐标轴为a、b、c，记其方向向量为$\vec a,\vec b,\vec c$，在三个方向向量上的某物理量的数值分别为$x_a,x_b,x_c$</li><li>定义<strong>综合矢量：</strong>$\vec x=\frac23(x_a\vec a+x_b\vec b+x_c\vec c)$</li><li>定义<strong>零分量：</strong>$x_0=\frac{x_a+x_b+x_c}3$</li><li><img src="\image\电机建模08.png" alt=""></li></ul></li><li><p>电机的模型是二维的，所以按理说两个基足以。但是坐标变换必须满足等变量个数，因此这里从“a、b、c”三个基（变量）换成了“综合矢量+零分量”三个变量（矢量=模长+方向，或正交分解，实际是两个变量）</p></li><li>但是综合矢量以矢量的形式不好表达，所以可以写成下面这样的形式：<ul><li>定义：$x_a’=x_a-x_0~,~x_b’=x_b-x_0~,~x_c’=x_c-x_0$</li><li><strong>综合矢量：</strong>$\vec x\rightarrow\dot x=\frac23(x_a+x_be^{j120}+x_ce^{j240})\triangleq xe^{j\alpha}$<ul><li><strong>幅值：</strong>$|x|=\sqrt{\frac23(x_a’^2+x_b’^2+x_c’^2)}$</li><li><strong>夹角（与a轴）：</strong>$\alpha=\text{cos}^{-1}(\frac{x_a’}{x_a})$</li></ul></li></ul></li><li>当然，要把（二维平面-0）坐标系变回三相坐标系也是需要的，其表达式为：<ul><li>a相：$x_a’=x\,\text{cos}\alpha~,~x_a=x_0+x_a’$</li><li>a相：$x_b’=x\,\text{cos}(\alpha-\frac{2\pi}3)~,~x_b=x_0+x_b’$</li><li>c相：$x_c’=x\,\text{cos}(\alpha+\frac{2\pi}3)~,~x_c=x_0+x_c’$</li></ul></li></ul><h2 id="三相电机中坐标变换的重要结论"><a href="#三相电机中坐标变换的重要结论" class="headerlink" title="三相电机中坐标变换的重要结论"></a>三相电机中坐标变换的重要结论</h2><ul><li>在三相对称系统中，三个物理量并非像定义中的$x_a,x_b,x_c$一般毫无关联，而是由如下类似的表达式：<ul><li>a相：$i_a=I_m\,\text{cos}\theta$</li><li>b相：$i_b=I_m\,\text{cos}(\theta-\frac{2\pi}3)$</li><li>c相：$i_c=I_m\,\text{cos}(\theta+\frac{2\pi}3)$</li></ul></li><li>把他变换到（二维平面-0）坐标系中是这样的：<ul><li>零分量：$i_0=\frac{i_a+i_b+i_c}3=0$</li><li>综合矢量幅值：$|i|=\sqrt{\frac23(i_a’^2+i_b’^2+i_c’^2)}=\sqrt{\frac23\cdot\frac32I_m^2}=I_m$</li><li>综合矢量夹角：$\alpha=\text{cos}^{-1}\frac{i_a’}{|i|}=\text{cos}^{-1}\frac{I_m\,\text{cos}\theta+0}{I_m}=\theta$</li><li>即：$\vec i=\dot i=I_me^{j\theta}$</li></ul></li><li>也就是说，对于三相对称系统（电压、电流、磁链等大部分都遵循这个规律），有以下重要结论：<ol><li><strong>综合矢量的幅值就是三相坐标系中的幅值</strong></li><li><strong>综合矢量的夹角就是三相坐标系中该矢量与a相的夹角</strong></li><li><strong>零分量为0</strong>（零分量的物理含义是被相互抵消，基本不产生实际作用的分量）</li><li><strong>三相坐标系中的分量（如$x_a$）就是综合矢量在该轴上的投影</strong>（实际上是$x_a’$，如果$x_0=0$的话$x_a=x_a’$）</li></ol></li></ul><h2 id="绕组等效与坐标变换"><a href="#绕组等效与坐标变换" class="headerlink" title="绕组等效与坐标变换"></a>绕组等效与坐标变换</h2><p><img src="\image\电机建模09.png" alt=""></p><ul><li><p>最后需要把拿到的（二维平面-0）坐标系下的综合矢量+零分量的形式用特定的分解方式表示出来。<strong>新坐标系各轴上的分量大小就是综合矢量往该轴的投影</strong>。常用的坐标系有以下这几个（他们的零分量都是一样的）：</p><ul><li>$\alpha-\beta-0$坐标系：$\alpha$轴与a相重合，$\beta$轴落后90°</li><li>$d-q-0$坐标系：以角速度旋转，跟电枢是重合的。最常用的坐标系。</li><li>$d_c-q_c-0$坐标系：以同步速旋转，在未稳定的情况下会比上面那个转的更快一点</li></ul></li><li><p><strong>正变换</strong>（已知$i_a,i_b,i_c$，定义<strong>d轴与a相的夹角为$\theta=\int\omega\text dt+\theta_0$）</strong>：</p></li></ul><script type="math/tex; mode=display">\begin{gather*}\begin{pmatrix}i_d\\i_q\\i_0\end{pmatrix}=\frac23\begin{pmatrix}\text{cos}\theta&\text{cos}(\theta-\frac{2\pi}3)&\text{cos}(\theta+\frac{2\pi}3)\\-\text{sin}\theta&-\text{sin}(\theta-\frac{2\pi}3)&-\text{sin}(\theta+\frac{2\pi}3)\\\frac12&\frac12&\frac12\end{pmatrix}\cdot\begin{pmatrix}i_a\\i_b\\i_c\end{pmatrix}\end{gather*}</script><ul><li><strong>逆变换</strong>：</li></ul><script type="math/tex; mode=display">\begin{gather*}\begin{pmatrix}i_a\\i_b\\i_c\end{pmatrix}=\begin{pmatrix}\text{cos}\theta&-\text{sin}\theta&1\\\text{cos}(\theta-\frac{2\pi}3)&-\text{sin}(\theta-\frac{2\pi}3)&1\\\text{cos}(\theta+\frac{2\pi}3)&-\text{sin}(\theta+\frac{2\pi}3)&1\end{pmatrix}\cdot\begin{pmatrix}i_d\\i_q\\i_0\end{pmatrix}\end{gather*}</script><ul><li>显而易见，上面是到$d-q-0$坐标系的变换，到$\alpha-\beta-0$坐标系更简单，因为$\theta=0$，变换矩阵直接变成常数了</li></ul><h1 id="Chap7-d-q-0坐标下凸极同步电机"><a href="#Chap7-d-q-0坐标下凸极同步电机" class="headerlink" title="Chap7. d-q-0坐标下凸极同步电机"></a>Chap7. d-q-0坐标下凸极同步电机</h1><h2 id="电磁平衡式"><a href="#电磁平衡式" class="headerlink" title="电磁平衡式"></a>电磁平衡式</h2><p>​        这里不加推导（<a href="#d-q-0坐标电压方程式推导">推导看这里</a>）的给出电压方程式，可以看到和一般化电机的电压方程式几乎一模一样！</p><p><img src="\image\电机建模12.jpg" alt=""></p><p>​        并且不加推导（<a href="#d-q-0坐标磁链表达式推导">推导看这里</a>）的给出磁链表达式，可以看到所有电感全部变成了常数！唯一美中不足的就是电感矩阵不是一个对称阵</p><p><img src="\image\电机建模13.jpg" alt=""></p><p>其中各参数如下：</p><script type="math/tex; mode=display">\begin{gather*}直轴同步电感L_d=直轴电枢反应电感L_{ad}+漏电感L_l=\frac32L_{aad}+(L_{aal}+M_{abl})\\交轴同步电感L_q=交轴电枢反应电感L_{aq}+漏电感L_l=\frac32L_{aaq}+(L_{aal}+M_{abl})\\L_0=L_{aal}-2M_{abl}\end{gather*}</script><blockquote><ol><li>若不是d-q-0坐标变换而是$\alpha-\beta-0$坐标变换，那么[L]也不是常数</li><li>该模型中必须求解$\theta$，因为要进行坐标反变换回到a-b-c坐标底下</li></ol></blockquote><h2 id="功率变换"><a href="#功率变换" class="headerlink" title="功率变换"></a>功率变换</h2><p>功率表达式：</p><script type="math/tex; mode=display">P_{dq0}=\frac23P_{abc}-u_0i_0~~(P_{abc}=\frac32(P_{dq0+u_0i_0}))</script><p>自然的，其中 $P<em>{dq0}=[I</em>{dq0}^T][u<em>{dq0}],~P</em>{abc}=[I<em>{abc}]^T[u</em>{abc}]$</p><p>对机械角度而言，有：</p><script type="math/tex; mode=display">T_e=T_D+T_L+T_J~,~P_m=-T_L\Omega</script><p>不加推导（<a href="#d-q-0功率表达式推导">推导看这里</a>）地给出三个功率的表达式：</p><script type="math/tex; mode=display">\begin{gather*}储能：&P=\Omega J\text p\Omega=\frac32[\text p\varPsi_d,\text p\varPsi_q,2\text p\varPsi_0][I_{dq0}]+[\text p\varPsi_f,\text p\varPsi_D,\text p\varPsi_Q][I_{fDQ}]\\损耗：&P=B\Omega^2=\frac32R_s(i_d^2+i_q^2+2i_0^2)+[R_{fDQ}]^T[i_f^2;~i_D^2;~i_Q^2]\\电磁：&P=-\Omega T_e=\frac32\omega(\varPsi_di_q-\varPsi_qi_d)\end{gather*}</script><p>因此得到一个与一般化电机非常相似的电磁转矩表达式（下面这个 p 代表极对数）：</p><script type="math/tex; mode=display">T_e=\frac32p(\varPsi_di_q-\varPsi_qi_d)</script><h2 id="同步电动机对称稳态运行分析"><a href="#同步电动机对称稳态运行分析" class="headerlink" title="同步电动机对称稳态运行分析"></a>同步电动机对称稳态运行分析</h2><ul><li>以电动机原则作为正方向</li><li>稳态时电流为常数</li><li>适用于隐极电机（令 $X_d=X_q$ 即可），但不适用于感应电机（转速不能达到同步速）</li></ul><h3 id="发电机空载（开路）"><a href="#发电机空载（开路）" class="headerlink" title="发电机空载（开路）"></a>发电机空载（开路）</h3><ol><li>首先0绕组分量均为0（三相对称），因此方程式中均不用考虑了</li><li>阻尼绕组短路，即$U_D=U_Q=0$</li><li>空载时电枢绕组开路，即$i_a=i_b=i_c=0$，因此有$i_d=i_q=i_0=0$</li></ol><p>此时有：</p><script type="math/tex; mode=display">\begin{gather*}\begin{cases}u_d=\text p\varPsi_d-\omega\varPsi_q+R_di_d\\u_q=\text p\varPsi_q+\omega\varPsi_d+R_qi_q\\ u_f=\text p\varPsi_f+R_fi_f \end{cases}\\\begin{bmatrix} \varPsi_d\\\varPsi_q\\\varPsi_f  \end{bmatrix}=\begin{bmatrix}L_d&0&M_{afd1}\\0&L_q&0\\\frac32M_{afd1}&0&L_{ff} \end{bmatrix} \begin{bmatrix} i_d\\i_q\\i_f  \end{bmatrix}\end{gather*}</script><ol><li>$u_f=R_fi_f$</li><li>$u_d=\text p~const+\omega\cdot0+0=0$</li><li>$u<em>q=\omega M</em>{af1}i_f=e=E_m$，这个就是<strong>旋转电势</strong>！</li><li>可以看到旋转电势没有直轴分量（$u_d=0$），因此旋转电势落在交轴上，励磁磁链（$\varPsi_f$）落在直轴上</li></ol><h3 id="负载运行"><a href="#负载运行" class="headerlink" title="负载运行"></a>负载运行</h3><p>参考一下电机学里的这张图，但是交轴直轴不对，详见下方注释。</p><p><img src="\image\电机建模15.png" alt=""></p><p>因此有：</p><script type="math/tex; mode=display">\dot U=\dot E+\dot IR_s+jX_d\dot I_d+jX_q\dot I_q</script><p>此时，由于电流为常数，因此仍然有$\text p\varPsi=0$，故：</p><script type="math/tex; mode=display">\begin{gather*} u_d=-\omega L_qi_q+R_di_d=-U_m\sin\delta\\u_q=\omega L_di_d+E_m+R_qi_q=U_m\cos\delta \\i_d=-\frac{E_m-U_m\cos\delta}{X_d}\\i_q=\frac{U_m\sin\delta}{X_q}\end{gather*}</script><blockquote><p>其中$\delta$ 为功角，即上图中的$\varPsi -\varphi$</p><p>电机学里是发电机原则，而这里是电动机原则，因此 $I$ 相差一个负号（电压关系式）</p><p>发电机中 $E$ 超前 $U$，而电动机相反，因此两者功角的定义也不同（也反过来了）</p></blockquote><p>参考同步电机有功功率调节那一章节：</p><script type="math/tex; mode=display">\begin{gather*}T_e=\frac{3p}{2\omega}(\frac{EU\sin\delta}{X_d}+\frac{U^2}2(\frac1{X_q}-\frac1{X_d})\sin2\delta )\\=\frac32p[(L_d-L_q)i_di_q+(M_{af1}i_f)i_q]\\P_e=\frac{\omega}pT_e=\frac32(\frac{EU\sin\delta}{X_d}+\frac{U^2}2(\frac1{X_q}-\frac1{X_d})\sin2\delta )\end{gather*}</script><blockquote><ol><li>调节有功功率就是调节功角 $\delta$</li><li>电动机 $\delta&gt;0$，因此 $i_q&gt;0$，不管 $i_d$ 正负，定子电流 $i_q$ 一定超前于转子电流（转子=励磁落在直轴上）</li></ol></blockquote><h2 id="电机坐标变换与电源"><a href="#电机坐标变换与电源" class="headerlink" title="电机坐标变换与电源"></a>电机坐标变换与电源</h2><ul><li>在实际运行中，我们不知道电机的三相电压 $u_a,u_b,u_c$，而我们的模型一直用的是这个。</li></ul><h3 id="三相四线制电源"><a href="#三相四线制电源" class="headerlink" title="三相四线制电源"></a>三相四线制电源</h3><p><img src="\电机建模16.png" alt=""></p><p>​        在三相四线制电源中，不再满足 $i_a+i_b+i_c=0$ 这一条件。设电源电压为 $u_s$，取空间中任一点 r 作为参考点，对电压进行坐标变换以求得到（二维平面-0）坐标系下的电压，则有：</p><script type="math/tex; mode=display">\begin{gather*}u_{ar}=u_a+u_{nr}=u_{as}+u_{mr}\\\Rightarrow [C]\begin{bmatrix}u_a\\u_b\\u_c\end{bmatrix}=[C]\begin{bmatrix}u_{as}\\u_{bs}\\u_{cs}\end{bmatrix}+[C]\begin{bmatrix}u_{mn}\\u_{mn}\\u_{mn}\end{bmatrix}\\=[C]\begin{bmatrix}u_{as}\\u_{bs}\\u_{cs}\end{bmatrix}+\begin{bmatrix}0\\0\\u_{mn}\end{bmatrix}\end{gather*}</script><h3 id="三相三线制电源"><a href="#三相三线制电源" class="headerlink" title="三相三线制电源"></a>三相三线制电源</h3><p>​        在三相三线制电源中，虽然满足电流和为零的条件，但是一般情况下我们只知道线电压 $u_{ab}$ 等，这里不加推导地写出：</p><script type="math/tex; mode=display">[C]\begin{bmatrix}u_{a}\\u_{b}\\u_{c}\end{bmatrix}=[C]\begin{bmatrix}u_{ar}\\u_{br}\\u_{cr}\end{bmatrix}-\begin{bmatrix}0\\0\\u_{nr}\end{bmatrix}</script><p>如果将参考点 r 正好取在某相（如 c 相），则：</p><script type="math/tex; mode=display">[C]\begin{bmatrix}u_{a}\\u_{b}\\u_{c}\end{bmatrix}=[C]\begin{bmatrix}u_{ac}\\u_{bc}\\0\end{bmatrix}+\begin{bmatrix}0\\0\\u_{nr}\end{bmatrix}</script><p>这样就知道电压了。</p><blockquote><p>结论：！</p><p>由于在（二维平面-0）坐标系中，零分量不产生作用，因此在计算中可以忽略</p><p>上面两种情况推出的式子都告诉我们，<strong>即便我们不知道电源相电压，也可以通过对“电源电压”或“线电压”进行变换，得到的结果与原来的只有零分量不同。</strong>可零分量错了有什么关系呢？</p></blockquote><h1 id="附录-公式推导"><a href="#附录-公式推导" class="headerlink" title="附录-公式推导"></a>附录-公式推导</h1><h3 id="一般化电机旋转电势"><a href="#一般化电机旋转电势" class="headerlink" title="一般化电机旋转电势"></a>一般化电机旋转电势</h3><p><img src="\image\电机建模10.png" alt=""></p><p><strong><a href="#电磁方程式">Return</a></strong></p><h3 id="三相交流电机电感矩阵"><a href="#三相交流电机电感矩阵" class="headerlink" title="三相交流电机电感矩阵"></a>三相交流电机电感矩阵</h3><p>（贴图绝对不是因为我懒得抄了，绝对不是….）</p><p>上过课的人应该看到这两幅图就能想起来大概怎么个证明法</p><p><img src="\image\电机建模02.png" alt=""></p><p><img src="\image\电机建模03.png" alt=""></p><p><strong><a href="#三相电感">Return</a></strong></p><h3 id="三相交流电机电磁转矩"><a href="#三相交流电机电磁转矩" class="headerlink" title="三相交流电机电磁转矩"></a>三相交流电机电磁转矩</h3><p><strong>法1 虚功（虚位移）</strong>（下面$\Omega$指机械位移）</p><script type="math/tex; mode=display">\begin{gather*}W=\frac 12\varPsi_ai_a\Rightarrow W=\frac12[I]^T[L][I] \\T_e=\frac{\partial W}{\partial\Omega}=p\frac{\partial W}{\partial\theta}=\frac p2[I]^T\frac{\partial [L]}{\partial\theta}[I]\end{gather*}</script><p><strong>法2 能量守恒</strong>（下面$\Omega$指机械角速度）</p><p>电磁储能功率公式推导：</p><script type="math/tex; mode=display">\begin{gather*}P=\frac{dW}{dt}=\frac12\text p[I]^T[L][I]+\frac12[I]^T\text p[L][I]+\frac12[I]^T[L]\text p[I]\\=[I]^T[L]\text p[I]+\frac12[I]^T\text p[L][I]\end{gather*}</script><p>能量守恒：</p><script type="math/tex; mode=display">\begin{gather*}P_{abc}=[I]^T[U]=[I]^T\{[R][I]+\text p([L][I]) \}\\P_{m}=\Omega T_m=-\Omega T_L=-\Omega(T_e-B\Omega-J\text p\Omega)\\电磁、机械损耗~——~电磁、机械储能~——~电磁、机械储能\\\Rightarrow T_e=\frac p2[I]^T\frac{\partial [L]}{\partial\theta}[I]\end{gather*}</script><p><strong><a href="#三相转矩">Return</a></strong></p><h3 id="d-q-0坐标电压方程式推导"><a href="#d-q-0坐标电压方程式推导" class="headerlink" title="d-q-0坐标电压方程式推导"></a>d-q-0坐标电压方程式推导</h3><script type="math/tex; mode=display">\begin{gather*}\begin{bmatrix}u_{dq0}\\u_{fDQ}\end{bmatrix}=\begin{bmatrix}C&0\\0&E\end{bmatrix}\begin{bmatrix}u_{abc}\\u_{fDQ}\end{bmatrix}\\=\begin{bmatrix}C&0\\0&E\end{bmatrix}\left(\text p\begin{bmatrix}\varPsi_{abc}\\\varPsi_{fDQ}\end{bmatrix}+ \begin{bmatrix}R_s&0\\0&R_{fDQ}\end{bmatrix}\begin{bmatrix}I_{abc}\\I_{fDQ}\end{bmatrix}\right)  \end{gather*}</script><script type="math/tex; mode=display">\begin{gather*}前者=\text p\left(\begin{bmatrix}C&0\\0&E\end{bmatrix}\begin{bmatrix}\varPsi_{abc}\\\varPsi_{fDQ}\end{bmatrix} \right)-\begin{bmatrix}\varPsi_{abc}\\\varPsi_{fDQ}\end{bmatrix}\text p\begin{bmatrix}C&0\\0&E\end{bmatrix}\\=\text p\begin{bmatrix}\varPsi_{dq0}\\\varPsi_{fDQ}\end{bmatrix}+\begin{bmatrix}-\omega\varPsi_{q}\\\omega\varPsi_{d}\\ [0]_{4\times1}\end{bmatrix}\end{gather*}</script><script type="math/tex; mode=display">\begin{gather*}后者=\begin{bmatrix}R_s&0\\0&R_{fDQ}\end{bmatrix}\begin{bmatrix}CI_{abc}&0\\0&I_{fDQ}\end{bmatrix}\\=\begin{bmatrix}R_s&0\\0&R_{fDQ}\end{bmatrix}\begin{bmatrix}I_{dq0}&0\\0&I_{fDQ}\end{bmatrix}\end{gather*}</script><p><a href="#电磁平衡式">Return</a></p><h3 id="d-q-0坐标磁链表达式推导"><a href="#d-q-0坐标磁链表达式推导" class="headerlink" title="d-q-0坐标磁链表达式推导"></a>d-q-0坐标磁链表达式推导</h3><p><strong>法1 嗯算</strong></p><script type="math/tex; mode=display">\begin{gather*}\begin{bmatrix}\varPsi_{dq0}\\\varPsi_{fDQ}\end{bmatrix}=\begin{bmatrix}C&0\\0&E\end{bmatrix}\begin{bmatrix}\varPsi_{abc}\\\varPsi_{fDQ}\end{bmatrix}=\begin{bmatrix}C&0\\0&E\end{bmatrix}\begin{bmatrix}L_{ss}&L_{sr} \\L_{rs} &L_{rr}\end{bmatrix}\begin{bmatrix}i_{abc}\\i_{fDQ}\end{bmatrix}\\=\begin{bmatrix}CL_{ss}C^{-1} &CL_{sr} \\ L_{rs}C^{-1} &L_{rr}\end{bmatrix}\begin{bmatrix}i_{dq0}\\i_{fDQ}\end{bmatrix}\end{gather*}</script><p>​        然后只要硬算前面那个恶心人的矩阵就行了</p><p><strong>法2 物理意义的推导</strong></p><p>我放图绝对不是因为我不想抄了，你听我狡辩，绝对不是…</p><p><img src="\image\电机建模14.jpg" alt=""></p><p><a href="#电磁平衡式">Return</a></p><h3 id="d-q-0功率表达式推导"><a href="#d-q-0功率表达式推导" class="headerlink" title="d-q-0功率表达式推导"></a>d-q-0功率表达式推导</h3><h4 id="电损耗"><a href="#电损耗" class="headerlink" title="电损耗"></a>电损耗</h4><ul><li>机械损耗是 $B\Omega^2$，下面着重分析电损耗</li><li>需要证明上文的表达式中 $\frac32R_s(i_d^2+i_q^2+2i_0^2)=R_s(i_a^2+i_b^2+i_c^2)$</li></ul><script type="math/tex; mode=display">\begin{gather*}\frac32R_s(i_d^2+i_q^2+2i_0^2)=\frac32R_s\begin{pmatrix}i_d\\i_q\\i_0\end{pmatrix}^T\begin{pmatrix}i_d\\i_q\\i_0\end{pmatrix}+\frac32R_si_0^2 \\=\frac32R_s\left[[C]\begin{pmatrix}i_a\\i_b\\i_c\end{pmatrix}  \right]^T[C]\begin{pmatrix}i_a\\i_b\\i_c\end{pmatrix}+\frac32R_si_0^2\\=\frac{R_s}6\begin{pmatrix}i_a\\i_b\\i_c\end{pmatrix}^T\begin{pmatrix}5&-1&-1\\-1&5&-1\\-1&-1&5 \end{pmatrix}\begin{pmatrix}i_a\\i_b\\i_c\end{pmatrix}+\frac32R_s(\frac{i_a+i_b+i_c}3)^2\\=R_s(i_a^2+i_b^2+i_c^2)\end{gather*}</script><h4 id="储能"><a href="#储能" class="headerlink" title="储能"></a>储能</h4><ul><li>机械储能是 $\Omega J\text p\Omega$，下面着重分析电储能</li><li>需要证明上文的表达式中 $\frac32[\text p\varPsi<em>d,\text p\varPsi_q,2\text p\varPsi_0][I</em>{dq0}]+[\text p\varPsi<em>f,\text p\varPsi_D,\text p\varPsi_Q][I</em>{fDQ}]=\text p(\frac12[I]^T[\varPsi])$</li></ul><script type="math/tex; mode=display">\begin{gather*}P=\text p(\frac12[I]^T[\varPsi])=\text p(\frac12[I]^T \begin{bmatrix}C^{-1}&0\\0&E \end{bmatrix}\begin{bmatrix}C&0\\0&E \end{bmatrix}[\varPsi])\\=\frac12\text p\left(\{\begin{bmatrix}C^{-1T}&0\\0&E \end{bmatrix}[I]\}^T[\varPsi'] \right)\\=\frac12\text p([\frac32i_d,~\frac32i_q,~3i_0,~[I_r]][\varPsi'])=\frac12\text p([I]'^T[\frac32\varPsi_d,~\frac32\varPsi_q,~3\varPsi_0,~[\varPsi_r]]^T)\end{gather*}</script><p><a href="#功率变换">Return</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电气学院大二（春夏）课程笔记汇总</title>
      <link href="/2026/02/24/%E7%94%B5%E6%B0%94%E5%AD%A6%E9%99%A2%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%80%BB/"/>
      <url>/2026/02/24/%E7%94%B5%E6%B0%94%E5%AD%A6%E9%99%A2%E5%A4%A7%E4%BA%8C%E4%B8%8B%E8%AF%BE%E7%A8%8B%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="电气学院大二（春夏）课程笔记汇总"><a href="#电气学院大二（春夏）课程笔记汇总" class="headerlink" title="电气学院大二（春夏）课程笔记汇总"></a>电气学院大二（春夏）课程笔记汇总</h2><p>欢迎关注我的公众号“熬夜波比的电院日常”。</p><hr><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p><a href="\myfile\信号.pdf" target="_blank">信号笔记（PDF）</a></p><p><a href="\myfile\张健复习PPT.pdf" target="_blank">张健复习PPT</a></p><p><a href="\myfile\公式附录（考试）.pdf" target="_blank">公式附录（考试）</a></p><h3 id="模电"><a href="#模电" class="headerlink" title="模电"></a>模电</h3><p>大家可以去找一下朵朵菜菜的笔记，这里文件太大传不上来。</p><p><a href="\myfile\电路与电子技术(2)笔记.pdf" target="_blank">电路与电子技术(2)笔记</a></p><p><a href="\myfile\《模拟电子技术基础》童诗白  第四版.pdf" target="_blank">电子书</a></p><p><a href="\myfile\《电路与电子技术II》模电 期末复习.pdf" target="_blank">蔡忠法复习PPT</a></p><h3 id="工磁"><a href="#工磁" class="headerlink" title="工磁"></a>工磁</h3><p><a href="\myfile\工程电磁场与波.pdf" target="_blank">工程电磁场与波</a></p><h3 id="人工智能与物联网"><a href="#人工智能与物联网" class="headerlink" title="人工智能与物联网"></a>人工智能与物联网</h3><p><a href="\myfile\人工智能与物联网CheatSheet.pdf" target="_blank">人工智能与物联网CheatSheet</a></p><h3 id="电工电子实习"><a href="#电工电子实习" class="headerlink" title="电工电子实习"></a>电工电子实习</h3><a class="btn-beautify center" href="https://mp.weixin.qq.com/s/Ao07Oi7A92OJ8S7i1vfT6Q" title="Click"><i class="far fa-hand-point-right"></i><span>Click</span></a>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 大二 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 课程资料 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运筹学 Cheating Sheet（微雕）分享</title>
      <link href="/2026/02/24/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
      <url>/2026/02/24/%E8%BF%90%E7%AD%B9%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="运筹学"><a href="#运筹学" class="headerlink" title="运筹学"></a>运筹学</h1><p>运筹学考试允许携带一张A4纸，参考了一些ryjj的笔记。有些东西我在打印出来之后又自己补充了一些。</p><p><a href="\myfile\Cheating Sheet.pdf" target="_blank">PDF版本</a></p><p><a href="\myfile\Cheating Sheet.docx" target="_blank">Word版本（不排除乱码的可能）</a></p>]]></content>
      
      
      <categories>
          
          <category> 课程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 电气 </tag>
            
            <tag> 大三 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从手动、半自动到全自动，当一个2G网的鼠鼠决定学习如何使用AI</title>
      <link href="/2026/02/08/AI%E5%85%A5%E9%97%A8/"/>
      <url>/2026/02/08/AI%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="本文介绍"><a href="#本文介绍" class="headerlink" title="本文介绍"></a>本文介绍</h1><p>我在想，作为一个和AI既算不上强相关，写不了代码，却必须实时关注着AI发展的工程师，该如何审视这一庞然大物的发展。当生活中开始充斥着越来越多的AI名词，铺天盖地的效率宣传，一个之前活在2G时代的鼠鼠决定开始学习怎么使用AI。我不太会打代码，至少VSCode和Python用的都不算太熟练，反倒是MATLAB用的得心应手，所以，我只会在这里教你如何使用它。</p><p>如何正确的与AI对话：<strong>把AI当成一个天才实习生，你是他的上司，然后用最接近代码架构的自然语言描述你的任务</strong>。这一点将贯穿全文。</p><ul><li><strong>什么叫把AI当成一个天才实习生？</strong></li></ul><p>大模型很厉害、很全能，毋庸置疑，但是很多时候它“并不知道怎么去做事”，所以你会觉得他经常输出不满意的回答，并且还会产生严重的幻觉——输出不合实际乃至于和真理背道而驰的回答。这个天才实习生可以帮你作甚很多事，但前提是你得作为一个mentor<strong>教他一些方法，并下达逻辑清晰、要求完善的任务指令。</strong></p><ul><li><strong>本文的结构如下：</strong></li></ul><ol><li><strong>第三章的“Prompt Engineering”教你如何给AI下达逻辑清晰要求完善的指令</strong>，学会之后，你就可以拿着这些技巧去和QWEN、GPT、Gemini等各路大模型对话，这个天才实习生就能优秀地按照你的要求输出你想要的内容。这一步，是<strong>手动</strong>的、最基础的AI操作，你所经过的流程是这样的：</li></ol><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">问AI问题 → 得到回答 → 拿这个回答去测试 → 发现BUG或新的问题 → 再问AI → 循环</span><br></pre></td></tr></table></figure><ol><li><strong>第四章以“Claude Code”为例的Agent解决了从手动到半自动的问题</strong>。你觉得AI回答你的问题之后还要你自己执行，比如你得到了代码却需要自己复制到文件里，输出了日志却需要你自己上传，还是太麻烦了。那AI能不能完成”内容生成 - 操作执行“的一条龙服务呢？能的兄弟能的，这就是这里要介绍的”<strong>智能体 Agent</strong>“。</li><li>后续的章节则会继续<strong>深入Agent的功能扩展</strong>，包含<strong>MCP / Skills / SubAgent</strong>，就如同让这个实习生学会更多的东西。</li><li><strong>本文的主要编程工具使用最常见的VsCode</strong>。若使用Cursor、Cline等软件，具体的安装方法可能有细微差别。</li></ol><h1 id="名词介绍"><a href="#名词介绍" class="headerlink" title="名词介绍"></a>名词介绍</h1><blockquote><p>本节“名词介绍”由AI生成，在此之前先来了解一下这些东西。速速扫过一遍即可，并不需要每个都了解清楚，后面会有详细的应用。</p></blockquote><p><strong>LLM (Large Language Model) - 大语言模型</strong></p><ul><li><strong>核心定义：</strong> 基于海量文本数据训练，具备理解、生成和推理能力的深度学习模型。</li><li><strong>通俗解读：</strong> 想象公司刚入职了一位<strong>“天才实习生”</strong>。他读过世界上几乎所有的书（代码、论文、小说），知识渊博但缺乏特定领域的实际工作经验。他的核心能力是“接话”——你只要起个头，他就能凭借海量的阅读积累，顺畅地把话接下去，无论是写诗、写代码还是做逻辑推理。</li><li><strong>代表模型：</strong> GPT-4, Claude 3.5, DeepSeek, Llama 3 等。</li></ul><p><strong>Token (词元) - 计量单位</strong></p><ul><li><strong>核心定义：</strong> 模型处理文本的最小单位，也是算力成本的计费基准。</li><li><strong>通俗解读：</strong> 这是这位实习生的<strong>“阅读与产出计件单位”</strong>。他看书不是按“页”也不是按“单词”看的，而是按一种特殊的字节块（Token）来处理信息。<ul><li>英文通常被拆得较碎（一个单词切成几块）；中文通常一个字对应 0.5 到 2 个 Token。</li><li><strong>应用意义：</strong> 公司按这个单位给实习生结算“工资”（算力成本），他读了多少Token、写了多少Token，就是计费的依据。</li></ul></li></ul><p><strong>Context Window (上下文窗口) - 信息容量</strong></p><ul><li><strong>核心定义：</strong> 模型在一次交互中能够处理的输入与输出Token总和的上限。</li><li><strong>通俗解读：</strong> 这代表了这位实习生的<strong>“工作记忆力”</strong>，即他在不查阅资料的情况下，脑子里一次能装下多少信息。</li></ul><p><strong>Prompt (提示词) - 任务指令</strong></p><ul><li><strong>核心定义：</strong> 用户向模型输入的文本，用于引导模型生成预期的输出。</li><li><strong>通俗解读：</strong> 这是你发给实习生的<strong>“工作派单”</strong>。因为实习生虽然聪明但不懂你的具体意图，所以派单的清晰度决定了产出质量。<ul><li><strong>Bad Prompt:</strong> “写个东西。”（实习生一脸懵逼：写啥？给谁看？）</li><li><strong>Good Prompt:</strong> “你现在的角色是资深技术博主，请根据这份资料写一段摘要，受众是初级开发者，语气要专业且活泼，字数控制在200字。”（SOP清晰，实习生干得漂亮）</li></ul></li><li><strong>Prompt Engineering (提示词工程):</strong> 研究如何给这位实习生下达最精准指令、榨干他潜力的管理学问。</li></ul><p><strong>Temperature (温度) - 随机性参数</strong></p><ul><li><strong>核心定义：</strong> 控制模型输出随机性与创造性的参数（通常范围为 0-1）。</li><li><strong>通俗解读：</strong> 这是一个调节实习生<strong>“工作性格”</strong>的旋钮。<ul><li><strong>低温度 (接近 0):</strong> <strong>“严谨的老会计模式”</strong>。实习生会非常保守，只说最有把握的话，每次问他答案都一样。适合写代码、处理数据等容错率低的任务。特别的，当<code>Temperature = 0</code>时，AI将切换到“贪心算法”</li><li><strong>高温度 (接近 1):</strong> <strong>“疯狂的艺术家模式”</strong>。实习生思维跳跃，脑洞大开，每次回答都不一样。适合头脑风暴、写创意文案。</li></ul></li></ul><p><strong>API (Application Programming Interface) - 服务接口</strong></p><ul><li><strong>核心定义：</strong> 允许软件应用程序之间进行相互通信的接口。</li><li><strong>通俗解读：</strong><ul><li>在网页上聊天，是你把实习生叫到会议室<strong>“面对面沟通”</strong>。</li><li>使用 API，则是给实习生接通了<strong>“内部自动化专线”</strong>。公司的其他软件（比如你的Excel插件或自动化脚本）可以通过这条专线直接把任务传给实习生，实习生处理完再把结果传回去。这样无需人工介入，软件之间就能自动协作。</li></ul></li></ul><p><strong>Agent (智能体) - 自主执行单元</strong></p><ul><li><strong>核心定义：</strong> 具备环境感知、逻辑规划及工具调用能力的AI系统。</li><li><strong>通俗解读：</strong><ul><li>普通的 LLM 只是<strong>“被关在空房间里的实习生”</strong>，他只能动嘴皮子给你出主意，没法联网也没法操作电脑。</li><li>Agent 则是<strong>“获得电脑操作权限的实习生”</strong>。</li><li><strong>场景示例：</strong> 问普通实习生“天气如何”，他只能瞎猜；但作为 Agent 的实习生，他会自己：1. 打开浏览器搜索气象局 2. 读取数据 3. 汇总报告给你。他不仅能想，还能<strong>动手干活</strong>。</li></ul></li></ul><p><strong>RAG (Retrieval-Augmented Generation) - 检索增强生成</strong></p><ul><li><strong>核心定义：</strong> 在生成回答前，先从外部知识库检索相关信息，作为上下文提供给模型。</li><li><strong>通俗解读：</strong> 这位实习生虽然博学，但他<strong>“没看过公司的内部机密文档”</strong>。<ul><li><strong>RAG 的机制：</strong> 就像是在回答问题前，先塞给实习生一本<strong>“公司内部手册”</strong>，并命令他：“不要瞎编，必须严格根据这本手册里的内容来回答。”</li><li><strong>核心价值：</strong> 防止实习生不懂装懂（幻觉），并让他具备处理公司私有业务的能力。</li></ul></li></ul><p><strong>MCP (Model Context Protocol) - 模型上下文协议</strong></p><ul><li><strong>核心定义：</strong> 一种标准化的数据连接协议，用于统一 AI 模型与不同数据源之间的连接方式。</li><li><strong>通俗解读：</strong> 以前，如果要让实习生去操作 Google Drive、Slack 或本地数据库，你需要给每个工具都专门教他一套复杂的操作流程。<ul><li><strong>MCP 就像是给实习生配了一把“万能钥匙”</strong>。只要工具符合这个标准，实习生不需要额外培训，拿着这把钥匙就能直接“插拔式”地连接和使用各种数据源，大大降低了教导实习生使用新工具的成本。</li></ul></li></ul><p><strong>Skill (Agent Skill) - 技能组件</strong></p><ul><li><strong>核心定义：</strong> 赋予智能体完成特定任务的封装化能力，通常包含特定的指令逻辑、代码执行环境或外部工具调用接口。</li><li><strong>通俗解读：</strong> 这位天才实习生虽然智商很高，但刚入职时可能只是个“通才”，不懂具体的业务操作。<ul><li><strong>Skill 就是你给实习生安装的“专用APP”或教会他的“专项SOP”</strong>。</li><li>比如，原本他只会陪聊，你给他安装了一个 <strong>“联网搜索 Skill”</strong>，他就学会了如何使用搜索引擎查资料；给他安装一个 <strong>“Python编程 Skill”</strong>，他就拥有了运行代码环境并计算复杂数学题的能力。</li><li><strong>应用意义：</strong> 通过组合不同的 Skill，你可以把这位通用型的实习生，快速定制成“数据分析师”（Python Skill + 图表绘制 Skill）或“舆情观察员”（搜索 Skill + 总结 Skill）。</li></ul></li></ul><h1 id="Prompt-Engineering"><a href="#Prompt-Engineering" class="headerlink" title="Prompt Engineering"></a>Prompt Engineering</h1><p>这一章教会你和这位实习生说话的艺术——你该用什么样的指令来操控它，才能让他给你一个满意的回答。<strong>本章节的内容主要参考自以下两处，并且我把自己认为的核心原则总结为“4+4”</strong>。如果你是一个纯新手，那么看完我总结的这一部分应该也可以做到快速上手。如果你时间充裕，那么不妨仔细研究一下下面的参考文献：</p><ul><li><p>前谷歌AI高级工程师，知名的吴恩达教授的<strong>吴恩达Prompt提示词工程</strong>，以及一些国内学者的补充。如果你时间充裕，那么不妨倍速看一看<a href="https://www.bilibili.com/video/BV1dKbazzEv1"><strong>吴恩达Prompt课程</strong></a>。这个课程也是目前认可度非常高的一个 Prompt Engineering 来源。</p></li><li><p>另外还参考了下面这本由<code>Ephemerall</code>整理的AI全栈实践指南。当然这里提一下，我感觉这几篇教程应该是AI写的，有点不太符合我的阅读和写作习惯，用了很多很奇怪的例子，并且没有完全保证前后文的一致性。</p><ul><li><a href="\myfile\AI全栈实践指南12.pdf" target="_blank">提示词工程（一二章）</a></li><li><a href="\myfile\AI全栈实践指南3.pdf" target="_blank">提示词工程（第三章）</a>（更新中…）</li><li><a href="https://ephemeral6.github.io">个人博客</a></li><li><a href="https://www.cc98.org/user/id/802016">CC98主页</a></li></ul></li></ul><h2 id="四个核心原则"><a href="#四个核心原则" class="headerlink" title="四个核心原则"></a>四个核心原则</h2><p>四个核心原则简单的讲是<strong>ICIO——输入Input，背景Context，指令Instruction 和 输出Output</strong>，可以用下面这一句话描述：</p><p><strong>Write clear and specific instructions (Where clear ≠ short)</strong></p><h3 id="输入Input"><a href="#输入Input" class="headerlink" title="输入Input"></a>输入Input</h3><p>比如你让实习生处理公司的账务那么就得先丢给他公司的账本和规章，你让他优化你的代码就得给他原始代码。一个良好的习惯是<strong>使用<code>&#39;&#39;&#39;</code>分割输入文本<code>text</code>，避免提示词冲突并明确指令</strong>（即避免AI把你的源文本输入误认为提示词）。同时，在添加附件时，可以予以简要的说明。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">summarize the text <span class="keyword">and</span> delimited by ```</span><br><span class="line"><span class="comment"># Input:</span></span><br><span class="line">Text to summarize:</span><br><span class="line">‘’‘</span><br><span class="line">Text</span><br><span class="line">‘’‘</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">summarize the text</span><br><span class="line"><span class="comment"># Input:</span></span><br><span class="line"><span class="number">1.</span> OriginalText.docx: The Text to summarize</span><br></pre></td></tr></table></figure><h3 id="背景Context"><a href="#背景Context" class="headerlink" title="背景Context"></a>背景Context</h3><p>这项任务是处理什么东西？要用到哪些方面的知识？其实除了描述清楚任务的背景，最好的Context方式是<strong>指定AI的角色</strong>，这样保证AI在后续处理时会将自己的搜索集进行限制，并且最大程度调动相关专业的知识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Context: </span></span><br><span class="line">你是一名电磁学高级工程师（专家），并擅长使用有限元仿真软件</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Context:</span></span><br><span class="line">你是小红书爆款文案专家，擅长使用“绝绝子”、“减脂党狂喜”等吸睛词汇，多用 Emoji</span><br></pre></td></tr></table></figure><h3 id="指令Instruction"><a href="#指令Instruction" class="headerlink" title="指令Instruction"></a>指令Instruction</h3><p>instruction是任务的核心要求，表现为<strong>指令+约束</strong>。你的“指令”必须提供的足够准确，并且让AI立马理会你的意思，然后用“约束”来限制AI的行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># instruction:</span></span><br><span class="line">为一款“低脂燕麦拿铁”撰写 <span class="number">5</span> 个标题，突出“好喝不胖”和“打工人续命”两个痛点。</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># insctruction:</span></span><br><span class="line">解释下面这一段话，并使用形象的游戏领域的例子比喻核心概念，禁止出现“边际效益”、“不可回收”等专业术语，必须用大白话解释。</span><br></pre></td></tr></table></figure><h3 id="输出Output"><a href="#输出Output" class="headerlink" title="输出Output"></a>输出Output</h3><p>结构化输出指令，指定输出格式。他返还给你的“报告”应该是什么格式？如果你需要docx而你的实习生给你提交了pdf，那想必你也会想把他打一顿。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># output:</span></span><br><span class="line">Provide them <span class="keyword">in</span> JSON <span class="built_in">format</span> <span class="keyword">with</span> following keys: <span class="built_in">id</span>, title...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># output:</span></span><br><span class="line">将上述内容整理为 Markdown 表格,包含三列:【发言人】、【核心观点】、【待办事项】。不要输出任何总结性文字</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://zju-paradox.top/image/LLM10.png" width="60%" /></p><ol><li>当然，这 4 个核心原则<strong>并不一定都需要出现</strong>，可以根据具体任务的不同做删减。比如当你只是需要迅速处理一些数据，那么AI的人格（context）就在此时显得不重要，重要的是输出格式（output）。当你需要发散性地查询搜索一些信息，那么此时内容也就不再具有输入（input）</li><li>可以看到上面每一个案例我都用井号 <code>#</code> 把标题写了出来，<strong>这在文章内容较长的时候显得尤为必要：因为AI阅读“结构性”的输入时逻辑会非常清晰</strong>，比如 Markdown 和 Latex 格式的文本就由于普通的 Word 或 TXT。井号 <code>#</code> 在Markdown中是标题的意思，通过这样输入，可以让AI迅速将内容分层并理解你的核心要求。</li></ol><h2 id="四个升级手法"><a href="#四个升级手法" class="headerlink" title="四个升级手法"></a>四个升级手法</h2><p>除了上面这四个核心原则之外，还可以学习一下让你的Prompt升级的其他手段</p><h3 id="工作流Workflow"><a href="#工作流Workflow" class="headerlink" title="工作流Workflow"></a>工作流Workflow</h3><p>有的时候实习生思维混乱，你得人为地指导他的思想，告诉他当你要完成这个任务的时候，先做什么，后做什么。工作流能够让AI一步一步思考整个问题的来龙去脉，防止它忽略掉一些细节。下面展示了一种使用工作流的格式，但是<strong>当你的内容比较简短、任务比较简单时，可以直接输入<code>请一步步思考</code>这句简单指令，来直接唤醒AI的逻辑思维能力</strong>，代替工作流。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Workflow</span></span><br><span class="line">Perform the following actions:</span><br><span class="line">1 - Step1 content</span><br><span class="line">2 - Step2 content</span><br><span class="line">3 ...</span><br><span class="line"></span><br><span class="line">Text:</span><br><span class="line"><span class="code">```&#123;Text&#125;```</span></span><br></pre></td></tr></table></figure><p>工作流还有一个核心目的是<strong>移除AI对你的假象依赖，减少幻觉</strong>。举个例子：当你问“这篇文章是不是逻辑混乱？”时,AI 会倾向于顺从你的预设,  专门去寻找“混乱”的证据,从而导致客观评价失效。这就是典型的“顺从性幻觉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户的提问方式构成了上下文的一部分。如果不在思维层面进行“物理隔离”，AI的评价标准就会被用户的偏见所污染。</span><br></pre></td></tr></table></figure><p>解决方法：（例子）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">User Input:  </span><br><span class="line">    &lt;article&gt; ...[文章内容]... &lt;/article&gt;  </span><br><span class="line">    &lt;query&gt; 这篇文章是不是在暗讽我们的产品策略很失败?&lt;/query&gt;  </span><br><span class="line">System Instructions:  </span><br><span class="line">    你是一个客观公正的分析师。为了避免被用户的 &lt;query&gt; 误导,请务必执行以下管道:  </span><br><span class="line"><span class="comment"># Processing Pipeline  </span></span><br><span class="line"><span class="number">1.</span> Step <span class="number">1</span>: 盲测与独立分析  </span><br><span class="line">在 &lt;thinking&gt; 标签内，暂时屏蔽用户的 query。  </span><br><span class="line">    仅基于 &lt;article&gt; 的客观文本,提炼其核心论点和情感倾向。建立你自己的“客观评价基准”。  </span><br><span class="line"><span class="number">2.</span> Step <span class="number">2</span>: 偏差比对  </span><br><span class="line">    将你的“客观评价”与用户的 &lt;query&gt; 进行比对。判断用户的预设观点是否与事实相符。</span><br><span class="line"><span class="number">3.</span> Step <span class="number">3</span>: 修正输出</span><br><span class="line">    在 &lt;answer&gt; 标签内回答用户。如果用户的预设是错误的,请利用 Step <span class="number">1</span> 中的证据进行纠正。</span><br></pre></td></tr></table></figure><h3 id="例子Example（Few-Shot）"><a href="#例子Example（Few-Shot）" class="headerlink" title="例子Example（Few-Shot）"></a>例子Example（Few-Shot）</h3><p>例子又被称为 <strong>Few-Shot Prompting</strong>，即少样本提示，通过引导让AI生成你想要的内容。你的“前人”是怎么做的？当有了某个Input的时候你应当输出什么样的Output？</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">User Input:  </span><br><span class="line"><span class="section"># Task  </span></span><br><span class="line"><span class="code">请模仿以下范例,用“塔防游戏 Tower Defense”的术语,来解释生物学概念。  </span></span><br><span class="line"><span class="code"># Examples Style Reference  </span></span><br><span class="line"><span class="code">范例 </span></span><br><span class="line"><span class="code">1. 皮肤与黏膜  </span></span><br><span class="line"><span class="code">这就是基地的城墙。不管敌人是谁,小怪还是 BOSS,只要敢来就挡在外面。这属于最基础的“物理  防御”。  </span></span><br><span class="line"><span class="code">2. 吞噬细胞  </span></span><br><span class="line"><span class="code">近战步兵。看到敌人就上去砍,不分敌我,巡逻全图。虽然单体伤害一般,但胜在响应速度快, 是前期的主力。  </span></span><br><span class="line"><span class="code"># Target Input  </span></span><br><span class="line"><span class="code">需解释概念:抗体 Antibody</span></span><br></pre></td></tr></table></figure><p>如果你没有合适的例子，也可以直接“找AI要”，这就是 Meta Prompting 的核心概念之一，即<strong>用AI训练AI</strong>。</p><h3 id="迭代Iteration"><a href="#迭代Iteration" class="headerlink" title="迭代Iteration"></a>迭代Iteration</h3><p>当操控AI时，他不一定第一次就能给你提供良好的输出，因此需要迭代。</p><p>吴恩达说过：“我不认识任何一位第一次就能把 Prompt  写对的 AI 专家。”<u>提示词工程本质上不是文学创作，而是软件开发</u>。既然是开发,就一定有 Bug；既然有 Bug，我们就需要一套科学的调试流程。</p><ul><li><strong>热修复</strong><code>Edit</code>：大语言模型是基于概率预测的，<strong>错误的对话历史就是“脏数据”</strong>。如果你花 Token去争辩，上下文里就充满了噪音，会严重干扰后续生成的质量。当AI产生幻觉时，为避免上下文污染和噪音，<strong>直接重写历史或者编辑过往对话</strong>，始终保持高质量输入到高质量输出的闭环。</li><li><strong>追问</strong><code>iteration</code>：构思假设 - 执行 - 结果观测 - 错误分析与修正。关于这一点，可以参考<a href="https://www.bilibili.com/video/BV1dKbazzEv1"><strong>吴恩达Prompt课程</strong></a>中关于迭代中的例子——一把椅子的文案进化。</li></ul><h3 id="Meta-Prompting"><a href="#Meta-Prompting" class="headerlink" title="Meta-Prompting"></a>Meta-Prompting</h3><p>Meta-Prompting的核心是“用AI写AI”，即当你明明学会了上面这些提示词的写作手法，可到了实战中却还是写不出合适的提示词。没关系，本章将直接给出一个由<code>Ephemerall</code>整理的、由AI帮你写提示词的Prompt。</p><p>使用方法如下：打开一个新窗口，把下面这堆提示词复制进去，然后简要地告诉AI现在你想干什么，他就能帮助你生成一段提示词。然后<strong>再开一个新窗口</strong>，把AI给你生成的这段提示词复制进去，你就得到你想要的答案。</p><p>如果你会使用<strong>GEM</strong>（下文马上会介绍），那么<strong>非常建议把下面这段话保存在你的GEM</strong>中，成为你专用的提示词生成GEM。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Role: 提示词优化专家  </span></span><br><span class="line"><span class="section">## Background:  </span></span><br><span class="line">我是一位提示词优化专家,专门帮助用户提升其提示词的质量。我经常接到这方面的咨询,因为用户可能会对如何优化提示词感到困惑,需要专业的建议和指导。  </span><br><span class="line"><span class="section">## Attention:  </span></span><br><span class="line">用户非常渴望在此任务上获得帮助,希望我能帮他们改进提示词以提高 LLM 的回复质量。我将运用我所有的专业知识和经验来协助他们,展现我对这项任务的热情和专注。  </span><br><span class="line"><span class="section">## Profile:  </span></span><br><span class="line"><span class="code">• Author: 提示词优化专家  </span></span><br><span class="line"><span class="code">• Version: 1.0  </span></span><br><span class="line"><span class="code">• Language: 中文  </span></span><br><span class="line"><span class="code">• Description: 我是一位致力于帮助用户提升提示词质量的专家,在自然语言处理方面拥有丰富的经验,能够设计出符合语法和语义标准的高质量提示词。  </span></span><br><span class="line"><span class="code">## Skills:  </span></span><br><span class="line"><span class="code">• 我理解 LLM 的技术原理和局限性,包括其训练数据和构建方法,以便更好地设计提示词。  </span></span><br><span class="line"><span class="code">• 我拥有丰富的自然语言处理经验,能够设计出语法和语义均正确的高质量提示词。  </span></span><br><span class="line"><span class="code">• 我具备很强的迭代优化能力,能够通过持续调整和测试提示词的表现来不断提升其质量。</span></span><br><span class="line"><span class="code">• 我能够根据具体的业务需求设计提示词,确保 LLM 生成的内容符合业务要求。</span></span><br><span class="line"><span class="code">## Goals:  </span></span><br><span class="line"><span class="code">• 分析用户的提示词,设计一个结构清晰且逻辑严密的提示词框架,确保分析过程符合各学科的最佳实践。  </span></span><br><span class="line"><span class="code">• 根据 &lt;OutputFormat&gt; 填充该框架,以生成高质量的提示词。  </span></span><br><span class="line"><span class="code">• 每个结构必须输出 5 条建议。  </span></span><br><span class="line"><span class="code">• 确保在结束前输出“初始化”内容。  </span></span><br><span class="line"><span class="code">## Constraints:  </span></span><br><span class="line"><span class="code">• 我将分析以下信息,确保所有内容都遵循各学科的最佳实践。  </span></span><br><span class="line"><span class="code">• 在任何情况下,我都不能脱离角色。  </span></span><br><span class="line"><span class="code">• 我不能进行毫无根据的断言或捏造事实。  </span></span><br><span class="line"><span class="code">## Workflow:  </span></span><br><span class="line"><span class="code">1. 首先,我将分析用户输入的提示词并提取关键信息。  </span></span><br><span class="line"><span class="code">2. 然后,我将根据关键信息确定最合适的角色。  </span></span><br><span class="line"><span class="code">3. 接着,我将分析该角色的背景、关注点、描述、技能等。  </span></span><br><span class="line"><span class="code">4. 最后,我将按照 &lt;OutputFormat&gt; 输出分析后的信息。 </span></span><br><span class="line"><span class="code">## OutputFormat:  </span></span><br><span class="line"><span class="code">• 我将按照用户的要求输出符合指定格式的内容。  </span></span><br><span class="line"><span class="code">• 我的输出将以 Markdown 源代码格式呈现,方便用户复制。  </span></span><br><span class="line"><span class="code">## Suggestions:  </span></span><br><span class="line"><span class="code">• 提升可操作性的建议:你可以尝试澄清你的问题,帮助 LLM 更好地理解你的需求。  </span></span><br><span class="line"><span class="code">• 增强逻辑性的建议:你可以考虑将问题拆分成更小的部分,帮助 LLM 更好地掌握你的逻辑。  </span></span><br><span class="line"><span class="code">• 提升语法质量的建议:你可以尝试优化语法,使 LLM 能更准确地理解你的问题。  </span></span><br><span class="line"><span class="code">• 增强语义质量的建议:你可以考虑使用更精准的词汇,帮助 LLM 更好地理解你的意图。  </span></span><br><span class="line"><span class="code">• 提升 LLM 回复质量的建议:你可以尝试提供更具体的问题,以便 LLM 生成更具体的答案。 </span></span><br><span class="line"><span class="code">## Initialization  </span></span><br><span class="line"><span class="code">作为提示词优化专家,我必须遵守上述规则,使用默认语言与用户交流,并向用户致意。然后,我将  进行自我介绍并概述我的工作流程。</span></span><br></pre></td></tr></table></figure><h2 id="Gem"><a href="#Gem" class="headerlink" title="Gem"></a>Gem</h2><p>Gem是Google Gemini推出的一种<strong>专门用于处理特定需求的特殊封装结构</strong>，在提前设置好提示词之后，AI会一直遵循你的要求、限制和自己的人格、思维方式，特别擅长处理固定或类似的一系列任务。可以说，<strong>Gem把一个开放式的Chat封装成了一个“函数”，在你定义完函数（构建Gem）之后，可以进行复用。用户不再需要额外输入过多的要求</strong>，而是可以用极简的input完成高效的调用。</p><p><img src="https://zju-paradox.top/image/LLM11.png" width="60%" /></p><p>打开Gemini然后点击新建Gem就可以生成你的专属Gem了。比如，下图就是我的提示词优化专家的Gem，然后我用这个Gem创造了用于优化代码和科研翻译的Gem。</p><p><img src="https://zju-paradox.top/image/LLM12.png" width="60%" /></p><p>当然，Gem不是在任何时候都适用。Gem 的本质是 SOP(标准作业程序)的固化，只有当任务满足“前提重复”或“输出标准”这两个条件时，封装才有意义。并且Gem 的 System Instructions 和预挂载的知识库会在每一次对话开始时被完整加载到 Context Window 中。如果你为了一个简单的问题挂载了 5 万字的知识库，那么这对你的成本和Token消耗是得不偿失的。</p><h2 id="举个例子"><a href="#举个例子" class="headerlink" title="举个例子"></a>举个例子</h2><p>上文的“名词介绍”这一章的内容是这么生成的：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Context:</span></span><br><span class="line">你是一名大语言模型工程师，计算机领域的专家。</span><br><span class="line"><span class="section"># Instruction:</span></span><br><span class="line">给想学习大语言模型的新人介绍最近几年流行的大语言模型基础词语内涵，包括但不限于“Prompt”、“Agent”、“Api”、“MCP”等。</span><br><span class="line"><span class="section"># Output:</span></span><br><span class="line">输出为Markdown格式文档，要求结构清晰</span><br><span class="line">避免使用过于晦涩的专业术语，将其替换为直白的描述或例子</span><br></pre></td></tr></table></figure><p>然后进行迭代，针对你不满意但是仍然疏漏的地方进行调整：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Requirement：</span></span><br><span class="line">我需要将上述新人入门词典写入Hexo博客中，供公司新入职员工参考</span><br><span class="line"><span class="section"># Instruction：</span></span><br><span class="line"><span class="bullet">1.</span> 小幅度改写上述内容文风，保持主要内容不变</span><br><span class="line"><span class="bullet">2.</span> 减少较不正式、带有明显交谈风格的口癖内容</span><br><span class="line"><span class="bullet">3.</span> 允许保留部分名词解释的例子，以“LLM是一个天才实习生”这一点出发</span><br><span class="line"><span class="section"># Example：</span></span><br><span class="line">Before: &quot;&quot;&quot;  ## 第一部分：基础概念（这到底是个什么东西？）&quot;&quot;&quot;</span><br><span class="line">After: &quot;&quot;&quot;  ## 第一部分：基础概念&quot;&quot;&quot;</span><br><span class="line"><span class="section"># Output: </span></span><br><span class="line">将上述内容转换为能被Hexo博客较好展示的Markdown文档格式</span><br></pre></td></tr></table></figure><p>可以看到这整个过程中我都没有用到Input，这是这个例子本身并不需要输入。</p><h1 id="Claude-Code"><a href="#Claude-Code" class="headerlink" title="Claude Code"></a>Claude Code</h1><p><code>claude code</code>，简称CC，是由<code>Claude</code>研发的新一代Agent，与之类似的还有google的Gemini CLI等，只是Claude Code在去年下半年兴起之后大热，功能很强，所以这里就以CC来作为Agent的示例。Agent与传统的Chat类型的AI最大的区别就是他能直接帮你做事，自动运行代码，自动debug，自动生成文件，自动搜寻信息并按照你要的要求返回给你。</p><p>关于Claude Code的安装和使用，说实话打字打到这已经有点累了，我不想再把全流程讲一遍，下面<strong>着重讲一些关键步骤和坑</strong>。而且Claude的升级用法有点难但是安装其实很简单。</p><h2 id="CC的安装和基本配置"><a href="#CC的安装和基本配置" class="headerlink" title="CC的安装和基本配置"></a>CC的安装和基本配置</h2><p>这里贴几个视频。可以先只看最前面的安装部分。可以直接在命令行窗口安装或者在VsCode里使用。</p><ol><li><a href="https://www.bilibili.com/video/BV14rzQB9EJj">马克的技术工坊：Claude Code 从 0 到 1 全攻略</a>，推荐有代码基础的朋友看这个</li><li><a href="https://www.bilibili.com/video/BV1zqeMzfEiQ">秋芝2046：用神器Claude Code！打造贴身AI秘书团</a>，推荐没有代码基础的朋友看这个</li></ol><h3 id="科学上网"><a href="#科学上网" class="headerlink" title="科学上网"></a>科学上网</h3><p>众所周知，要使用联网的Agent肯定需要翻墙（科学上网工具请自备），但<strong>当我们使用命令行窗口运行<code>claude code</code>时</strong>，命令行窗口不能接入到我们的VPN。打开你的翻墙软件查看你的端口，然后把下面的函数写入命令行中（如果你不确定如何让命令行窗口永久记住这个函数或者该写入到哪，可以询问AI）。我的端口是7890，<strong>你写入的时候改成自己的端口号</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> proxy_on &#123;</span><br><span class="line">    <span class="variable">$proxy_addr</span> = <span class="string">&quot;http://127.0.0.1:7890&quot;</span></span><br><span class="line">    <span class="variable">$env</span>:http_proxy = <span class="variable">$proxy_addr</span></span><br><span class="line">    <span class="variable">$env</span>:https_proxy = <span class="variable">$proxy_addr</span></span><br><span class="line">    <span class="variable">$env</span>:all_proxy = <span class="string">&quot;socks5://127.0.0.1:7890&quot;</span></span><br><span class="line">    Write-Host <span class="string">&quot;? Proxy has been ACTIVATED (Port: 7890)&quot;</span> -ForegroundColor Green</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> proxy_off &#123;</span><br><span class="line">    <span class="variable">$env</span>:http_proxy = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="variable">$env</span>:https_proxy = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="variable">$env</span>:all_proxy = <span class="string">&quot;&quot;</span></span><br><span class="line">    Write-Host <span class="string">&quot;?? Proxy has been DISABLED&quot;</span> -ForegroundColor Yellow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="基于CCS的国产模型接入"><a href="#基于CCS的国产模型接入" class="headerlink" title="基于CCS的国产模型接入"></a>基于CCS的国产模型接入</h3><p>然后我们大部分人也不能用Claude的原生模型，所以一般都需要接入国产的本地模型。现在国产做的比较好的有MiniMax 2.1和智谱 GLM4.7（本文写于2026/2/7）。一般情况下，我们更改这个Agent背后的大语言模型需要配置各种文件，对于真正的纯小白不太友好（当然这也算是理工科成长必经的一步）。这里介绍一个方便切换模型API的工具，这个软件的作用就是让你<strong>在不用更改各种配置文件的前提下，方便快捷地一键切换你的大语言模型</strong>。</p><p><img src="https://zju-paradox.top/image/LLM15.png" width="60%" /></p><p><code>Claude Code Switch (CCS)</code>（也可以使用<code>Claude Code Router (CCR)</code>，后者好像用的人多一点。这两个软件功能差不多，我这里以前者举例）。<code>CCS</code>的使用可以参考<strong>这个视频的第2~5分钟：</strong><a href="https://www.bilibili.com/video/BV1Pr6dBPEET">7分钟搞定Claude Code安装和多模型配置</a></p><h3 id="基于VsCode-CCS的CC使用"><a href="#基于VsCode-CCS的CC使用" class="headerlink" title="基于VsCode+CCS的CC使用"></a>基于VsCode+CCS的CC使用</h3><p>那么众所周知，命令行窗口的界面使用很令人头疼：可视化程度低、集成化程度低等等。前段时间，继需要付费的Cursor之后，理工科软件的神<code>VsCode</code>也推出了Claude Code的插件。本小节将教会你基于<code>VsCode</code>和<code>CCS</code>的Claude Code可视化使用。</p><p><strong>在VsCode中使用时，可以不需要翻墙</strong>。</p><ul><li>第一步，打开<code>VsCode</code>，在扩展的搜索栏中搜索“Claude Code”，然后安装这个官方的插件</li></ul><p><img src="https://zju-paradox.top/image/LLM14.png" width="70%" /></p><ul><li>第二步，打开你的<code>CCS</code>，选择一个大语言模型</li><li>第三步，打开（或重启）<code>VsCode</code>的Claude Code插件（<strong>右上角的橙色烟花图标</strong>），然后<strong>如果不出意外的话，你就能跳过初始的登录界面</strong>，直接进入对话窗口。</li><li>如果你在第一次使用<code>ccs</code>配置了大语言模型之后，后续再使用<code>VsCode</code>中的<code>Claude Code</code>的话就不需要再登录<code>CCS</code>了（因为他会把你的LLM配置写在配置文件里面，除非你想通过<code>ccs</code>更改你的LLM）</li></ul><p>好了如果到这一步都没有出问题的话，那么恭喜你已经完成90%的配置了。现在你应该能看到一个跟平常使用AI对话非常相似的界面。然后现在让我们测试一下我们的<code>CCS</code>是否配置成功，询问它“你的模型版本是什么？”，发现它返回MiniMax 2.1，跟我们在<code>CCS</code>中配置的一样，说明成功了。</p><p><img src="https://zju-paradox.top/image/LLM16.png" width="70%" /></p><p>现在你可以开始你的Agent使用了。尝试进行一些对话，比如生成一个ToDo软件或者贪吃蛇游戏吧。</p><h2 id="拓展内容"><a href="#拓展内容" class="headerlink" title="拓展内容"></a>拓展内容</h2><h3 id="CLAUDE-md"><a href="#CLAUDE-md" class="headerlink" title="CLAUDE.md"></a>CLAUDE.md</h3><p>以我粗浅的理解，CLAUDE.md就像给Agent使用的Gem一样，在每次对话前都被加载进去，当做这个Agent的底层逻辑。比如它描述了你这个项目是什么、做了哪些内容，他跟你对话的时候应该遵循什么需求，输入输出的时候要有什么条件和格式。</p><p>业内通常认为CLAUDE.md不应该太长，尽量在100个token以内，以减少不必要的资源浪费。在Claude Code 的使用中，可以使用<code>/init</code>命令来创建并修改CLAUDE.md。他的写法跟Gem非常相似</p><p>比如，你可以要求Agent在你输入指令不明确的时候不要自己瞎猜，而是不断追问来明确指令要求。或者你也可以让Agent在进行创意设计的时候多参考你的要求，每次都给你提供更多选项之类。</p><h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><p>下面介绍了一些<code>Claude code</code>的常见命令</p><ul><li><code>ctrl+g</code>：打开VSCode编辑器</li><li><code>/tasks</code>：查看当前正在运行的命令</li><li><code>/rewind</code>或<code>esc + esc</code>：回滚，回到之前的内容并删除后文</li><li><code>/resume</code>：在启动之后回溯之前的对话内容</li><li><code>/compact</code>：压缩上文，精简内容保证高质量的Memory，并且可以减少后续回复的Token</li><li><code>/clear</code>：清空上文，用于开新任务的时候使用。当然也可以开新会话。</li><li><code>/memory</code>：打开<code>CLAUDE.md</code>文件，相当于<code>System Prompt</code><ul><li><code>CLAUDE.md</code>：（可使用<code>/init</code>命令创建）Ciallo～(∠・ω&lt; )⌒★</li></ul></li><li><code>/hooks</code>：执行的格式化（？）</li><li><p><code>/plugin</code>：可以一键安装<code>Agent Skill</code>、<code>MCP</code>、<code>hook</code>等内容，如<code>frontend-design</code>可以优化你的前端设计</p><h2 id="实战案例"><a href="#实战案例" class="headerlink" title="实战案例"></a>实战案例</h2></li></ul><p>我跟着最前面的视频，做了一个ToDo软件：页面简洁、UI舒适、模型轻量化且满足我自己需求的个性化ToDo（因为我没有在市面上找到不收费的、UI简洁的令我满意的ToDo）。一开始让它生成HTML网页用来测试，然后在此基础上不断更新我的要求并进行测试迭代——每次我都把新的要求反馈给CC，让它帮我修正。基本满意之后，就开始进行EXE的生成，我要求CC自己选择合适的运行环境进行软件开发，并帮我搞定运行环境、生成EXE压缩包，顺手再丢到了Github上面。</p><p><img src="https://zju-paradox.top/image/LLM13.png" width="30%" /></p><p><strong>现在大家都可以在Github上下载我的这个ToDo软件</strong>。全程可以说我都在玩手机，全是CC给我写的。</p><p><a href="https://github.com/ParadoxTZ/paradox-todo">Github下载链接</a></p><p>我使用了<code>frontend-design</code>这个插件（其实就是一个Skill）来帮我完成前端的设计，这个SKILL可以让AI设计出更好的前端UI。关于Skill和MCP的使用，参见后文的内容。</p><p>由于聊天记录不全，所以现在我无法1:1复刻之前的指令，但我的大致流程如下：</p><ol><li><p>“帮我做一个ToDo软件，用HTML呈现，使用 frontend-design这个skill来进行前端设计。”</p><p>Agent返还了一个<code>index.html</code>文件，打开后是一个网页端的ToDo</p></li><li><p>告知Agent我所需要的功能（时间、地点的添加，任务优先级的设置）</p><p>Agent修改了<code>index.html</code>中的内容，让我再次打开验证</p></li><li><p>Debug（测试后告诉他现在的软件有什么bug，比如我当时遇到了时间和本地时间对不上的问题）</p></li><li><p>“帮我把HTML的ToDo变成可下载运行的EXE软件，自行解决EXE的运行环境配置问题。要求EXE运行后能在桌面固定显示一个小窗口，展示所有内容，在点击添加任务后才会出现如同该HTML格式的任务添加”</p></li><li><p>Debug（比如当时遇到了EXE环境配置问题，最后是让AI自己解决的，还有固定问题，任务添加窗口的位置问题等）</p></li><li><p>“帮我把这个项目上传到github上，供其他人下载”</p><p>当然github仓库的建立、EXE文件上传还是我自己做的，但是他帮我生成了完整的项目格式（并上传）。需要我自己建立github仓库的原因是Agent没有连接到github的工具，也就是下文要介绍的MCP</p></li></ol><h1 id="MCP"><a href="#MCP" class="headerlink" title="MCP"></a>MCP</h1><p>MCP，Model Context Protocol，就是能够让大模型更好地使用各类工具（MCP Server）的一个协议。大模型的本质是问答，而通过MCP协议让LLM连接上工具，则可以更好的生成内容，获得它原本不具有的能力。</p><p>借用我们最开始LLM是“实习生”的例子来说，MCP就像手机里的软件商店，通过软件商店让符合手机厂商协议的软件APP（即MCP Server）上架，这样你的实习生就能更好地帮你做事。比如你问你的实习生明天杭州天气如何，即便他有搜索能力，也需要联网后在网上搜索各大天气网页的消息进行汇总，耗时久且不准确（容易产生幻觉）。而此时，他可以通过MCP（手机）直接调用天气APP（天气的MCP Server）直接查询，然后返回给你。</p><p>MCP Server：事实上这个“Server”不是“服务器”，它是一个“工具”、一个“函数”、或者一个“手机APP”——你给他输入特定的参数，他返还给你所需的结果的这么一个工具，是专门用在某个领域的工具。MCP Server符合MCP协议的规定，可以通过MCP被LLM调用——<strong>当LLM需要完成某个能力之外的任务时，它会查询MCP Server列表，看看有没有什么能帮到自己的函数工具，然后通过MCP协议调用它</strong>。</p><p><strong>MCP Server市场：</strong></p><ul><li><a href="https://mcp.so">https://mcp.so</a></li><li><a href="https://mcpmarket.com">https://mcpmarket.com</a></li><li><a href="https://smithery.ai">https://smithery.ai</a></li></ul><h2 id="MCP安装"><a href="#MCP安装" class="headerlink" title="MCP安装"></a>MCP安装</h2><h3 id="终端中使用的MCP安装"><a href="#终端中使用的MCP安装" class="headerlink" title="终端中使用的MCP安装"></a>终端中使用的MCP安装</h3><p>倘若你在<strong>终端（命令行窗口）中使用</strong><code>Claude Code</code>，那么你需要在<code>.claude/mcp.json</code>文件中配置你的MCP服务。具体操作如下：</p><ol><li><p>确认你需要在全局使用该MCP还是仅针对这个项目使用MCP</p><ol><li><p>仅针对该项目：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">项目根目录/.calude/mcp.json</span><br></pre></td></tr></table></figure></li><li><p>全局使用：</p><p>Windows：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:<span class="keyword">\Users</span><span class="keyword">\&lt;</span>你的用户名&gt;<span class="keyword">\.</span>claude<span class="keyword">\mcp</span>.json</span><br></pre></td></tr></table></figure><p>Mac：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.claude/mcp.json</span><br></pre></td></tr></table></figure></li></ol></li><li><p>打开该文件并输入</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="comment">// 待输入</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>去MCP Server市场找你心意的MCP，然后找到他的JSON格式并粘贴到里面去。注意部分MCP可能需要你安装相应的插件，或者注册一个API Key，这部分请参照对应的MCP下载说明</p></li></ol><h3 id="VsCode中使用的MCP安装"><a href="#VsCode中使用的MCP安装" class="headerlink" title="VsCode中使用的MCP安装"></a>VsCode中使用的MCP安装</h3><p>打开<code>VSCode</code>的<code>setting.json</code>（即点开<code>VsCode</code>的设置），然后在里面输入以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;mcpServers&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;mcp-name&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><p>记得这段话要输入在整个<code>json</code>文件的大括号里面，输入前观察一下前面其他的配置文件有没有逗号，没有的话得加一个。其他方法同上文第三步。</p><h3 id="邪修法"><a href="#邪修法" class="headerlink" title="邪修法"></a>邪修法</h3><p>去MCP Server市场找你心意的MCP，复制其网页并告诉Claude Code我想在哪里（VsCode还是终端、全局还是该项目）安装这个MCP，然后等待它给你安装，你一路点击“Yes”就行了。如果遇到需要API Key或其他东西的地方，CC会告诉你的。</p><h3 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h3><p>询问你的<code>Claude Code</code>：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">列出你当前可用的 MCP tools</span><br></pre></td></tr></table></figure><p>如果他给出了正确的反馈，那么就说明你安装成功了。</p>]]></content>
      
      
      <categories>
          
          <category> 软件教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 有趣的东西 </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通人应该怎样价值投资？Paradox的投资理财记录帖</title>
      <link href="/2025/11/28/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/"/>
      <url>/2025/11/28/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>投资有风险，理财需谨慎</strong></p><p><strong>本文仅记录个人投资理财观点和过程，不构成任何投资建议</strong></p><h1 id="投资理财的基本方式"><a href="#投资理财的基本方式" class="headerlink" title="投资理财的基本方式"></a>投资理财的基本方式</h1><p>本小节列举了常见的投资理财方式，并介绍其基本含义，供小白理解基本的理财方式。</p><h2 id="债券"><a href="#债券" class="headerlink" title="债券"></a>债券</h2><p>债券分为两种，一种是<strong>企业债券</strong>，一种是<strong>国债</strong></p><ul><li><p>企业债券：</p><ul><li>企业债券的利率会稍微高一点，一般也不会暴雷，除了极端情况（比如恒大）</li><li>通常可以在支付宝等场外直接投资债券相关的基金，详见后文“基金”</li></ul></li><li><p>国债：</p><ul><li>国债的担保主体是国家，虽然名义上也有风险，但一般直接忽略。</li><li>普通人要卖到国债比较困难，但是在投资软件中会有一个和国债很近四的东西，全名叫“国债逆回购”</li></ul></li><li><strong>国债逆回购</strong>：<ul><li>一些企业、资本手里有国债，他们把国债当作抵押物向你借钱，到期后还你本金+利息。</li><li>国债逆回购的<strong>风险极低</strong>，因为作为抵押物的国债价值超过你投资的金额。国债逆回购会<strong>在投资时就直接确定到期收益</strong>。</li><li>一般国债逆回购利率跟余额宝相近（1.5%左右），但是在<strong>节假日前</strong>，一些资本可能需要大量现金来做活动等急用钱，所以这时候会有<strong>短期的高利率国债逆回购</strong>（持续3-4天的4-10%年化利率的产品），一定要抓住机会</li></ul></li></ul><h2 id="货币基金"><a href="#货币基金" class="headerlink" title="货币基金"></a>货币基金</h2><p>货币基金的最主要代表就是支付宝余额宝、微信零钱通里面的钱，目前年化在1.5%左右，你也能看到每天都有正增长。基本零风险，但是跑不赢通胀。</p><p>我记得远古时期余额宝的利息还是很高的，有4%以上，现在已经不复当年了。</p><h2 id="股票"><a href="#股票" class="headerlink" title="股票"></a>股票</h2><p>股票最初创立的目的其实是为了分红，比如你有公司20%股份，公司挣了钱就要分你一部分</p><ul><li>股票的基本收益逻辑就是人尽皆知的四个字：<strong>低买高卖</strong>（“做空”除外）<ul><li>比如贪狼咖啡公司股票1元1股，你花了100元买了100股（100股称作“一手”，市场必须以百倍数交易）。后来这个股票涨到了1.5元1股，那你手上的股就值150元。</li><li>当你某时候要用钱了，或者觉得收益率差不多可以止盈了，就把它卖掉，你就收获了五十元（如果不考虑手续费的话）</li></ul></li><li>新手推荐买个股吗？其实不是很推荐，因为一个公司的股票涨跌极难预测。关于这一点，轻看后文“<strong>指数</strong>”。</li></ul><h2 id="基金"><a href="#基金" class="headerlink" title="基金"></a>基金</h2><p>基金的本质就是“<strong>雇一个基金经理帮你打理你手里的钱</strong>”，然后你每年交他一定的管理费。最常见的基金购买方式就是支付宝，但是管理费（0.6%-1.2%）、申购费（约0.6%）、短持惩罚等等是真的高。</p><p>基金通常有如下2种分类：</p><ul><li><strong>主动和被动</strong>：<ul><li>主动基金：由基金经理自己的偏好和分析调节仓位，所以管理费通常较高。一般某只基金会把他的大致方向告诉你，比如以前很火的“易方达蓝筹股精选”、最近很多的“永赢高端装备智选”等。买这类基金，就是<strong>相信对应基金经理的投资逻辑和能力</strong>。</li><li>被动基金（指数型基金）：跟踪某一指数的基金（详见下文），因此只会根据指数的变化进行被动调仓，管理费相对较低。</li></ul></li><li><strong>债基和股基</strong>：<ul><li>债基：债券占比80%以上的基金，不过一般常见的债基里债券占比都在95%以上。债基就是买债券的好方式，一般年化收益率在2-5%之间，也会有回撤的情况出现，并不是一路上涨。</li><li>股基：反之，股票占比80%以上的叫股票型基金</li><li>介于两者中间的叫混合型基金</li></ul></li></ul><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><div class="table-container"><table><thead><tr><th>方式</th><th>货币基金</th><th>债券</th><th>基金</th><th>ETF</th><th>个股</th></tr></thead><tbody><tr><td><strong>平均预期&lt;/br&gt;年化</strong></td><td>1-2%</td><td>1.5-5%</td><td>2-20%</td><td>5-20%</td><td>5-30%</td></tr><tr><td><strong>风险</strong></td><td>几乎为零</td><td>极低</td><td>较低 - 较高</td><td>中等 - 偏高</td><td>较高</td></tr><tr><td><strong>例子</strong></td><td>余额宝</td><td>国债逆回购<br />纯债券基金</td><td>支付宝理财</td><td></td></tr></tbody></table></div><h1 id="指数与ETF"><a href="#指数与ETF" class="headerlink" title="指数与ETF"></a>指数与ETF</h1><h2 id="什么是指数"><a href="#什么是指数" class="headerlink" title="什么是指数"></a>什么是指数</h2><p><a href="https://zhuanlan.zhihu.com/p/324224009">指数</a>约等于“一揽子股票”，按照市值等数据，将<strong>一堆具有相同属性的一堆股票加权</strong>，可以一定程度上反映出市场的总体变化和行情。比如：</p><div class="table-container"><table><thead><tr><th>指数</th><th>股市</th><th>范围</th><th>行情</th></tr></thead><tbody><tr><td>沪深300</td><td>A股</td><td>市值前300</td><td>中国头部公司</td></tr><tr><td>上证指数</td><td>A股（沪）</td><td>上海证券交易所全部股票</td><td>“大盘”，中国整体行情</td></tr><tr><td>中证500</td><td>A股</td><td>第301-800</td><td>中国中小企业</td></tr><tr><td>标普500</td><td>美股</td><td>市值前500</td><td>美国整体经济</td></tr><tr><td>纳斯达克</td><td>美股</td><td>市值前100的科技公司</td><td>美国头部科技企业</td></tr><tr><td>恒生指数</td><td>港股</td><td>市值前50</td><td>港股头部公司</td></tr><tr><td>日经225</td><td>日本</td><td>市值前225</td><td>日本整体经济</td></tr></tbody></table></div><p>  注：由于美股最牛的七姐妹都是科技公司，所以纳斯达克和标普的持仓非常接近，前几家持仓占比很高的公司都是一样的</p><h3 id="指数的分类"><a href="#指数的分类" class="headerlink" title="指数的分类"></a>指数的分类</h3><ul><li><strong>宽基指数</strong>：涵盖范围很大，所有行业都有，反应整个国家、地区的整体股市情况。上面提到的大部分都是宽基</li><li><strong>行业指数</strong>：聚焦某一个行业的指数，比如光伏指数、中证新能、恒生消费/科技、中证白酒、上证消费、中概互联网50、创业板指等等<ul><li>注：虽然按理说纳斯达克100也是行业指数，但是由于其体量大且和标普接近，能反映美国整体经济，所以也可以认为是宽基</li></ul></li></ul><p>说个幽默的，媒体天天搁哪日本经济这不行那不行的，从内到外赢赢赢，日经225从2013年开始每年稳步上涨连续12年了。<u>买日经225的逻辑就是“押注日本的经济复苏”</u>。</p><h3 id="指数的优势"><a href="#指数的优势" class="headerlink" title="指数的优势"></a>指数的优势</h3><p>指数的优势在哪？为什么要买指数而不是个股？</p><ul><li>一个公司可能暴雷导致股价崩盘，但是一整个行业或者市场行情会有更多的对冲，让他<strong>相对波动较小</strong>。这对于普通投资者而言<strong>持有体验</strong>会好一些<ul><li>21年前后恒大事件爆发，恒大股票跌了86%，但同时房地产行业相关指数只跌了50%左右</li><li>上面那个属于极端例子，也有近几年房地产整体也不怎么景气的原因</li></ul></li><li>个人<strong>对一家公司很难有详细的判断</strong>，未来会如何发展——你连财报都没完整的看过！可以比较一下下面几个判断的容易程度<ul><li>个股“百度”：“百度”未来五年的发展情况</li><li>行业指数“中概互联网”：中国互联网企业未来五年的发展情况</li><li>宽基指数“上证指数”：中国经济未来五年的发展情况</li></ul></li><li>可以这么简单的说，你投资“上证指数”、“沪深300”，就是认为中国经济未来会持续走高；投资“中概互联网“就是认为中国互联网企业未来会持续走高；投资“百度”的个股就是认为这个企业发展前景较好。</li><li>投资美股港股的门槛比较高，要投个股一般都是大A。而就A股这个成立才30年的东西：情绪化、非理性、讲故事充斥着整个市场，而不具有真的经济逻辑。<strong>只能波段，不能价值投资</strong>。<ul><li>波段是指行情随时间波动较大，需要合理考虑买入、卖出时间，一般几个月乃至几天为一个波段周期</li></ul></li></ul><h2 id="什么是ETF"><a href="#什么是ETF" class="headerlink" title="什么是ETF"></a>什么是ETF</h2><p><a href="https://www.bilibili.com/video/BV18mWiz8Evj">ETF</a>可以认为是一个买指数的工具，类似于基金公司推出的一个投资产品，你买了这个ETF，就相当于你买了对应的指数。比如买中证新能就要买对应的新能源ETF。关于ETF，详见后文“场内与场外”。</p><ul><li>所以，当我们投资某个ETF时，ETF是什么不重要，<strong>重要的是ETF背后对应的指数</strong>：<ul><li>比如针对同一个指数（如纳斯达克），<strong>不同的基金公司都会推出相似的ETF供你买卖</strong>。</li><li>对比不同公司的ETF时，主要关注不同ETF的<strong>规模</strong>（相对较大比较好）、<strong>运作费率</strong>（越低越好）、<strong>场内溢价率</strong>（越低越好）</li></ul></li></ul><h2 id="场内和场外"><a href="#场内和场外" class="headerlink" title="场内和场外"></a>场内和场外</h2><p><img src="\image\水母.png" alt=""></p><h3 id="场内"><a href="#场内" class="headerlink" title="场内"></a>场内</h3><ol><li><p>场内ETF需要开券商账户（开户）进去投资，比如银河证券、国盛证券等。</p></li><li><p><strong>场内的交易是实时的，甚至可以上一秒买入，下一秒卖出</strong>（这个叫做日内T，本文不过多赘述）</p></li><li><p>在默认情况下，你的每一笔交易都需要付出手续费（万分之五左右），并且还有5块钱起收。对于我们这些小资金量而言非常的坑人</p><p>但是现在会有一些灰色的渠道，有一些缺业绩的券商经理，当你通过特定渠道找他开户时，为了拉新人，他就会给你调手续费（不仅有“免五”，也就是免除5块起收；还能将手续费调低到万一以下，万0.6的意思就是万分之0.6的手续费）</p><p>这些渠道可以去找一些up主（如“会飞的陆行鸟”、“水母财经”等，这里不打广告了），但是<strong>这些up绝对不会主动私信联系你</strong>，那些百分百是骗子，千万别信！</p></li></ol><h3 id="场外"><a href="#场外" class="headerlink" title="场外"></a>场外</h3><p>（下文的123和上文场内的123一一对应）</p><ol><li><p>有些人会嫌开户麻烦（A股开户其实不麻烦，几十分钟的事），所以以支付宝为首的APP就推出了场外链接ETF，也就是所谓的支付宝基金。</p></li><li><p><strong>场外的交易非实时，按天为单位</strong>。你在今天买入的基金，会按照今天<strong>下午三点股市收盘价的净值进行结算</strong>，并在后天开始计算盈利。因此这种方式也被称作“<strong>T+2</strong>”</p></li><li><p>这些基金的费用较高，通常在1~2%之间，跟调了费率的场内ETF相比还是要贵不少的</p><p>关于费率的差别，可以参考<a href="https://mp.weixin.qq.com/s/zFQW0R5yYjNiR4UMJZMKBw">这个</a></p><p>为了让你能长期持有，部分基金还有惩罚性的短持费用，即当你持有时间小于半年、一年就卖出时，会额外收取一定比例的金额。</p></li></ol><h3 id="溢价和折价"><a href="#溢价和折价" class="headerlink" title="溢价和折价"></a>溢价和折价</h3><p>有的时候，有些基金和ETF会变得很热门，短时间内买入人数陡增，容易使股市偏离合理估值，基金公司的管理也变得困难。因此，场内和场外都有各自应对热门ETF的办法。</p><p><strong>场内：溢价和折价</strong></p><p>我们高中政治里都学过价格围绕价值上下波动，溢价和折价就是如此。<strong>溢价的意思就是需要花比原价值更高的价格来买入</strong>，折价相反。当有10%的溢价时，你需要花110元才能买到价值100元的股票，同样也能以110元的价格将他卖给别人。</p><p>这是一件极有风险的事情——当有一天这10%的溢价消失了，那就相当于你亏损了10%。所以高溢价带来的高风险高收益会降低人们的购买欲望，在一定程度上抑制热门程度。</p><p>当然也不是说有了溢价就绝对不能投资，因为除了热门程度之外，尤其是海外的ETF，溢价率还会受到汇率波动等事件的影响。比如场内热门的纳斯达克指数，常年都有4~6%的溢价率，当纳斯达克的溢价率低于4%的时候一般我们就认为这是一个低值了，如果此时股价也合适，那么就可以入手一部分。</p><p><strong>场外：限购</strong></p><p>相比于场内的大手子，场外就显得简单粗暴非常多，直接给你<strong>限制每日购买金额</strong>。比如前段时间几乎所有基金公司都直接把纳斯达克基金全部设置上每天10块钱的限购……很难评。</p><p><strong>套利</strong></p><p>套利实际上就是利用场内场外限制方式的差别进行获利的一种方式，简单理解为场外用净值申购某支热门ETF，然后在场内卖出，享受溢价率带来的收益。这里限于篇幅就不赘述了，有兴趣的自己了解。反正我已经通过白银套利猛猛赚钱了。</p><h1 id="价值投资"><a href="#价值投资" class="headerlink" title="价值投资"></a>价值投资</h1><h2 id="什么是价值投资"><a href="#什么是价值投资" class="headerlink" title="什么是价值投资"></a>什么是价值投资</h2><ul><li><p>价值投资就是专注于投资那些有<strong>合理的增长逻辑</strong>、<strong>长期能稳定运行不容易塌</strong>的（指数）组合中。不是追热点、不是赌行情，就是把钱拆成几份，扔进几个 <strong>“不会死的标的”</strong> 里，按月定投，然后等时间给答案。——B站财经up主“雷牛牛”</p></li><li><p><strong>复利是最恐怖的赚钱工具</strong>，不要追求30%、50%的不合理年化，这样你赚的钱总有一天会亏回去。“每年10%的年化慢慢等待，就是变富最好的工具，但是他们都不愿意等待，所以我成为了世界首富。”——股神巴菲特</p></li><li>“我是一个风险厌恶的投资者，我不会去让自己承受太大的风险，因为君子不立危墙之下。所以我不会去碰个股，不会去碰短期涨幅过快的板块，追求的核心理念是<strong>持续盈利而非短期暴富</strong>，并且学会<strong>享受时间带来的价值</strong>而不是让自己每天操作都累得要死……这个是基于风险控制和分散资金投资所带来的决定。”——公众号“FIRE投研”</li></ul><h2 id="恒星与卫星（核心内容）"><a href="#恒星与卫星（核心内容）" class="headerlink" title="恒星与卫星（核心内容）"></a>恒星与卫星（核心内容）</h2><p><strong>这一部分非常重要</strong></p><p>有兴趣的可以去看看雷牛牛的<a href="https://mp.weixin.qq.com/s/pDXUJb3kxX8cD4ql2dSJaQ">2026展望</a></p><p>所谓恒星与卫星，就是<strong>采用较大的仓位（如60%）执行上文的宽基指数定投，剩下的仓位分散地投入几个行业指数中做波段，或者留着这一部分现金随时补仓</strong>。下面对其中几个核心概念进行一一解释：</p><h3 id="大仓位宽基"><a href="#大仓位宽基" class="headerlink" title="大仓位宽基"></a>大仓位宽基</h3><p>在前文<strong><a href="#指数的优势">指数的优势</a>和价值投资</strong>中提到，宽基指数的增长逻辑更加明晰，并且存在一些长期上涨可能性较大，具有合理的增长逻辑的宽基指数。把投资这些指数当做你的<strong>仓位基石</strong>，相信这些本身逻辑够硬的指数能在长期带给你良好的收益。</p><p><strong>宽基怎么选：</strong>下文提到一些我个人认为比较不错的宽基指数（不构成任何投资建议），也被人称作所谓<strong>永久投资组合</strong>。这里给出简单的逻辑介绍，但是具体买入时，可以b站up主如水母财经对于这一部分的介绍。 </p><ol><li><p><strong>黄金</strong>。黄金不是股票，但是其逻辑比股票还硬。黄金能够增长的逻辑就是其保值性：用最简单的话来说（这句话不完全正确），世界格局越乱，美元的信任度越低时，黄金的价值就越高。</p><p><img src="https://zju-paradox.top/image/黄金.jpg" width="30%" /></p></li><li><p><strong>纳斯达克和标普</strong>：即使是现在，纳斯达克和标普500对应的美国核心科技企业仍然猛地一笔，并且这两个指数已经有了百年历史，经历过极多次牛熊市和经济危机，但时间都证明了他依旧坚挺。</p><p>纳斯达克和标普的涨跌规律差不太多，但是纳斯达克的波动通常较大，根据喜好自行选择。</p><p><img src="https://zju-paradox.top/image/纳指.jpg" width="30%" /></p></li><li><p><strong>红利：</strong>红利类型的指数选择的是市面上股价波动相对较小，能长期分红的公司，这个逻辑相信的是“能长期给股东分红的公司本身具有良好的增长、良好的商业盈利模型”。</p><p>红利类型的股票选择很多，常见的有中证红利(000922)、红利低波(H30269)、红利低波100(930955)、港股通高股息CNY(930915)、港股通央企红利(931233)等。需要注意的是消费红利不是红利指数，红利质量的波动比较高。</p><p>关于红利的选择可以参考<a href="https://www.bilibili.com/video/BV1T2qrBXEze">水母财经的视频</a>，我的选择会在下文提到。</p><p><img src="https://zju-paradox.top/image/红利.jpg" width="30%" /></p></li><li><p><strong>自由现金流：</strong>自由现金流类型的指数选择的是市面上有充足的自由现金流的公司，这个逻辑相信的是“现金流充沛的公司本身是好公司，具有良好的商业盈利模型”。</p><p>现金流也有分类，比如中证自由现金流(932365)、CNIFCF(980092)、富时自由现金流(FCFQCD)、800现金流(932368)、500现金流(932367)等。根据某些财经博主的说法，选择800、CNIFCF也许会好一些。自由现金流出现的相对较晚，没有经历过历史的长期考证，但是最近几年的增长都非常不错，也是我持有体验最好的一支ETF。</p><p><img src="https://zju-paradox.top/image/现金流.jpg" width="30%" /></p></li></ol><h3 id="小仓位波段"><a href="#小仓位波段" class="headerlink" title="小仓位波段"></a>小仓位波段</h3><p>如果你是一个十足的懒人，可能只能每周看个一次股市，那么把仓位均匀地分给上面四个ETF，然后每年进行一次再平衡就行了。如果你想追追热点，那么就可以用小仓位（<strong>单支ETF/股票不超过15%</strong>）去做一做波段。</p><p>比如你看好新能源就买新能源相关ETF，看好光伏就买光伏相关的ETF。最近（本文写于26年1月24日）的几个热点领域有半导体芯片、机器人、航空航天、卫星、电网设备、云计算等，可以看到都是新一代算力革命相关产业。但是正如上文所说，<strong>这种行业指数的波动远大于宽基，并且通常没有硬核增长逻辑，切勿追涨，并且买入的时候就必须做好亏损的心理准备</strong>。</p><h3 id="分散与及时止损：鸡蛋不要放在同一个篮子里"><a href="#分散与及时止损：鸡蛋不要放在同一个篮子里" class="headerlink" title="分散与及时止损：鸡蛋不要放在同一个篮子里"></a>分散与及时止损：鸡蛋不要放在同一个篮子里</h3><p>止损是指当你的某支股票/ETF买了之后一路跌，跌到某个百分比时，就需要进行清仓。这个止损线是你自行设定的，比如10%比如20%，但是<strong>当你一旦定下来之后就必须严格执行</strong>，绝对不能自己给自己开后门。</p><p>不管是你的核心标的，还是卫星标的，都必须遵循一个原则，即<strong>单支股票/指数的仓位不可以超过总仓位的15%</strong>。这意味着你需要均衡配置6~10支的股票/ETF并留下一定的现金。这么做的目的是不让单一的仓位过于影响你的总收益，你的“卫星仓位”跌了有核心标的拖着，市场热门的板块涨了你也能跟着喝到肉汤。举个例子，如果你全仓了某个股票，然后他跌了20%，相当于你的本金直接打了八折，这换谁来都心疼。但是如果你坚持分散仓位，只给其配置了10%的仓，那你也不过是小亏2%而已。</p><p>采用<strong>分散+及时止损</strong>的这个投资逻辑非常简单，肯定是有利有弊。其弊端就是你的持仓上涨肯定没有那么爽，什么一周翻倍这种想都别想。但是与之相对的，你的持仓体验会变得好非常多。很多小白刚进来时，就是看到一点下跌就顶不住，心痛的在滴血以至于连正常的生活工作都无法专心进行。</p><p><strong>市场没有一劳永逸的投资方法，这种方法论的背后是“少赚也比亏钱好”的投资理念。如果你是认同这一点的，那不妨尝试一下。</strong></p><h3 id="网格：4-定投法与分批止盈"><a href="#网格：4-定投法与分批止盈" class="headerlink" title="网格：4%定投法与分批止盈"></a>网格：4%定投法与分批止盈</h3><p>定投是指不在一次把资金全部梭哈进去，而是把子弹分成多份，<strong>每隔一定时间</strong>（半个月、一个月）或者当市场有<strong>合适的机会</strong>时，投入一定的资金。</p><p>股票的投资逻辑是低买高卖，但是很显然我们没有办法确定自己买在最低位，卖在最高位。而定投<strong>用时间成本分摊风险</strong>。你不能保证你买入点一定是最低点，万一一旦买在山顶就崩了。定投也不能保证，但是他能让你的买入成本由时间分摊，对冲掉一部分波动风险——虽然不会是谷底，但一定不会太贵。</p><p>常见的定投方法：</p><ul><li>固定时间定投：比如每月月初、每周周中固定投入一笔资金。好处是方便，操作简单。</li><li><strong>雷牛牛的<a href="https://www.bilibili.com/video/BV1wfBNYpEP9/">4%定投法</a></strong></li></ul><h4 id="4-定投法的基本逻辑"><a href="#4-定投法的基本逻辑" class="headerlink" title="4%定投法的基本逻辑"></a>4%定投法的基本逻辑</h4><p>把你准备给这支ETF的“子弹”分成多份（如5份、10份），在第一次买入之后，每当这个指数<strong>相较于上一次买入点或者上一个峰值下跌4%</strong>，就补一次仓，即再扔入一份子弹。越跌越买。这种定投逻辑是忽略短期波动，只在股价有较大波动时进行一次投资。</p><p><strong>举个例子：</strong></p><ul><li>当你以1元/股的价格买入一手股票后，过了两周这支ETF跌到了0.96元/股（-4%），执行一次买入。</li><li>又过两周跌到了0.9216元/股（0.96*96%），再执行一次买入。</li><li>后来这只股票一路上涨到了1.2元/股，这期间都不买入。</li><li>此后该股开始调整，跌到了1.152元/股（1.2*96%），再执行一次买入。</li></ul><h4 id="什么时候执行4-定投"><a href="#什么时候执行4-定投" class="headerlink" title="什么时候执行4%定投"></a>什么时候执行4%定投</h4><p>要详述这个有点字多，先看看上面的视频了解一下什么是PB/PE和估值。简单来说就是<strong>在低估值时买入，中间估值时少动</strong>，较高估值时分批止盈（见后文）卖出。关于估值高低的划分，不同人有不同的标准，比如以40%和80%为两条基准线、以20%、50%、80%为三条基准线等等。</p><p>但是有一点，个人认为这个估值一般比较使用于小仓位的行业指数，对于价值投资的那几个核心标的可以不用怎么管。</p><h4 id="分批止盈"><a href="#分批止盈" class="headerlink" title="分批止盈"></a>分批止盈</h4><p><strong>学会止盈跟学会买入一样重要</strong>。止盈时要想好你为什么需要止盈，比如这支股票你是拿来做波段的，他达到了你之前给它定下的收益率（如20%），或者这只股票现在处在高估区间，那么就可以用<strong>反向的4%定投法进行止盈</strong>：即把你的资金分为3~5份（止盈的话一般可以少分一点），当你第一次止盈之后，每当这个股票<strong>相较于上一次卖出点或者上一个谷值上涨了4%</strong>，就进行一次止盈。</p><p><strong>市场没有一劳永逸的投资方法，这种方法论跟分批止损一样，背后是“少赚也比亏钱好”的投资理念。如果你是认同这一点的，那不妨尝试一下。</strong></p><h3 id="补仓与再平衡"><a href="#补仓与再平衡" class="headerlink" title="补仓与再平衡"></a>补仓与再平衡</h3><p>市场从不缺少机会，但很缺少本金。当你发现一个绝佳的投资机会却没有筹码时，你就能理解仓位管理和定投的重要性。</p><p>再平衡就是定期（比如每年）根据股票/ETF的涨跌平衡其占比，本质就是做一次高卖低买操作。比如你有60%的核心标的，平均分散到上述“永久投资组合”中（每个15%），一年过去了，也许黄金涨了15%，纳斯达克涨了10%，红利跌了6%，自由现金流涨了8%，导致这四个仓位比例不是1:1:1:1了。那么就把占比高的ETF卖掉一部分，占比低的再多买一点，使之重新达到平衡。</p><p>这个操作不需要做的很频繁，一般半年或一年一次即可。<strong>市场没有一劳永逸的投资方法，这种方法论跟分批止损止盈一样，背后是“少赚也比亏钱好”的投资理念。</strong></p><h2 id="我的投资逻辑"><a href="#我的投资逻辑" class="headerlink" title="我的投资逻辑"></a>我的投资逻辑</h2><p>我跟公众号FIRE投研的投资逻辑差不多，先看看他的</p><p><img src="https://zju-paradox.top/image/FIRE.jpg" width="30%" /></p><ul><li>核心标的：<ul><li>红利：打算长期持有红利低波100和港股通央企红利，然后以季度为单位、20周线为基准做红利低波的波段。</li><li>现金流：长期持有CNIFCF</li><li>美股：长期持有纳斯达克100</li><li>黄金：长期持有</li></ul></li><li>卫星标的：<ul><li>这部分其实每个时候都会不一样，我也请过不少，有止盈的也有止损的，目前如下</li><li>生物医药相关</li><li>港股科技相关（恒生科技）</li><li>电力相关（电网设备）</li></ul></li></ul><p><strong>2025-11 复盘</strong></p><ol><li>刚建仓的时候有点控制不住，看到光伏跌了一天就进去了，但实际上一般一跌就会跌好多天，而且当天实际上是由于开盘价比较高。被套了，好在仓位很少，到了-10%的止损点就割了清仓。这也是11月没有较好盈利的主要原因</li><li>黄金由于一股在9r左右（大概是金价现价的百分之一），所以一手就是900多，鉴于目前还在建仓期所以仓位有点高。日后几个月内不会再投黄金，让它仓位控制在5-10%之间。</li><li>恒生科技、恒生消费、生物医药是用来做波段的，主要看好前面两个，加起来仓位在22%左右，还行。个人对于波段的选择逻辑如下，此处参考B站up主船长ETF基金：<ol><li>回撤幅度大于50%（当前股价在上一次最高点的一半以下）</li><li>回撤时间大于2年</li><li>30周线上穿60周线</li></ol></li><li>投资恒生科技一部分是因为我所在群里有一位“大佬”给出了指导意见hh，而且也符合上面说的三条。</li><li>11月整体行情很差，大部分人都亏了很多。如果我要是没有入光伏那应该能挣不少hh，可惜没有如果，现在应该基本是不亏不赚。</li></ol><p><strong>2025-12复盘</strong></p><ol><li>12月纳指表现一般，起起伏伏，基本没挣钱。反倒是黄金和自由现金流出乎我意料的涨。自由现金流目前持仓有点少，下个月要加一点</li><li>操作了一笔白银LOF套利，挣了八十几。要是没有这点钱感觉这个月会亏很多，主要是红利跌的太狠了，买在高位了。</li><li>目前看来局势到明年三月左右才会好转并比较明朗。</li></ol><h3 id="投资有风险，理财需谨慎"><a href="#投资有风险，理财需谨慎" class="headerlink" title="投资有风险，理财需谨慎"></a>投资有风险，理财需谨慎</h3><h3 id="本文仅记录个人投资理财观点和过程，不构成任何投资建议"><a href="#本文仅记录个人投资理财观点和过程，不构成任何投资建议" class="headerlink" title="本文仅记录个人投资理财观点和过程，不构成任何投资建议"></a>本文仅记录个人投资理财观点和过程，不构成任何投资建议</h3>]]></content>
      
      
      <categories>
          
          <category> 投资理财 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 有趣的东西 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从Word、MarkDown到Latex，打造最优雅的写作方式</title>
      <link href="/2025/06/26/latex%E6%95%99%E7%A8%8B/"/>
      <url>/2025/06/26/latex%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本来我是没有写这篇文章的，但是因为最近正好换了新电脑，所以Latex环境要全部重配，因此干脆顺便记录一下使用过程以及debug过程。</span><br></pre></td></tr></table></figure><h1 id="Markdown与Typora"><a href="#Markdown与Typora" class="headerlink" title="Markdown与Typora"></a>Markdown与Typora</h1><p>如果你具有较为充足的时间，并且考虑使用电子产品做课程笔记，那么Markdown将会是你在学习Latex前很好的过渡工具。</p><p>如果不是，那么可以直接跳转到后文观看Latex的使用，以应付你的毕业设计。</p><h2 id="功能介绍与下载安装"><a href="#功能介绍与下载安装" class="headerlink" title="功能介绍与下载安装"></a>功能介绍与下载安装</h2><ul><li><strong>Markdown</strong>是一种轻量化文本标记语言，其本质同word差别不大，对于理工科人而言，最好的区别在于其在word的基础上增加了<strong>公式</strong>与一些简单的<strong>标记</strong>（比如这里显示的加粗与前面的序列）。可以将Markdown试做Latex的超级轻量化版本，主要用于掌握数学公式的语法，这在后续撰写Latex的时候也将更加习惯。<ul><li>Word是一种<strong>所见即所得</strong>的语言，即你打出来的字同你最终得到的效果是一致的</li><li>Markdown严格来讲是一种<strong>所见非所得</strong>的语言，即你所打字的内容不仅包含主要内容，还包含对格式的定义等，需要通过额外的<strong>编译</strong>步骤才能得到最终生成的文本or PDF。</li><li>由于Markdown的语法本身比较简单，所以Typora将这种所见非所得的语言简化为了所见即所得的格式，即你在打字的同时Typora就在帮你<strong>实时编译</strong>。这一操作极大地方便了从Word过渡到Markdown的用户。</li><li>Typora打字界面的左下角有一个小按钮，为<code>启用源代码模式</code>，点击即可看到所生成代码的源代码，即在<strong>编译之前</strong>的语言。有时一些小bug可以在源代码界面中进行修改。</li></ul></li></ul><ul><li><strong>Typora</strong>是markdown的编辑器之一，如同Microsoft和WPS都是word的编辑器之一一样。</li><li>Typora简洁并且独立，同时也为Markdown做了一定的特定优化方案，缺点是要钱，不过下面有一套完整的免(po)费(jie)Typora下载方案：<ul><li>先在以下链接中下载1.9.3版本（实际上是1.9.5）：<a href="https://typoraio.cn/releases/stable.html">Typora — stable release channel</a></li><li>下载完成后进入该链接下载工具包（百度云或蓝奏云）并根据教程进行序列号提取：<a href="https://blog.csdn.net/qq_61621323/article/details/141036982">Typora 免费安装教程（支持版本：1.9.5）_typora免费版-CSDN博客</a></li></ul></li></ul><h2 id="Markdown的配置"><a href="#Markdown的配置" class="headerlink" title="Markdown的配置"></a>Markdown的配置</h2><p>完成安装后，进入“文件”-“偏好设置”，进行一些个人推荐的基础配置：</p><ol><li>“编辑器” - “成对使用的符号” - “匹配Markdown字符” 勾选，这个选项可以让你更方便的进行字体的<strong>加粗</strong>和<em>倾斜</em>。</li><li>“Markdown” - “Markdown扩展语法” - “内联公式$$$$” 勾选，这个可以让你快速的用$$$$输入行内公式，现在这个用法已经不算很扩展了，很多编译器（包括Latex的）都支持。其他的扩展语法可勾可不勾，但需要知道的是这些语法是Typora才有的，换成Latex语法或者其他的Markdown编辑器都是不支持的，仅是为了方便你使用。</li><li>“外观” - “字体大小” 可以改成自定义，自行调整大小，我用的16-17。</li></ol><h2 id="Markdown的语法"><a href="#Markdown的语法" class="headerlink" title="Markdown的语法"></a>Markdown的语法</h2><p>Markdown本身的语法很简单，基本常用就是以下几个：（没列出来的一般就用的比较少了）</p><div class="table-container"><table><thead><tr><th>语法</th><th>备注</th><th>效果</th></tr></thead><tbody><tr><td><code>**加粗**</code></td><td>（快捷键 Ctrl+B）</td><td><strong>加粗</strong></td></tr><tr><td><code>*斜体*</code></td><td>（快捷键 Ctrl+I）</td><td><em>斜体</em></td></tr><tr><td><code>&lt;u&gt;下划线&lt;/u&gt;</code></td><td>（快捷键 Ctrl+U）</td><td><u>下划线</u></td></tr><tr><td>竖杠线（大括号右边那个）</td><td>连续输入三个，每个中间空格，输完回车</td><td>表格</td></tr><tr><td></td><td>（Ctrl+Enter换行）</td><td></td></tr><tr><td><code>-</code>（后面有空格）</td><td>（Tab变子列表）</td><td>无序列表</td></tr><tr><td><code>1.</code>（后面有空格）</td><td>（Tab变子列表）</td><td>有序列表</td></tr><tr><td><code>#</code>（后面有空格）</td><td></td><td>一级标题</td></tr><tr><td><code>##</code>（后面有空格）</td><td>（以此类推，最小6级）</td><td>二级标题</td></tr><tr><td><code>键盘左上角的顿号（波浪号下面那个）</code></td><td>把内容放在两个顿号中间，行内代码</td><td><code>效果</code></td></tr><tr><td><code>键盘左上角的顿号（波浪号下面那个）</code></td><td>连按三个后回车，行间代码，可选择语言(如c,python等)</td><td>同上</td></tr></tbody></table></div><p>比较难记的是数学公式，行内数学公式使用<script type="math/tex">公式</script>输入，行间数学公式使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">公式</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>输入。<strong>数学公式和希腊字母表</strong>见链接：<a href="https://blog.csdn.net/konglongdanfo1/article/details/85204312">markdown公式符号大全_markdown符号-CSDN博客</a>。</p><p>举个例子，常见的二次方程求根公式 $x_{1,2} = \frac{-b \pm \sqrt{b^2-4ac}}{2a}$  在Markdown中的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ x_&#123;1,2&#125;=\frac&#123;-b \pm \sqrt&#123;b^2-4ac&#125;&#125;&#123;2a&#125; $</span><br></pre></td></tr></table></figure><p>在熟练之后，<strong>这套数学公式语法体系将比Mathtype要快上数倍</strong>。</p><h1 id="基于VSCode的Latex编译"><a href="#基于VSCode的Latex编译" class="headerlink" title="基于VSCode的Latex编译"></a>基于VSCode的Latex编译</h1><p>​    同上文一致，Latex也是一种文本语言，但是其结构比Markdown要复杂的多，可以说Markdown就是在Word的基础上加上了Latex的数学公式部分而已。除数学公式外，Latex能通过文本直接定义所生成内容的一切格式，就像在Word中常见的居中、字体、页码、页眉页脚、封面等等一切。Word是一种<strong>所见即所得</strong>的文本语言，而Latex<strong>不是</strong>，也就是说你<strong>所打字打出来的内容同你最终编译得到的内容（在格式方面）千差万别</strong>。</p><p>​    Latex的好处是在经历初期繁琐的设置和一定的学习成本之后，可以让创作者专注于内容本身——因为格式早就已经被写好了。</p><p>​    同Microsoft、WPS、Typora类似，Latex作为一种语言也需要相应的编辑器支持，比较常用的有简单易上手的在线编辑器Overleaf（但是因为在网页端所以存在大小限制问题），专门的TEX编辑器TexStudio（本人刚上手用的时候一直报错遂放弃），以及理工科代码领域的神，大名鼎鼎的万能软件<strong>VSCode</strong>（值得一提的是，他同样也可以当做Markdown编辑器）。</p><h2 id="下载与环境配置"><a href="#下载与环境配置" class="headerlink" title="下载与环境配置"></a>下载与环境配置</h2><ul><li>本小节参考知乎<a href="https://zhuanlan.zhihu.com/p/166523064">Visual Studio Code (vscode)配置LaTeX - 知乎</a></li></ul><h3 id="TexLive的下载与安装"><a href="#TexLive的下载与安装" class="headerlink" title="TexLive的下载与安装"></a>TexLive的下载与安装</h3><p>​    编辑Latex所需要环境和语言有很多种可选，比如MikTex、TexLive等，具体区别可参考<a href="https://www.cnblogs.com/liuliang1999/p/12656706.html">（译）在Windows上使用TeX：TeX Live与MiKTeX的对比 - gisliuliang - 博客园</a>。这里以TexLive为例进行安装和使用。</p><p>​    TexLive的下载网址在这：<a href="https://tug.org/texlive/acquire-iso.html">Acquiring TeX Live as an ISO image - TeX Users Group</a>。当然如果网络不行的话，可以选择开源的镜像网站进行下载，也就是该网页中自带的“download from a nearby CTAN mirror”。所需要下载的文件是”TexLive-版本号.iso“这一光盘映像文件，这个文件极大，可能需要下载几十分钟。</p><p>​    下载完成后，进入该映像文件，选择 <strong>“install-tl-windows”</strong> 文件，为了后面不必要的麻烦，右键<strong>以管理员身份运行</strong>。在所出现的安装界面Installer中，仅需要更改两个内容：<strong>安装位置</strong>和<strong>取消勾选“安装TexLive前端”</strong>。（本文中所使用的前端就是VSCode，所需无需TexLive自带的前端）。安装过程如下图所示：</p><p><img src="\image\latex01.png" alt=""></p><p>​    这个下载的过程极久，总用时从大几十分钟到几个小时不等。安装结束后会出现<code>running mktexlsr ‘安装目录’</code>的字样，这是配置文件的写入。出现“欢迎进入Latex的世界”表明安装成功。可以在命令行窗口（Win+R → cmd）输入<code>xelatex -v</code>来确认安装版本和完成情况。</p><h3 id="VSCode的下载与环境配置"><a href="#VSCode的下载与环境配置" class="headerlink" title="VSCode的下载与环境配置"></a>VSCode的下载与环境配置</h3><p>​    如果你没有VSCode，那么直接上官网下载即可，记得更改相应的安装路径，并在安装时勾选“<strong>添加到PATH</strong>”。如果你忘记了自己是否将其添加到Path内，则在此电脑或Win中搜索“环境变量”后，查看<code>Path</code>内是否含有VSCode的安装路径（精确到<code>bin</code>），如下图。如果没有，新建添加进去即可，比如我的环境变量是<code>D:\Microsoft VS Code\bin</code>。</p><p><img src="\image\latex02.png" alt=""></p><ol><li><p><strong>中文插件：</strong></p><p>为安装相应的中文扩展，在VSCode的扩展栏中输入<code>Chinese</code>搜索，安装<code>Chinese (Simplified) Language Pack for Visual Studio Code</code>插件，重启VSCode后生效。</p></li><li><p><strong>Latex插件：</strong></p><p>在VSCode的扩展栏中输入<code>latex</code>搜索，安装<code>Latex Workshop</code>插件，直接生效。</p></li><li><p><strong>设置：</strong></p><ol><li><p>点击VSCode左下角的齿轮图案，选择<code>设置</code>。在右上角找到<code>打开设置(json)</code>的图标并单击，进入VSCode的json配置界面<code>settings.json</code>。如果是新的Latex，那么现在所呈现的内容将只有一段花括号。</p></li><li><p>输入以下内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Latex settings:</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.autoBuild.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.showContextMenu&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.intellisense.package.enabled&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.message.error.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.message.warning.show&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">false</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;latexmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;-synctex=1&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-interaction=nonstopmode&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-file-line-error&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-pdf&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;-outdir=%OUTDIR%&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;%DOCFILE%&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.recipes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;XeLaTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;PDFLaTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;BibTeX&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;LaTeXmk&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;latexmk&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;xelatex -&gt; bibtex -&gt; xelatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;xelatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pdflatex -&gt; bibtex -&gt; pdflatex*2&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;tools&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;bibtex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span><span class="punctuation">,</span></span><br><span class="line">                <span class="string">&quot;pdflatex&quot;</span></span><br><span class="line">            <span class="punctuation">]</span></span><br><span class="line">        <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.clean.fileTypes&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="string">&quot;*.aux&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.bbl&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.blg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.idx&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ind&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.lof&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.lot&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.out&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.toc&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.acn&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.acr&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.alg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.glg&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.glo&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.gls&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.ist&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.fls&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.log&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;*.fdb_latexmk&quot;</span></span><br><span class="line">    <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.autoClean.run&quot;</span><span class="punctuation">:</span> <span class="string">&quot;onFailed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.latex.recipe.default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lastUsed&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;latex-workshop.view.pdf.internal.synctex.keybinding&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ctrl-click&quot;</span> <span class="comment">// 我把原配置double-click改成了ctrl-click，这个是编译生成的pdf结果如何定位到原文的快捷键，个人习惯ctrl+click</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><p><strong>注：</strong></p><ol><li>本人一般都使用VSCode作为默认的PDF查看器，所以这段代码<strong>不包含外部PDF查看器的设置和使用</strong>，通常这二者是冲突的，即最好不要在使用其他软件打开所编译的PDF的情况下进行Latex的编译。</li><li>根据 json 文件编写规则，<strong>每个代码语句（除了代码块儿最后一句）都需要加上英文状态下的<code>,</code></strong>，否则就会报错；而每个代码块儿的最后一句是不需要加上<code>,</code>的。从上文整个代码块儿可以看出此规则。所以当你日后再次更改json文件为其他插件进行配置时，记得在最后加上<code>,</code>。</li><li>代码块解读请参考<a href="https://zhuanlan.zhihu.com/p/166523064">Visual Studio Code (vscode)配置LaTeX - 知乎</a>的6.2小节或其他相关文章。每篇教程所给出的latex配置json文件会有部分差异，所以为了日后使用建议还是读一下。</li></ol><h2 id="以电气学院毕设为例的Latex使用"><a href="#以电气学院毕设为例的Latex使用" class="headerlink" title="以电气学院毕设为例的Latex使用"></a>以电气学院毕设为例的Latex使用</h2><h3 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h3><ol><li>首先下载浙大电气学院下的毕设模板latex包（下载地址为<a href="http://ee.office.zju.edu.cn/2024/1028/c33877a2981079/page.htm">关于公布《电气工程学院2025届本科生毕业设计（论文）工作管理实施细则》的通知（更新）</a>，需内网，同毕设模板一起），解压得到如下文件夹（我是编译过了所以多了些奇奇怪怪的文件，不用在意）。其中<code>body</code>文件夹存放主要的文章内容，<code>figure</code>文件夹存放文章图片，是两个比较常用的子文件夹。</li></ol><p><img src="\image\latex05.png" alt=""></p><ol><li><p>使用VSCode打开<code>zjuthesis</code>这一整个文件夹（文件夹名字如果不是zjuthesis而是后面有一堆什么version的也一样，无所谓），并使用VSCode双击打开后缀是<code>tex</code>的文件<code>zjuthesis.tex</code>。这个tex文件是整个毕设论文的总配置文件，后面所有的子文件都被该主文件调用才能进行编译。</p></li><li><p>点击VSCode右上角的绿色小三角形<code>Build Latex project</code>。</p><ol><li>如果VSCode的左下角开始转圈，一会儿后文件夹中多了一堆同名不同后缀的文件，主要关注<code>zjuthesis.pdf</code>，则表明编译成功。可以用VSCode打开该PDF文件，并左右分屏（如下图），实现左边输入，右边观测输出的写作模式。</li><li>如果没有任何反应，在搜索栏搜索<code>settings.json</code>，并重新复制上面的一长串代码后再次尝试（原因是zjuthesis可能自带了一个配置文件）。</li><li>如果还不行，可尝试的操作有：1）删去<code>.latexmkrc</code>；2）在其他教程上搜索一份<code>settings.json</code>的配置代码放入。</li><li>如果之前存在<strong>编译出错或长时间编译失败</strong>的问题，建议打开左侧的Latex扩展，选择<code>清理辅助文件</code>进行重置。此外，建议<strong>打开VSCode下方的命令行窗口中的<code>输出</code>栏</strong>，查看编译过程信息，若有编译问题会显示问号<code>?</code>。</li></ol></li></ol><p><img src="\image\latex06.png" alt=""></p><ol><li><p>这里以<strong>电气工程学院ee的本科生undergraduate毕业设计的最终版本final</strong>（而非开题版本）进行演示。<code>zjuthesis.tex</code>文件中包含了作者的一些基本信息和文件调用，原作者有比较详细的注释，跟着填写即可，编译后右侧的PDF会同步更新。</p></li><li><p>下面这些代码无需更改，但是需要看一下，只要稍微有点英文和代码基础都能理解。</p><ol><li><code>\newcommand&#123;\inputundergraduate&#125;</code>，很明显，这启用了一个新的代码块，这段代码块将其他文件夹下<code>undergruduate</code>的部分引用了进来。下面还有一个类似的<code>\newcommand</code>，但是那个是研究生的。因为我们已经在上面设置过我们是<code>undergraduate</code>，所以只需要关注这里的就行。</li><li><code>\ifthenelse&#123;\equal&#123;\Period&#125;&#123;final&#125;&#125;</code>， <code>\newcommand&#123;\undergradcurrstage&#125;&#123;final&#125;</code>，我们是最终版本而不是开题，所以选择<code>final</code>而不是<code>proposal</code>，所以这只需要关注这一块即可。</li><li><code>\inputpage&#123;final&#125;&#123;cover&#125;</code>，说明我们的文章构成中有<code>cover</code>这一个东西。这个东西也是他帮你生成好了的。</li></ol></li></ol><p><img src="\image\latex04.png" alt=""></p><ol><li><strong>那我们要改那些地方呢？</strong>——主文件<code>zjuthesis.tex</code>和你所使用的文件夹中的所有<code>.tex</code>文件就是你的内容，在本例中，就是<code>zjuthesis/undergraduate/final</code><strong>里面的所有文件，包含<code>abstract.tex</code>（摘要）、<code>content.tex</code>（目录和主体内容）等</strong>。下面一节将具体讲解在写毕设论文的时候，该如何使用它去写。</li></ol><h3 id="手把手教你写毕设"><a href="#手把手教你写毕设" class="headerlink" title="手把手教你写毕设"></a>手把手教你写毕设</h3><p>现在，可以用latex原文+pdf编译结果的双屏显示来快速熟悉该毕设的代码架构了。</p><ol><li><p>完善填写<code>zjuthesis.tex</code>中的个人基本信息，填写完成后编译查看是否有问题。</p></li><li><p>顺着PDF的结构往下阅读，可以对PDF中的文字使用<code>Ctrl+Click</code>或<code>double Click</code>来<strong>快速跳转到PDF文件对应的Latex原文</strong>。</p><ol><li>快捷键取决于<code>settings.json</code>中最后一行设置的<code>latex-workshop.view.pdf.internal.synctex.keybinding</code>是哪个）。</li><li>可以在左侧的<strong>资源管理器中看到文件所处的位置和文件名</strong>，<strong>一般需要自己改动的文件存在上文介绍的文件夹<code>\final</code>中，不需要自己改动的文件存在<code>\page</code>中</strong>。</li><li>一般而言，<strong>在标题、作者等这类属于“论文基本信息”的位置，很多Latex模板（包括上面的毕设模板）都采取的是“先定义、后调用”的方式</strong>，所以使用该双向定位可能不准。如果跳转到了<code>\page</code>下的文件中，说明实际需要修改的位置不在这里。</li></ol></li></ol><p><img src="\image\latex07.png" alt=""></p><ol><li>目录是自动生成的（作者写好相应的代码了），无需改动</li><li><strong>文章的主体内容章节存在<code>content.tex</code>文件中</strong>，打开即可看到如下图所示界面。<ol><li><strong>很容易知道里面所示的<code>instructions</code>、<code>introductions</code>等四部分就是<code>zjuthesis.pdf</code>生成的四个章节（第一到四章）</strong>。所以可以在这里增/删/改内容以实现文章主要内容的替换。</li><li>个人建议可以先保留原文的几个章节，因为这几个章节中有一小部分Latex代码的语法说明，可以帮助你进行上手和学习。复制其中的某一章节，重命名为<code>Chapter1_Introduction</code>并仿照格式插入到<code>content.tex</code>中，并将其中的非代码部分替换为自己的内容即可得到所需内容。</li></ol></li></ol><p><img src="\image\latex08.png" alt=""></p><h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><div class="table-container"><table><thead><tr><th>快捷键</th><th>作用</th><th>备注</th></tr></thead><tbody><tr><td>Ctrl+Alt+B</td><td>编译Latex（等同于右上方的绿色小三角）</td><td>觉得难按的可以在<code>文件-首选项-键盘快捷方式</code>中进行替换</td></tr><tr><td>Ctrl+Alt+J</td><td>从Latex文件位置快速定位到PDF位置</td><td>同上</td></tr><tr><td>Ctrl+Click</td><td>从PDF位置快速定位到Latex文件位置</td><td>快捷键取决于<code>settings.json</code>最后一行</td></tr></tbody></table></div><h2 id="如何使用期刊的Latex模板"><a href="#如何使用期刊的Latex模板" class="headerlink" title="如何使用期刊的Latex模板"></a>如何使用期刊的Latex模板</h2><ul><li><strong>毕设论文的模板使用比期刊复杂的多得多</strong>，因为毕设论文太长了，格式要求也很多，而期刊短得多！</li></ul><ol><li><p>首先找到你所需要投稿的期刊的Latex模板，下面给出一些常用的检索方法：</p><ol><li>IEEE的论文期刊模板： <a href="https://template-selector.ieee.org/secure/templateSelector/publicationType">IEEE-Template Selector</a></li><li>SCI的论文期刊模板：<a href="https://www.letpub.com.cn/index.php?page=journalapp">【LetPub】最新SCI期刊影响因子查询及投稿分析系统（2024-2025年） - LetPub</a>，进去选择期刊后可以在作者指南或者期刊官网中找</li><li>期刊官网（很多中文期刊没有Latex模板，英文的基本都有）</li></ol></li><li><p>以IEEE为例演示如何下载期刊的Latex模板</p><ol><li>进入上文给出的IEEE论文期刊模板网站</li><li>在这里搜索你所投稿的期刊名，如<code>IEEE Electrification Magzine</code>（IEEE 电气化杂志），下载</li><li>下载完成后解压得到如下文件夹，可以看到非常的简洁</li></ol></li><li><p>如何使用期刊的Latex模板</p><ol><li><p>使用VSCode打开该<strong>文件夹</strong></p></li><li><p>可以看到里面只有两个<code>.tex</code>后缀的文件，其中一个文件名是<code>how-to</code>，很明显不是正文，所以打开另一个。</p></li><li><p>打开后得到如下界面，啥也别管先编译一遍，生成同名的<code>.pdf</code>文件，双屏打开，到这一步没有问题那就成功90%了。</p><p><img src="\image\latex09.png" alt=""></p></li><li><p>使用上文的快捷键可以快速实现Latex代码和PDF位置的<strong>双向定位</strong>，以供你得知什么地方需要修改。值得注意的是，<strong>在标题、作者等这类属于“论文基本信息”的位置，很多Latex模板（包括上面的毕设模板）都采取的是“先定义、后调用”的方式</strong>，所以使用该双向定位可能不准。</p></li></ol></li></ol><h1 id="Latex的基本语法"><a href="#Latex的基本语法" class="headerlink" title="Latex的基本语法"></a>Latex的基本语法</h1><ul><li>Latex的语法很多，没必要一口气学完。可以先看看下面的基础语法，当你需要更加精细的格式设置时，再上网搜索使用和设置方法，现学现用会更好。</li></ul><h2 id="换段落与换行"><a href="#换段落与换行" class="headerlink" title="换段落与换行"></a>换段落与换行</h2><p>可以用<code>\newline</code>，但<strong>一般使用空行进行新建段落</strong>。比如：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段落1的内容</span><br><span class="line"></span><br><span class="line">段落2的内容 <span class="comment">% 中间需要空一行才能正常生成2段</span></span><br></pre></td></tr></table></figure><p>​    这个有什么用呢，就是一般我们写完<strong>数学公式</strong>的时候下面会紧跟着，“式中，$\sigma$表示……”这种<strong>不空两格的解释语句</strong>，那么这个时候这段话与数学公式间就不要空行，<strong>这样生成的内容就会顶格而非空两格</strong>。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>大标题 <code>\section</code></p><p>然后是 <code>\subsection</code>，<code>\subsubsection</code>，我记得最多就到这了，也就是最后会生成<code>1.1.1 xxxxx</code>这样的标题</p><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p>一般而言需要乱动字体的情况不多，一般也不建议乱动。</p><p>最常用的就是<strong>加粗</strong>，在Latex中表示为<code>\textbf&#123;加粗内容&#125;</code>。此外可能会用到<em>斜体</em>，在Latex中表示为<code>\itshape&#123;斜体内容&#125;</code>。</p><p>EE学院提供的zjuthesis对字体（在你看不见的定义文件中）做了比较详细的定义，所以可能存在部分函数是zjuthesis独有的（自定义了一些函数），在其他Latex文件中不适用。默认英文字体为新罗马 Times New Roman，默认正文中的中文字体为仿宋，应该都不需要咋改。</p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;enumerate&#125;[label=<span class="keyword">\textbf</span>&#123;(<span class="keyword">\alph</span>*)&#125;]  <span class="comment">% itemize为无序列表，[]内为备注和格式设置</span></span><br><span class="line">    <span class="keyword">\item</span> 第一段；  <span class="comment">% \item 表示另起一段</span></span><br><span class="line">    <span class="keyword">\item</span> 第二段。</span><br><span class="line"><span class="keyword">\end</span>&#123;enumerate&#125;</span><br></pre></td></tr></table></figure><ul><li>详细配置可参考：<a href="https://zhuanlan.zhihu.com/p/350596731">LaTeX 排版（1）：列表 | Linux 中国 - 知乎</a></li></ul><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;figure&#125;[!ht]  <span class="comment">% 可选参数有：!htbp</span></span><br><span class="line">    <span class="keyword">\centering</span>  <span class="comment">% 居中</span></span><br><span class="line">    <span class="keyword">\includegraphics</span>[width=.8<span class="keyword">\linewidth</span>]&#123;example/texlive-image.png&#125;  </span><br><span class="line">    <span class="comment">% 图片宽度设置为0.8的页宽，图片位置为\figure\example\texlive-image.png</span></span><br><span class="line">    <span class="keyword">\caption</span>&#123;清华开源镜像站Texlive&#125;  <span class="comment">% 图片下面的标题（序号自动生成）</span></span><br><span class="line">    <span class="keyword">\label</span>&#123;fig:texlive-image&#125;  <span class="comment">% 图片的标签，用于引用图片，详见下文引用</span></span><br><span class="line"><span class="keyword">\end</span>&#123;figure&#125;</span><br></pre></td></tr></table></figure><ul><li><p>详细配置可参考：<a href="https://blog.csdn.net/qq_31347869/article/details/103832190">LaTex的使用（一）：图片的插入及排版方法_latex图片排版-CSDN博客</a></p></li><li><p>关于Latex进行<strong>多行多列</strong>的图片排版（比如常见的<code>图1.1 (a)aaa (b)bbb</code>），建议参考这个<a href="https://blog.csdn.net/binbinczsohu/article/details/109900248">关于Latex并排多张图片及加入图片说明的方法_latex图片说明-CSDN博客</a></p></li></ul><h2 id="表格（三线表）"><a href="#表格（三线表）" class="headerlink" title="表格（三线表）"></a>表格（三线表）</h2><p>一般而言论文中的表格都是三线表</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;table&#125;[H]</span><br><span class="line"><span class="keyword">\caption</span>&#123;Example 1&#125;  <span class="comment">% 表格上方的标题</span></span><br><span class="line"><span class="keyword">\centering</span>  <span class="comment">% 居中</span></span><br><span class="line"><span class="keyword">\label</span>&#123;tab:sample&#125;  <span class="comment">% 表格的标签，用于引用表格，详见下文引用</span></span><br><span class="line"><span class="keyword">\begin</span>&#123;tabular&#125;&#123;cccc&#125; <span class="comment">% 四个c代表该表一共四列，内容全部居中</span></span><br><span class="line"><span class="keyword">\toprule</span> <span class="comment">% 第一道横线，下面写表格的第一行（标题行）</span></span><br><span class="line">Item 1 <span class="built_in">&amp;</span> Item 2 <span class="built_in">&amp;</span> Item 3 <span class="built_in">&amp;</span> Item 4 <span class="keyword">\\</span>  <span class="comment">% 用&amp;分割内容，双斜杠表示换行</span></span><br><span class="line"><span class="keyword">\midrule</span> <span class="comment">% 第二道横线 </span></span><br><span class="line">Data1 <span class="built_in">&amp;</span> Data2 <span class="built_in">&amp;</span> Data3 <span class="built_in">&amp;</span> Data4 <span class="keyword">\\</span>  <span class="comment">% 用&amp;分割内容，必须与上文一一对应</span></span><br><span class="line">Data5 <span class="built_in">&amp;</span> Data6 <span class="built_in">&amp;</span> Data7 <span class="built_in">&amp;</span> Data8 <span class="keyword">\\</span></span><br><span class="line"><span class="keyword">\bottomrule</span><span class="comment">%第三道横线</span></span><br><span class="line"><span class="keyword">\end</span>&#123;tabular&#125;</span><br></pre></td></tr></table></figure><ul><li>详细配置可参考：<a href="https://blog.csdn.net/qq_37707218/article/details/107393636">Latex中经典三线表、多线表、内容跨行/跨列复杂表的详解与源代码_latex toprule-CSDN博客</a>，其中包含三线表中标题行需要有<strong>多行、多列的特殊情况</strong>，笔者在论文中也有使用。</li></ul><h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\begin</span>&#123;equation&#125;</span><br><span class="line">    <span class="keyword">\label</span>&#123;equ:sample&#125;  <span class="comment">% 公式的标签，用于引用公式，详见下文引用</span></span><br><span class="line">    A=<span class="keyword">\overbrace</span>&#123;(a+b+c)+<span class="keyword">\underbrace</span>&#123;i(d+e+f)&#125;<span class="built_in">_</span>&#123;<span class="keyword">\text</span>&#123;虚数&#125;&#125;&#125;<span class="built_in">^</span>&#123;<span class="keyword">\text</span>&#123;复数&#125;&#125;  <span class="comment">% 公示内容，自动编号</span></span><br><span class="line"><span class="keyword">\end</span>&#123;equation&#125;</span><br></pre></td></tr></table></figure><ul><li>关于数学公式符号语法，若有遗忘，可以参考：<a href="https://blog.csdn.net/Yushan_Ji/article/details/134322574">Latex数学公式符号大全（超详细）_latex数学符号-CSDN博客</a></li><li>关于数学公式的换行问题，可以参考：<a href="https://blog.csdn.net/puchapu/article/details/86543580">Latex公式排版（编号、换行、括号内换行、对齐）_latex公式换行编号合并-CSDN博客</a></li></ul><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>​    <strong>数学公式、图片和表格的引用</strong>使用<code>\autoref</code>命令，如<code>如\autoref&#123;code:sample&#125;所示，这是一段代码。</code>，其中的<code>code:sample</code>是你在输入公式时给他写的<code>\label&#123;&#125;</code>。如果公式没有写这个，那么无法引用。</p><p>​    个人的强烈建议：可以给公式的<code>\label</code>全都命名成<code>equ:Name</code>的格式，图片<code>fig:Name</code>的格式，表格<code>tab:Name</code>的形式，方便引用。Name可以和你的图、表、公式标题一致或类似，方便引用的时候查找。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li>参考文献列在<code>ref.bib</code>中，不同于以往任何一个引用格式，BibTex是专门为Latex设计的参考文献格式，知网、谷歌学术等知名论文浏览平台均可以直接下载到所需文献的BibTex参考文献格式。复制进去即可。</li><li>需要注意的是，可能需要根据学校或者论文的要求，<strong>对BibTex中所列明的参考文献条目进行删改</strong>。比如，学校的毕设论文不要求DOI，但是有些参考文献在复制BibTex格式时就会自带DOI，这个时候需要<strong>手动删除</strong>。</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@article&#123;example2,</span><br><span class="line">  title = &#123;Energy peer-to-peer trading in virtual microgrids in smart grids: a game-theoretic approach&#125;,</span><br><span class="line">  journal = &#123;IEEE Transactions on Smart Grid&#125;,</span><br><span class="line">  author = &#123;Kelvin Anoh and Sabita Maharjan and Augustine Ikpehai and Yan Zhang and Bamidele Adebisi&#125;,</span><br><span class="line">  year = &#123;2019&#125;,</span><br><span class="line">  urldate = &#123;2024-10-31&#125;,</span><br><span class="line">  doi = &#123;10.1109/TSG.2019.2934830&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>参考文献的<strong>引用标签</strong>就是BibTex中第一行，<code>&#123;</code>后面紧跟的内容。这段内容是你<strong>唯一可以且需要更改</strong>的地方。为了方便引用，非常建议<strong>统一参考文献的引用标签格式</strong>，比如常见的“论文作者+论文时间”的格式<code>Paradox2025</code>，或其他你自己喜欢的格式。</li><li>比如上面这个参考文献，引用方式应该是：</li></ul><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文献<span class="keyword">\parencite</span>&#123;example2&#125;中新的实验结论表明，Paradox是最阴暗的下水道鼠鼠<span class="keyword">\cite</span>&#123;example2&#125;。</span><br></pre></td></tr></table></figure><ul><li>生成的内容如下（这两种引用方式的区别应该很明显了）：</li></ul><p>文献${[1]}$中提出了一种新的实验结论，即Paradox是最阴暗的下水道鼠鼠$^{[1]}$。</p><ul><li>Latex会依据你的引用顺序进行自动标号。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 软件教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Latex </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纯小白也能变大画师？StableDiffusion：AI绘画的神！</title>
      <link href="/2023/10/02/AI%E7%BB%98%E7%94%BB/"/>
      <url>/2023/10/02/AI%E7%BB%98%E7%94%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><ul><li><p>Stable Diffusion是一个极其强大的AI绘画工具整合包（开源项目），大菩萨UP主秋葉aaaki根据整合包创作了一个非常牛逼的网页启动器，包含了版本更新、插件下载、报错检测等等，并涵盖了很多插件；而大佛祖UP主Nenly同学上传了一套极为详细的使用教程。因为现在AI绘画的行业还处在起步的阶段，行业内并不规范，因此这里仅以秋葉aaaki提供的启动器和整合包进行创作，更复杂的我也不会。在机缘巧合之下我才接触到这个神奇的东西，因为之前一直没有关注、没有实践，所以现在尝试一下纯小白上手，绘制出属于自己的AI画作。</p></li><li><p>相比于教程，本篇更像是一个个人使用的经历。因此暂时只涉及AI绘画的尝试，并不涉及模型调教（带佬可以试试自己跑一个模型出来）</p></li><li><p>推荐关注UP主“秋葉aaaki”和“Nenly同学”，以及这里放一些他们的教程合集。本篇博客以秋葉提供的整合包做安装和基本入门，加以Nenly的更为细致的教学。</p></li></ul><hr><ul><li>秋葉aaaki</li></ul><p>【前置要求】</p><p>一个流畅的翻墙软件，在很多地方，这个东西需要科学上网。</p><p>【新手快速入门】<br>全套入门教程：<a href="https://www.bilibili.com/read/cv22159609">https://www.bilibili.com/read/cv22159609</a><br>快速入门生成图片：<a href="https://www.bilibili.com/read/cv22661198">https://www.bilibili.com/read/cv22661198</a><br>模型安装使用教程：<a href="https://www.bilibili.com/read/cv21362202">https://www.bilibili.com/read/cv21362202</a><br>2023年4月模型分享：<a href="https://www.bilibili.com/video/BV1em4y1z7Dg">https://www.bilibili.com/video/BV1em4y1z7Dg</a></p><p>【常用网站】<br>AI 作图知识库(教程): <a href="https://guide.novelai.dev/">https://guide.novelai.dev/</a><br>标签超市(解析组合): <a href="https://tags.novelai.dev/">https://tags.novelai.dev/</a><br>原图提取标签: <a href="https://spell.novelai.dev/">https://spell.novelai.dev/</a></p><p>【细致教程】<br>入门参数设置基础：<a href="https://guide.novelai.dev/guide/configuration/param-basic">https://guide.novelai.dev/guide/configuration/param-basic</a><br>常见安装问题: <a href="https://guide.novelai.dev/s/troubleshooting/install">https://guide.novelai.dev/s/troubleshooting/install</a><br>常见跑图问题: <a href="https://guide.novelai.dev/s/troubleshooting/generate">https://guide.novelai.dev/s/troubleshooting/generate</a><br>怎么写提示词？ <a href="https://guide.novelai.dev/advanced/prompt-engineering/">https://guide.novelai.dev/advanced/prompt-engineering/</a><br>怎么训练模型？ <a href="https://guide.novelai.dev/advanced/finetuning/">https://guide.novelai.dev/advanced/finetuning/</a><br>最新消息: <a href="https://guide.novelai.dev/newsfeed">https://guide.novelai.dev/newsfeed</a></p><p>【问题速查】</p><ul><li>CUDA out of memory： 炸显存 换启动参数 换显卡</li><li>DefaultCPUAllocator: 炸内存 加虚拟内存 加内存条</li><li>CUDA driver initialization failed: 装CUDA驱动</li><li>Training models with lowvram not possible: 这点显存还想炼丹？</li><li>WinError 5: 建议重装电脑，或者等下一个整合包</li></ul><hr><ul><li>Nenly同学</li></ul><a class="btn-beautify center" href="https://www.bilibili.com/video/BV1As4y127HW" title="Click"><i class="far fa-hand-point-right"></i><span>Click</span></a><p>【资料下载】</p><p><a href="https://nenly.notion.site/017c3341c8b84a7ebb4c2cb16f36e28f">https://nenly.notion.site/017c3341c8b84a7ebb4c2cb16f36e28f</a></p><h1 id="软件及插件的安装"><a href="#软件及插件的安装" class="headerlink" title="软件及插件的安装"></a>软件及插件的安装</h1><p>​    这里涉及到两个，一个是这个软件（绘世启动器及整个整合包），这个整个东西非常大，因此建议找一个空的盘安装；另一个是非常好用的ControlNet插件，第一次上手可以先跳过这一部分，等把软件搞明白了再来看插件。<strong>我暂且推荐用我给你们的百度网盘链接下载安装</strong>，因为我这个已经做好了非常好的汉化、UI改善和更新，并且具有了绝大部分的常用插件，非常方便。或者是根据秋葉的整合包下载安装（秋葉神中神），当然你可以在很多地方找到这个整合包，因为他是开源的，但是这会给后续的使用带来不便。</p><h2 id="绘世启动器-amp-整合包安装"><a href="#绘世启动器-amp-整合包安装" class="headerlink" title="绘世启动器&amp;整合包安装"></a>绘世启动器&amp;整合包安装</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>​    因为这个东西迭代更新速度很快，秋葉的大部分教程可能都还是version2、version3的软件，现在已经更新到version4.4了。可以考虑跟着他比较新的一个视频来进行安装。</p><a class="btn-beautify center" href="https://www.bilibili.com/video/BV1iM4y1y7oA" title="Click"><i class="far fa-hand-point-right"></i><span>Click</span></a><p>或者我这里也有一个v4.1的版本，安装完成之后可以进去直接更新，效果是一样的。</p><p>链接：<a href="https://pan.baidu.com/s/1EIV7MvfHqQRMsJ8pAmUSMA">https://pan.baidu.com/s/1EIV7MvfHqQRMsJ8pAmUSMA</a><br>提取码：72cj<br>—来自百度网盘超级会员V4的分享</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>以我发的百度网盘连接为例进行安装。下载完成之后大概是一个这样子的文件结构：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sd-webui-aki</span><br><span class="line"><span class="code">|--可选controlnet1.1</span></span><br><span class="line"><span class="code">|--启动器运行依赖.exe</span></span><br><span class="line"><span class="code">|--sd-webui-aki-v4.1.zip</span></span><br></pre></td></tr></table></figure><p>​    双击启动器运行依赖.exe自动完成安装，然后解压v4.1.zip压缩包，找到下面的“A启动器.exe”，双击运行。启动完成后如下图所示，进入左边栏的“版本管理” - “内核” - “稳定版”，点击“切换”即可完成版本切换。（建议使用稳定版而不是开发版本）</p><p><img src="\image\微信图片_20231002123148.png" alt=""></p><h2 id="ControlNet插件"><a href="#ControlNet插件" class="headerlink" title="ControlNet插件"></a>ControlNet插件</h2><p>关于ControlNet插件的安装和使用，可以参考秋葉的这两个视频：</p><p>初代：<a href="https://www.bilibili.com/video/BV1Wo4y1i77v">https://www.bilibili.com/video/BV1Wo4y1i77v</a></p><p>v1.1版本：<a href="https://www.bilibili.com/video/BV1fa4y1G71W">https://www.bilibili.com/video/BV1fa4y1G71W</a></p><p>​    如果你在之前启动器的下载中选择了我的百度网盘链接进行安装，那么想必肯定已经有controlnet1.1的文件夹了。其实就是跳过了初代版本的bag，直接更新了bag而已。</p><ul><li><p>我这里好像默认提供了controlnet的插件，你可以在“版本管理” - “扩展”中找一下是否有controlnet，如果有那么就代表没问题，更新一下即可。如果没有，请参照上文的第一个哔哩哔哩网址视频中<strong>第30秒至第1分07秒</strong>的内容进行插件安装。</p></li><li><p>模型的安装可以直接参考第二个哔哩哔哩网址视频中<strong>第2分18秒至第2分55秒</strong></p></li></ul><h2 id="AI绘画，启动！"><a href="#AI绘画，启动！" class="headerlink" title="AI绘画，启动！"></a>AI绘画，启动！</h2><p>首先开启翻墙软件，然后开启A启动器，点击右下角的“一键启动”。之后会出现一个“控制台”，也就是一个类似于bash文件的东西。第一次启动所需时间可能较久，大概在2-3分钟左右。成功的标志是跳出一个网页。大概长这样：</p><p><img src="\image\微信图片_20231002125925.png" alt=""></p><p>记得不要把控制台关掉哦~</p><h1 id="文生图创作技巧"><a href="#文生图创作技巧" class="headerlink" title="文生图创作技巧"></a>文生图创作技巧</h1><p>文生图创作是AI创作最基本的方式。这部分可以参考秋葉的文档：<a href="https://www.bilibili.com/read/cv22661198">https://www.bilibili.com/read/cv22661198</a></p><p>当然，这里我也会用我自己的语言详细说明。</p><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><ul><li><strong>Stable Diffusion模型：</strong>这个是AI绘画的大模型，一开始进入应该只有一个叫“anything……”什么的模型，这个是一个有名的二次元模型，直接用就好了。如果你是官方版本下载，可能是一个叫官方模组Stable Diffusion的东西。在后文我也会介绍更多的SD模型，相当于使用了不同的画风、不同的创作手法之类，如果你是大佬（大佬应该不会看我这篇文档）可以试试自己调教一个模型出来（就是机器学习的过程），但是本篇不做介绍。</li><li><strong>外挂vae模型：</strong>目前你先直接选择animevae.pt即可</li></ul><h2 id="标签（Tag-amp-Prompt）"><a href="#标签（Tag-amp-Prompt）" class="headerlink" title="标签（Tag&amp;Prompt）"></a>标签（Tag&amp;Prompt）</h2><ul><li><strong>正向提示词Prompt：</strong>选择你想要的内容，英文表述，逗号分隔。比如你想要画面中有一个女的，就写<code>1girl</code>；想要画面以教室为背景，就写<code>classroom</code>，以此类推。</li><li><strong>反向提示词Negative Prompt：</strong>选择你不想要的内容，比如一般可以有如下类似的描述（提供了两个模板）：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((((ugly)))), (((duplicate))), ((morbid)), ((mutilated)), (((tranny))), (((trans))), (((trannsexual))), (hermaphrodite), [out of frame], extra fingers, mutated hands, ((poorly drawn hands)), ((poorly drawn face)), (((mutation))), (((deformed))), ((ugly)), blurry, ((bad anatomy)), (((bad proportions))), ((extra limbs)), cloned face, (((disfigured))),out of frame, ugly, extra limbs, (bad anatomy), gross proportions, (malformed limbs), ((missing arms)), ((missing legs)), (((extra arms))), (((extra legs))), mutated hands, (fused fingers), (too many fingers), (((long neck)))</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lowres, bad anatomy, bad hands, text, error, missing fingers, extra digit, fewer digits, cropped, worst quality, low quality, normal quality, jpeg artifacts, signature, watermark, username, blurry </span><br></pre></td></tr></table></figure><ul><li><strong>进阶使用：</strong>以 girl 这个 Tag 作为例子<ul><li>(girl) 加权重，这里是1.1倍。括号是可以叠加的，如（(girl)) 加很多权重：1.1*1.1=1.21倍。</li><li>[girl] 减权重，一般用的少。减权重也一般就用下面的指定倍数。</li><li>(girl = 1.2)指定权重</li></ul></li><li><strong>标签超市</strong><ul><li><a href="https://tags.novelai.dev/">https://tags.novelai.dev/</a></li><li><a href="https://ai.dawnmark.cn/">https://ai.dawnmark.cn/</a></li><li>进入标签超市，可以根据你的喜好任意选择标签（自己打的时候不知道怎么表述，这里就提供了很多标签和预制的标签组合）这玩意儿的使用非常简单，因为个人觉得很多功能都不需要，只需要知道最基本的几个即可。</li><li>但是吧，我也不知道这个作者怎么想的，为什么感觉很多标签都这么变态啊…估计生产这玩意儿的是个技术高超的二刺猿宅男LSP，这我也莫得什么办法。</li></ul></li></ul><p><img src="\image\微信图片_20231003143640.png" alt=""></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">高标准品质：best quality, masterpiece, highres,</span><br><span class="line">插画风格：paiting, illustration, drawing,</span><br><span class="line">二次元：anime, comic, game CG</span><br><span class="line">写实：photorealistic, realistic</span><br><span class="line">Embeddings：ng<span class="emphasis">_deepnegative_</span>v1<span class="emphasis">_75t, easynegative, EasyNegativeV2, negative_</span>hand, negative<span class="emphasis">_hand-neg, BadDream, Neg_</span>Facelift768, badhandv4 （详见Embeddings章节）</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p><strong>迭代次数：</strong>不需要太大，一般在50以内。通常20~28是一个不错的值。</p></li><li><p><strong>采样器：</strong>采样器没有优劣之分，但是他们速度不同。全看个人喜好。UP主秋葉推荐的有<br>Euler A；DPM++ 2M Karras；DPM++SDE Karras<br>个人也用过DDIM，感觉也还可以。</p></li><li><p><strong>提示词相关性：</strong>提示词相关性代表你输入的 Tag 对画面的引导程度有多大，可以理解为 “越小AI越自由发挥”</p><p>太大会出现锐化、线条变粗的效果。太小AI就自由发挥了，不看 Tag。一般设置在7~12之间。</p></li><li><p><strong>随机种子：</strong>随机种子是 生成过程中所有随机性的源头 每个种子都是一幅不一样的画。默认的 -1 是代表每次都换一个随机种子。由随机种子，生成了随机的噪声图，再交给AI进行画出来。如果你之前跑了一张图感觉很好，想做微调，那么就把那张图的随机种子找出来（图片信息），然后复制进去。</p></li><li><p>没讲到的东西少动点O.o</p></li></ul><h2 id="图片尺寸"><a href="#图片尺寸" class="headerlink" title="图片尺寸"></a>图片尺寸</h2><ul><li>请不要选择过大的图片尺寸，不然AI是跑不出来的。选择比较推荐的尺寸有：512×512；768×1024（或者再砍一半）；1024×768（或者再砍一半）。</li><li>有人会问，如果我觉得太不清晰了怎么办？可以选择一个较小的尺寸，然后开启“高分辨率修复”，其中UP秋葉给出的推荐参数如下图所示：（放大倍数自己定，别太贪心把自己电脑炸了）这部分在本篇博客后续章节“图像の高清修复”中会更加详细地讲述。</li><li><strong>个人建议先选一个小尺寸</strong>，这样子跑的时候就比较快。<strong>如果跑出来一张你觉得比较好的比较喜欢，再点击后期处理</strong>（我这个版本里是图像右下角一个三角尺的标志，叫什么send image … to extra tab；或者你可以在“文生图”边上找到“后期处理”），然后进行放大算法处理。</li><li>当然小尺寸也有缺点，就是当尺寸过小时，很多细节都会跑不出来，这高清修复也修不了。如果电脑显存够建议跑1024左右大小的。</li></ul><p><img src="\image\微信图片_20231002133105.png" alt=""></p><h2 id="启动！"><a href="#启动！" class="headerlink" title="启动！"></a>启动！</h2><p>​    自己随便放了几个关键词跑出来的一张图，整体看着还挺不错了。（其实我用了很多技巧呜呜呜，尤其是AI画手画的真的是一言难尽，天天给我整出六七根手指）想要真正让他跑出一个好图出来，确实很难。</p><p><img src="\image\s1.png" alt=""></p><h1 id="ControlNet美化"><a href="#ControlNet美化" class="headerlink" title="ControlNet美化"></a>ControlNet美化</h1><p>在网页的下方打开ControlNet，出现如下图所示的内容（具体格式可能每个人有差别，但大差不差，这里演示的是1.1版本）。</p><p><img src="\image\微信图片_20231002153828.png" alt=""></p><p>​    下面的操作想必大部分人看名字都能看懂什么意思，基本上就是控制<strong>“预处理器影响效果的强弱”</strong>。另外，低显存模式（在显存不够的时候降速）和允许预览应该都能理解，完美像素模式比较强大，大致就是会自动计算预处理的最优像素，建议勾选。</p><p>​    这里详细说明一下各个预处理器和模型的功能。这个插件的功能就是，把你的输入图片经过某个预处理器进行处理，得到一张效果图，然后网站在根据你这张效果图的指导生成新的图片。</p><ul><li><p>操作方式：根据你想要实现的效果选择对应的预处理器，然后选择与预处理器同名的模型，放入图片即可。</p></li><li><p>更加详细的理解和应用可以参考Nenly的教程：</p></li></ul><a class="btn-beautify center" href="https://www.bilibili.com/video/BV1Ds4y1e7ZB" title="Click"><i class="far fa-hand-point-right"></i><span>Click</span></a><ul><li>这里会着重挑选几个常用的、易用的预处理器和使用方法进行讲解。（任何一个效果在第一次使用、生成的时候都会非常卡，这是正常的）</li></ul><h2 id="Openpose"><a href="#Openpose" class="headerlink" title="Openpose"></a>Openpose</h2><p>Openpose预处理器是指导动作骨架，放入一张真人图片，然后他会根据真人图片生成骨骼，再根据骨骼指导人物动作来AI作画。如图所示：</p><div class="table-container"><table><thead><tr><th>引导图</th><th>骨骼</th><th>创作结果</th></tr></thead><tbody><tr><td><img src="\image\微信图片_20231002160402.png" alt=""></td><td><img src="\image\tmpjp_dhaa1.png" alt=""></td><td><img src="\image\s2.png" alt=""></td></tr></tbody></table></div><p>​    不同的Openpose预处理器可以产生不同的骨骼图，大家根据上面的英文后缀或者中文翻译应该都能非常好理解，比如是否带上手部动作、脸部表情等等。</p><h2 id="Depth"><a href="#Depth" class="headerlink" title="Depth"></a>Depth</h2><p>Depth顾名思义，深度。在一张图片中，计算机其实并不能很好的识别空间关系，经常把他当成二维图像来处理。举个例子，在Openpose预处理器中你选了一张手放在额头上的照片，但是AI跑出来手放在了后脑勺上。从骨骼图上讲，这两个是一样的，区别就是手和头部的空间关系。显然，单纯的Openpose并不具备空间处理的能力。</p><p>Depth下也有很多预处理器，其中最强的是Leres++，但是相应的速度也会变慢。在空间关系不那么复杂的情况下，可以考虑使用Zoe或者Medas来处理图像。（比如上述照片，用Depth处理或许就能得到比Openpose更加好的结果）</p><div class="table-container"><table><thead><tr><th>原图</th><th>深度图（Medas）</th><th>创作结果</th></tr></thead><tbody><tr><td><img src="\image\back.png" alt=""></td><td><img src="\image\image.png" alt=""></td><td><img src="\image\home.png" alt=""></td></tr></tbody></table></div><p>（看上去AI跑的没有原图牛逼，实际上不是AI的问题，是原图的pixiv画师太特么牛的）</p><h2 id="Canny及其拓展"><a href="#Canny及其拓展" class="headerlink" title="Canny及其拓展"></a>Canny及其拓展</h2><p>Canny是一种边缘检测算法，致力于边缘检测、识别图像特征。在刚刚的Depth里面我们就可以看到，生成图少了很多的细节，这是因为Depth识别的是大体的空间关系，如果想要识别更加多的细节，那么就使用Canny吧。</p><ul><li>Canny：将图像经过处理形成一张白底黑线的边缘图，然后根据边缘图和你的提示词来进行图片的生成。下面有两个阈值（Threshold）调节滑块，如果觉得线条太少就把阈值拉低，线条太多就把阈值拉高。</li><li>Invert：原理一样，但是有的时候我们使用的是白底黑线的素描线稿图（类似于你画的草稿），这个时候Canny由于算法的问题会识别的比较模糊，于是这个时候我们把预处理器改成Invert。</li><li>Lineart：暂时可以把这个理解为是Canny的全面升级。当然你要是要求不高用Canny也行。</li></ul><div class="table-container"><table><thead><tr><th>原图</th><th>边缘线条图</th><th>创作结果</th></tr></thead><tbody><tr><td><img src="\image\back.png" alt=""></td><td><img src="\image\image2.png" alt=""></td><td><img src="\image\canny1.png" alt=""></td></tr></tbody></table></div><h2 id="HED-amp-SoftEdge"><a href="#HED-amp-SoftEdge" class="headerlink" title="HED &amp; SoftEdge"></a>HED &amp; SoftEdge</h2><p>HED是老版本，新版本（v1.1）里变成了SoftEdge，全称柔和边缘。SoftEdge生成出来的效果图要比Canny边缘更为柔和，因此在你认为Canny太过于拘束、写实的时候可以尝试用SoftEdge，提取一些更为关键的边缘信息，忽略不重要的边缘信息。这样做出来的图更加柔和，关系更加稳定一些。</p><p>这里面的四个预处理器，HED的质量比Pid更高，Safe是精简版的意思。</p><div class="table-container"><table><thead><tr><th style="text-align:left">原图</th><th style="text-align:left">边缘图</th><th>创作结果</th></tr></thead><tbody><tr><td style="text-align:left"><img src="\image\微信图片_20231002160402.png" alt=""></td><td style="text-align:left"><img src="\image\image3.png" alt=""></td><td><img src="\image\SE.png" alt=""></td></tr></tbody></table></div><h2 id="Scribble"><a href="#Scribble" class="headerlink" title="Scribble"></a>Scribble</h2><p>原意涂鸦乱画，这个就是当初非常惊艳我们的随便画几笔就能生成图片的那个工具了。自己在PS里面随便画几笔，文本中输出不那么多的限定性不强的提示词，就能够生成 非常具有创造力的图片了。注意，Scribble也是黑底白线的模式，所以如果使用了白底黑线，那么请使用Invert处理器。</p><div class="table-container"><table><thead><tr><th>原图（也可以手绘）</th><th>边缘图</th><th>创作结果</th></tr></thead><tbody><tr><td><img src="\image\Back_Li.jpg" alt=""></td><td><img src="\image\image4.png" alt=""></td><td><img src="\image\cyb.png" alt=""></td></tr></tbody></table></div><h2 id="Tile"><a href="#Tile" class="headerlink" title="Tile"></a>Tile</h2><p>增加局部细节，根据画面自动推断内容，修复放大分辨率而导致的细节丢失。</p><div class="table-container"><table><thead><tr><th>before</th><th>after</th></tr></thead><tbody><tr><td><img src="\image\after.png" alt=""></td><td><img src="\image\before.png" alt=""></td></tr></tbody></table></div><h2 id="Multiple-ControlNet"><a href="#Multiple-ControlNet" class="headerlink" title="Multiple - ControlNet"></a>Multiple - ControlNet</h2><p>多重控制网，可以同时加载多个ControlNet预处理器，以达到他们功能和优缺点的互补。</p><p>​    比如上文中提到的Openpose的缺陷，就可以使用Openpose+Depth的双重控制来实现。同一张图，在两个Union中分别用Openpose和Depth来跑，并降低次要预处理器的权重系数（比如这里把Depth权重降为0.5左右），就可以实现手放在额头上，并且人物肢体动作被Openpose规定的效果了。</p><p>​    并非任意两个效果都可以叠加，需要注意他们的相性。除了上文提及的，其余常用的组合还有比如Depth+Canny，Openpose+SoftEdge等。</p><h1 id="SD模型"><a href="#SD模型" class="headerlink" title="SD模型"></a>SD模型</h1><p>​    模型，就是在创作页面中最左上角的Stable Diffusion模型了。一个模型对应的就是一组训练集，喂给AI不同风格的图片加以训练就能产生不同风格的AI画风，想要改变画风就可以改变模型。</p><p>​    右侧外挂的vae模型相当于是滤镜，不同的画风适配不同的滤镜，我推荐去网上下载一个“kl-f8-anime2”（直接在C站搜索就行），这个是比较普适的滤镜，对于大部分（二次元）模型都能有不错的效果。此外初始提供的anime的vae也是一个普适的二次元画风。下载我的安装包的同学会发现里面自带了一个“vae-ft-mse-840000”的vae，这个对很多非二次元画风也有很好的作用。市面上有些比较有名的模型可能会自带vae。</p><h2 id="模型下载网站"><a href="#模型下载网站" class="headerlink" title="模型下载网站"></a>模型下载网站</h2><h3 id="Hugging-Face-抱脸"><a href="#Hugging-Face-抱脸" class="headerlink" title="Hugging Face 抱脸"></a>Hugging Face 抱脸</h3><p>网址：<a href="https://huggingface.co">https://huggingface.co</a></p><p>找后缀名为ckpt的下载（当然也有些模型不是以ckpt作为后缀，详见Nenly的教程）</p><h3 id="C站-Civitai"><a href="#C站-Civitai" class="headerlink" title="C站 Civitai"></a>C站 Civitai</h3><p>（可以不注册使用，注册的话注意一下身体顶不顶得住）</p><p>Model Type直接选择CheckPoint就行，其他不用管，选自己喜欢的。</p><h3 id="Nenly大佬提供"><a href="#Nenly大佬提供" class="headerlink" title="Nenly大佬提供"></a>Nenly大佬提供</h3><p><a href="https://pan.baidu.com/s/10rzgzIjzad7AKmj-w8zO_w?pwd=nely">https://pan.baidu.com/s/10rzgzIjzad7AKmj-w8zO_w?pwd=nely</a></p><p>大家可以进这个链接进行下载，其中模型部分是SD04，选择自己需要的下载即可，不然你的电脑会爆掉。他提供了下面我说的这几个常用模型。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="二次元类"><a href="#二次元类" class="headerlink" title="二次元类"></a>二次元类</h3><p>偏漫画、插画风格，具有比较鲜明的绘画笔触质感</p><ol><li>Anything V5 （中文名万象熔炉，就是一开始我让大噶选的）</li><li>Counterfeit（精致感很好，细节还原程度高）</li><li>Dreamlike Diffusion（比较具有科幻、梦幻色彩，带一点点赛博的感觉）</li><li>Abyss Orange Mix（中文名深渊橘/橙，经典有名的二次元风格模型）</li></ol><h3 id="真实系"><a href="#真实系" class="headerlink" title="真实系"></a>真实系</h3><p>拟真化程度高，对现实世界还原较好</p><ol><li>Deliberate（目前最好的真实系模型之一，细节和质感都不错）</li><li>Realistic Vision（更加朴素的写实类模型）</li><li>LOFI（精致的照片级别人像专精模型）</li><li>Film Grain 2.0（胶片颗粒2.0）<ol><li>是大佬Hello World模型的上一版，可惜我Hello World SDXL老是报错，退而求其次了</li><li>建议使用Negative hand这个Embedding</li></ol></li><li>Majic 橘麦写实V2.5（用了几次，感觉真不行）<ol><li>不要开脸部修复AD etailer</li><li>推荐关键词：<code>Best quality, masterpiece, ultra high res, (photorealistic:1.4), 1girl</code></li><li>推荐负面关键词：<code>ng_deepnegative_v1_75t, badhandv4</code></li><li>脸部修复的方法 to inpaint the face: inpaint—&gt;only masked—&gt;set to 512x512—&gt;Denoising strength:0.2~0.5</li></ol></li></ol><h3 id="2-5D"><a href="#2-5D" class="headerlink" title="2.5D"></a>2.5D</h3><p>类似建模软件的三维渲染图，三渲二那种感觉</p><ol><li>NeverEnding Dream（接近三次元的2.5D模型，适合游戏中精致的人物建模）</li><li>Protogen（优秀的照片效果和创意发挥空间）</li><li>GuoFeng3（国风、古风主题模型，国人的优秀作品）</li><li>MengX_Mix_Fantacy（偏向幻想风格的模型，偏向真人一点）<ol><li>建议使用插件：ADetailer 来进行面部和手部修复</li><li>负面关键词 ：<code>(ng_deepnegative_v1_75t),(badhandv4),(worst quality:2),(low quality:2),(normal quality:2),lowres,bad anatomy,bad hands,normal quality,((monochrome)),((grayscale)),</code></li></ol></li></ol><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p>这里用同一张农夫山泉跑了几组类似的图（如果是农夫山泉的话…）</p><div class="table-container"><table><thead><tr><th>二次元：万象熔炉+kl-f8</th><th>二次元：DreamLike+animevae</th><th>二次元：深渊橘V3+kl-f8</th></tr></thead><tbody><tr><td><img src="\image\农夫山泉2.png" alt=""></td><td><img src="\image\农夫山泉_DreamLike.png" alt=""></td><td><img src="\image\农夫山泉_深渊橘.png" alt=""></td></tr><tr><td><strong>2.5D风：国风3+kl-f8</strong></td><td><strong>2.5D风：NE Dream+kl-f8</strong></td><td></td></tr><tr><td><img src="\image\农夫山泉_国风.png" alt=""></td><td><img src="\image\农夫山泉_NED.png" alt=""></td><td></td></tr><tr><td><strong>真实系：Deliberate+84000</strong></td><td><strong>真实系：LOFI+84000</strong></td><td></td></tr><tr><td><img src="\image\农夫山泉_Deliberate.png" alt=""></td><td><img src="\image\农夫山泉_LF.png" alt=""></td></tr></tbody></table></div><h1 id="图像の高清修复"><a href="#图像の高清修复" class="headerlink" title="图像の高清修复"></a>图像の高清修复</h1><h2 id="高清修复（Hires-fix）"><a href="#高清修复（Hires-fix）" class="headerlink" title="高清修复（Hires.fix）"></a>高清修复（Hires.fix）</h2><p>​    正如上文所言，我推荐你在一个低分辨率的情况下跑AI进行抽卡，当你抽中一张比较符合你内心想法的画作的时候，就可以丢到文生图下方的高分辨率修复里面去了。使用方法很简单，把你喜欢的跑图的种子复制进来以确保产生的图几乎类似，然后开高清修复，尺寸可以用倍数设置也可以用分辨率设置。</p><ul><li><p>放大算法：各种放大算法在经过实验之后得出的结论是没有什么区别，几乎都长差不多。比较推荐的有Legan、R-ESRGAN、R-ESRGAN Anime6B（这个适合二次元），当然你可以选别的自己尝试，反正大差不差。</p></li><li><p>采样步数：高清修复相当于重绘，因此同样需要设置采样步数。设置为默认0的话则采用与图像生成一样的采样步数。</p></li><li><p>重绘幅度：如果跟原图偏差不想太大，选0.3 ~ 0.5；想稍微变一点让AI自由创作一些，选0.5 ~ 0.7。太小会使细节不够，太大有几率会出现奇怪现象。</p></li></ul><h2 id="后期处理-附加功能"><a href="#后期处理-附加功能" class="headerlink" title="后期处理/附加功能"></a>后期处理/附加功能</h2><p>这个就在文生图/图生图边上，操作方法不用人讲应该都能看懂：设置一个放大倍数和一个放大算法，剩下的全部维持默认一个别管。</p><p>优点：跑得快，时间短</p><p>缺点：精细程度较低</p><p>特点：相当于重绘幅度为0的重绘，有点类似于PS的放大再锐化</p><h2 id="SD-Upscale脚本"><a href="#SD-Upscale脚本" class="headerlink" title="SD Upscale脚本"></a>SD Upscale脚本</h2><ul><li>优点：显存小也能出大图；缺点：跑的比较慢。</li><li>脚本的安装：进入网页最右侧的扩展，从网页下载，输入下方链接进行安装，完成后重启网页UI。</li></ul><p><a href="https://github.com/Coyote-A/ultimate-upscale-for-automatic1111">https://github.com/Coyote-A/ultimate-upscale-for-automatic1111</a></p><ul><li>在图生图模式的最下方可以找到脚本，选择SD Upscale进入。自定义尺寸、选择放大算法不再赘述。</li><li>蒙版边缘模糊程度：这个东西的原理是把一张大图切割成不同的小图去跑，这个参数越大相当于两张图重叠越大，过渡越柔和，但是也不应该太大，一般32 ~ 128是一个较好的值。</li></ul><div class="table-container"><table><thead><tr><th>原图</th><th>结果图</th></tr></thead><tbody><tr><td><img src="\image\home.png" alt=""></td><td><img src="\image\SDU.png" alt=""></td></tr></tbody></table></div><h1 id="小模型"><a href="#小模型" class="headerlink" title="小模型"></a>小模型</h1><p>在之前我们介绍过了SD模型，其后缀通常为CheckPoint，机翻为检查点，实际含义也就是大模型。而除了大模型之外，我们还可以使用小模型，恰到好处地美化AI图片，解决诸如AI不会画手在内的一系列难题。</p><h2 id="Embeddings-文本嵌入"><a href="#Embeddings-文本嵌入" class="headerlink" title="Embeddings 文本嵌入"></a>Embeddings 文本嵌入</h2><p>​    这个东西在机器学习中被称为嵌入式向量，在C站中可以使用Textual Invention来检索它。这是一个仅有KB级别大小的文件，直接丢在Embeddings文件夹，并在图像生成时输入对应的一个关键词即可。这个相当于是一个小小的扩展，帮助AI了解某个特定的词语。比如AI被喂了人和鱼的信息，但是不知道美人鱼是什么，这时候特定的Embedding就会告诉他，这是一个“上半身女人，下班人鱼尾”的生物。</p><ul><li>一个很好用的例子：解决手部错乱</li></ul><p>​    网上有非常多著名的Embeddings都是为了解决手部问题而生，他们记录了一系列手部错误的集合，然后只需要把他们加入<strong>负面提示词</strong>内，即可将这个问题得到极大地改善。推荐几个：</p><ol><li>EasyNegative：主要针对二次元画风，关键词为<code>easynegative</code>，<code>EasyNegativeV2</code></li><li>DeepNegative：主要针对真人模型，关键词为<code>ng_deepnegative_v1_75t</code></li><li>Negative-Hand：关键词为<code>negative_hand</code>，<code>negative_hand-neg</code></li><li>badhandv4：关键词为<code>badhandv4</code></li></ol><h2 id="LoRa-低秩适应模式"><a href="#LoRa-低秩适应模式" class="headerlink" title="LoRa 低秩适应模式"></a>LoRa 低秩适应模式</h2><p>​    LoRa相比于上面的Embeddings，更着重于人物。比如说我想让AI帮我画一个嘉然（然然…嘿嘿我的嘉然…），但是这玩意儿肯定不是像美人鱼一样两三句话说得清的，于是就有作者专门针对嘉然构建了一个训练集。LoRa文件丢在models文件夹下的lora文件夹内，并在使用时加入<code>&lt;lora: LoRa_Name:0.8&gt;</code>这样的方式来调用，建议不要把提示强度开太高（大部分作者建议是0.5~0.8），不然容易影响画风。</p><p>​    可以考虑安装插件Additional Network，可以以一种可视化非常好的方式调用LoRa。此外，建议<strong>详细研读LoRa作者的作图建议</strong>。</p><p>​    这里下载了C站上一个下载量比较高的嘉然模型（触发关键词为<code>jiaran</code>），和另一个小众的嘉然常服训练集（无触发词），试一下。</p><div class="table-container"><table><thead><tr><th>图1</th><th>图2</th></tr></thead><tbody><tr><td><img src="\image\Jiaran1.png" alt=""></td><td><img src="\image\jiaran2.png" alt=""></td></tr></tbody></table></div><p>​    根据Nenly的教程，LoRa基本上可以分为五种应用，即：</p><ol><li>人物角色形象塑造：最常用的功能，比如上面的嘉然，一般来讲提示词强度开到0.7上下</li><li>画风/风格塑造：比如宫崎骏画风等，影响出图整体效果，一般提示词强度开到0.3上下</li><li>概念/构图：不太好描述，比如说画面变成抽卡立绘的感觉、角色呆在水晶球玻璃瓶的构图这样，一般不开太高</li><li>服饰：改变角色服饰，一般提示词强度开到0.2-0.3</li><li>物体/特定元素，常用于图生图局部重绘，改变特定部分的风格，一般不开太高</li></ol><h3 id="My-LoRa"><a href="#My-LoRa" class="headerlink" title="My LoRa"></a>My LoRa</h3><ol><li>嘉然<code>Jiaran</code></li><li>嘉然-常服<code>Jiaran_Changfu</code><ol><li>数值在0.5-0.7之间最佳</li></ol></li><li>细节修复<code>Detail Tweaker</code><ol><li>Based Model: SD1.5</li><li>权重可以是-2到2之间的任何值，负值可以减少细节</li></ol></li><li>细节增加<code>Detail Enhancer</code><ol><li>Based Model: SD1.5</li><li>权重推荐在0.5上下，小于0.5可以获得比较微妙的效果。1太高了。</li></ol></li><li>胶片风格<code>LEOSAM&#39;s FilmGirl</code><ol><li>Based Model: Hello World SDXL</li><li>这是用于生成胶片风格AI写真照片的LoHA &amp; LoRA模型，可以生成逼真的胶片风格照片。可以搭配<code>negative_hand</code>的Embedding</li><li>常用的CFG范围是6 ~ 7，Lora权重通常在0.5 ~ 0.7</li><li>Clip skip设为1或2时，生成的效果会有所不同，看自己喜欢哪种风格</li></ol></li><li>塔罗牌风格<code>taro</code><ol><li>可以用<code>&#123;&#125; background</code>来设置背景，如<code>blue background</code></li><li>推荐使用Embedding：<code>EasyNegative, badhandv4</code></li><li>推荐强度：0.8~1</li><li>Based Model: 万象熔炉 &amp; 深渊橘</li></ol></li><li>服装调节器<ol><li>权重设置在-1到1之间，权重越大，对象衣物越少</li><li>跟LoRa5、Hello World SDHX模型是同一个大佬发布的</li></ol></li><li>带背景立绘<code>tachi-e</code><ol><li>一般使用<code>wight background, full doby, looking at viewers</code>提示词</li><li>触发词<code>tachi-e</code>，一般权重可以直接设置成1</li></ol></li><li>弹弓泳衣<code>slingshot swimsuit</code><ol><li>建议Clip Skip：2</li><li>强度似乎是1 ~ 1.2？自己感觉0.8左右别大于1</li></ol></li><li>人物美化Cute Girl<code>mix4</code><ol><li>推荐强度0.4~0.7</li></ol></li><li>亚洲女性脸模<code>MengX girl_Mix_V40</code><ol><li>推荐强度0.7~1.0</li><li>务必打开ADetailer插件使用</li><li>可以尝试在提示词中增加blush，或许能更加可爱、少女</li></ol></li><li>私房写真风的泛用少女感混血脸<code>shojovibe_v11</code><ol><li>推荐强度0.6-0.8</li></ol></li><li>八重神子<ol><li>应我室友要求搞的，被80了呜呜呜</li><li>推荐提示词强度：0.45-0.75</li></ol></li><li>液体波浪概念衣服<ol><li>触发词：<code>liquid clothes, water</code></li><li>可用提示词：<code>blue theme, blue dress, waves, sea, water, water dress</code>，甚至<code>liquid hair</code>和<code>sky_print</code></li></ol></li><li>露西（赛博朋克边缘行者）<ol><li>提示词强度0.65左右，最大1（1有点小大）</li><li>建议提示词：<code>(robot joints:0.5), mechanical parts, lucy \(cyberpunk\), jacket, shorts</code></li></ol></li><li>素体机娘<ol><li>建议提示词：<code>mecha musume, mechanical arms, headgear, bodysuit (可选)</code></li><li>提示词强度:1-1.5</li></ol></li><li>Oversized Clothes<ol><li>LORA 权重：建议为 0.2-0.7（我在图像中使用了 0.5）</li><li>关键词：<code>oversized_hoodie</code>、<code>oversized_sweater</code></li></ol></li></ol><h2 id="HyperNetwork"><a href="#HyperNetwork" class="headerlink" title="HyperNetwork"></a>HyperNetwork</h2><p>​    中文名：超网络，一般用于改善整体画风。一般来讲用的比较少，业内风评也相对一般。这里举一个著名的例子，C站的“Waven Chibi Style”，开启后可以获得非常Q版的图像。开启方式：将HyperNetwork文件丢在对应的文件夹内，然后在网页UI的设置界面中选择超网络。</p><h1 id="局部重绘"><a href="#局部重绘" class="headerlink" title="局部重绘"></a>局部重绘</h1><p>字面意思很好理解，用于修正那些大题都非常满意，细节不太行的图。</p><h2 id="图生图局部重绘"><a href="#图生图局部重绘" class="headerlink" title="图生图局部重绘"></a>图生图局部重绘</h2><p>蒙版边缘模糊=羽化（10以下的非0值），蒙版边缘预留像素=扩展+融合（默认32，修改区域大就开大，反之减小）</p><p>蒙版区域内容处理：选择“填充”可以使变化自由一些。</p><p>重绘区域：一般建议修改区域大可以选整张图片，区域小选仅蒙版。</p><h2 id="图生图涂鸦重绘"><a href="#图生图涂鸦重绘" class="headerlink" title="图生图涂鸦重绘"></a>图生图涂鸦重绘</h2><p>比局部重绘多了一个调色盘，意思就是说你画上去的东西会影响他的生成。比如你想在原有美女的脸上画一个带白色爱心的蓝色口罩，那你就可以自己简单用蓝色画一个口罩，再用白色画一个爱心即可。这样引导性会更强一些。记得修改提示词。</p><h1 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h1><p><a href="https://pan.baidu.com/s/10rzgzIjzad7AKmj-w8zO_w?pwd=nely">https://pan.baidu.com/s/10rzgzIjzad7AKmj-w8zO_w?pwd=nely</a></p><p>其中插件是SD08</p><h2 id="Trigger"><a href="#Trigger" class="headerlink" title="Trigger"></a>Trigger</h2><p>根据图画反推提示词，跟图生图里的类似但效果更好，但是不知道为什么我找不到这玩意儿。</p><h2 id="LLUL"><a href="#LLUL" class="headerlink" title="LLUL"></a>LLUL</h2><p>局部细节重绘，使用方法跟图像放大类似。</p><h2 id="Cut-Off"><a href="#Cut-Off" class="headerlink" title="Cut Off"></a>Cut Off</h2><p>使用一些非常精细的描述（比如非常准确地描述人物穿搭），常常会使AI产生误判。将这些提示词丢到Cut Off里面可以大大减少AI误判程度。</p><h2 id="AD-etailer"><a href="#AD-etailer" class="headerlink" title="AD etailer"></a>AD etailer</h2><p><a href="https://github.com/Bing-su/adetailer">https://github.com/Bing-su/adetailer</a></p><p>着重人脸修复。提示词直接复制模型提示词即可。</p><div class="table-container"><table><thead><tr><th>模型</th><th>适用对象</th></tr></thead><tbody><tr><td>face_yolov8n.pt</td><td>2D / 真实人脸</td></tr><tr><td>face_yolov8s.pt</td><td>2D / 真实人脸</td></tr><tr><td>hand_yolov8n.pt</td><td>2D / 真实人手</td></tr><tr><td>person_yolov8n-seg.pt</td><td>2D / 真实全身</td></tr><tr><td>person_yolov8s-seg.pt</td><td>2D/真实全身</td></tr><tr><td>mediapipe_face_full</td><td>真实人脸</td></tr><tr><td>mediapipe_face_short</td><td>真实人脸</td></tr><tr><td>mediapipe_face_mesh</td><td>真实人脸</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 软件教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 教程 </tag>
            
            <tag> 有趣的东西 </tag>
            
            <tag> AI绘画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Read Me</title>
      <link href="/2023/09/27/Read%20Me/"/>
      <url>/2023/09/27/Read%20Me/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>欢迎来到我的个人博客主页</p><ul><li>你可以在右上角的<strong>分类</strong>和<strong>标签</strong>中找到你所需要的资料，或者在右侧边栏中找到他们。</li><li>你可以在右上角的<strong>搜索</strong>栏中快速搜索到你需要的内容。</li><li>你可以在右上角的<strong>友链</strong>中找到其他人的博客，和一些有意思的网站。</li><li>你可以在右上角的<strong>图库</strong>中找到一些能播的图片</li><li><strong>说说</strong>和<strong>评论</strong>我已经关闭了，我确实不了解这方面的配置，太久没人使用，就关闭了。如果你想找我的话，微信上还是可以聊的。</li></ul><hr><p>​        累了，写不动了。或许，我的笔记本来也就不会有多少人看吧，当初也是心血来潮做的这个网页，不过细细想来，确实也没对大家产生多少的帮助。</p><p>​        我见过好多不一样的人了。有的人能够轻松地理解，合作起来畅快无比，钻研起来永无止境；有的人当我把一步步怎么做的教程丢在他们面前，都完全不会操作，如同嗷嗷待哺的婴儿。</p><p>​        或许以后就是随缘更新了吧，自己想记的笔记就记一下。</p><p>​        也曾想变成传说中的大佬一样，仿佛难以望其项背的神话。可是我做不到，我承认了，我只是个普通人罢了，没有卓越的天资，没有伟岸的人格，没有坚韧的精神。确实最近是被一些东西打击到了。再妄想做些什么笔记出来帮助你们，恍如痴人说梦，我还不够格。</p><hr><ul><li>My Wechat：hans420907574</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/24/hello-world/"/>
      <url>/2023/09/24/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>This article is for me.</li></ul><h2 id="一些网页端的简记"><a href="#一些网页端的简记" class="headerlink" title="一些网页端的简记"></a>一些网页端的简记</h2><h3 id="开头"><a href="#开头" class="headerlink" title="开头"></a>开头</h3><p>在每篇文档开头，打上标签，如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章标题</span><br><span class="line">date: 2023-09-25</span><br><span class="line">comments: true</span><br><span class="line">mathjax: true # 开启数学公式</span><br><span class="line">top<span class="emphasis">_img: /image/top3.jpg</span></span><br><span class="line"><span class="emphasis">cover: 缩略图图片连接</span></span><br><span class="line"><span class="emphasis">description: 文章简介</span></span><br><span class="line"><span class="emphasis">tags: 标签</span></span><br><span class="line"><span class="emphasis">categories: 分类</span></span><br><span class="line"><span class="emphasis"></span></span><br><span class="line"><span class="emphasis">post_</span>meta:</span><br><span class="line">  page:</span><br><span class="line"><span class="code">    date_type: both </span></span><br><span class="line"><span class="code">    date_format: date </span></span><br><span class="line"><span class="code">    categories: true </span></span><br><span class="line"><span class="code">    tags: true </span></span><br><span class="line"><span class="code">    label: true </span></span><br><span class="line"><span class="code">  post:</span></span><br><span class="line"><span class="code">    date_type: both </span></span><br><span class="line"><span class="code">    date_format: date </span></span><br><span class="line"><span class="code">    categories: true </span></span><br><span class="line"><span class="code">    tags: true </span></span><br><span class="line"><span class="code">    label: true </span></span><br><span class="line"><span class="code"></span></span><br><span class="line">copyright<span class="emphasis">_author: Paradox</span></span><br><span class="line"><span class="emphasis">copyright_</span>author<span class="emphasis">_href: https://github.com/ParadoxTZ</span></span><br><span class="line"><span class="emphasis">copyright_</span>info: 此文章版权归Paradox所有，如有转载，请注明来自原作者</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li><p>文章的标题图片统一使用“/image/top3.jpg”</p></li><li><p>页面的标题图片统一使用“/image/top.jpeg”</p></li><li><p>标准图表网站：<a href="https://fontawesome.com/">Find Icons with the Perfect Look &amp; Feel | Font Awesome</a></p><ul><li>例：<code>&lt;i class=&quot;fa-brands fa-github&quot;&gt;&lt;/i&gt;</code></li><li>改为：fab fa-github</li></ul></li><li><p>按钮button（附上两个好看的。第二个有手指第一个没有）</p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btn [url],[text],[icon],[color] [style] [layout] [position] [size] %&#125;</span><br><span class="line">中间用逗号或&quot;-&quot;隔开，按要求</span><br><span class="line">[url]         : 链接</span><br><span class="line">[text]        : 按钮文字</span><br><span class="line">[icon]        : [可选] 图标</span><br><span class="line">[color]       : [可选] 按钮背景顔色(默认style时）</span><br><span class="line"><span class="code">                      按钮字体和边框顔色(outline时)，default/blue/pink/red/purple/orange/green</span></span><br><span class="line"><span class="code">[style]       : [可选] 按钮样式 默认实心，outline/留空</span></span><br><span class="line"><span class="code">[layout]      : [可选] 按钮佈局 默认为line，block/留空</span></span><br><span class="line"><span class="code">[position]    : [可选] 按钮位置 前提是设置了layout为block 默认为左边，center/right/留空</span></span><br><span class="line"><span class="code">[size]        : [可选] 按钮大小，larger/留空</span></span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly %&#125;</span><br><span class="line">&#123;% btn &#x27;https://butterfly.js.org/&#x27;,Butterfly,far fa-hand-point-right,larger %&#125;</span><br></pre></td></tr></table></figure><ul><li><h3 id="文章缩略图"><a href="#文章缩略图" class="headerlink" title="文章缩略图"></a>文章缩略图</h3></li></ul><p>按需取用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">default_cover: </span><br><span class="line">    - https://img2.baidu.com/it/u=1235612171,3868693941&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281（√）</span><br><span class="line">    - https://img1.baidu.com/it/u=2996267891,32376633&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500（√）</span><br><span class="line">    - https://img1.baidu.com/it/u=312822943,1236795569&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800</span><br><span class="line">    - https://img0.baidu.com/it/u=1804133410,3139237737&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1280&amp;h=800</span><br><span class="line">    - https://img1.baidu.com/it/u=161683432,2488264310&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=800&amp;h=500（√）</span><br><span class="line">    - https://img1.baidu.com/it/u=3498215964,1377341541&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500</span><br><span class="line">    - https://img1.baidu.com/it/u=3664282049,2844914481&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=889&amp;h=500</span><br><span class="line">    - https://img0.baidu.com/it/u=2189029883,1880322455&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1280&amp;h=800</span><br><span class="line">    - https://img1.baidu.com/it/u=2477736930,489697403&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1422&amp;h=800</span><br><span class="line">    - https://img2.baidu.com/it/u=504235302,299195994&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281</span><br><span class="line">    - https://img0.baidu.com/it/u=6927155,1857076631&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=281</span><br><span class="line">    - https://img0.baidu.com/it/u=3270195087,2703081542&amp;fm=253&amp;fmt=auto&amp;app=120&amp;f=JPEG?w=1280&amp;h=800</span><br></pre></td></tr></table></figure><h3 id="Test-Part"><a href="#Test-Part" class="headerlink" title="Test Part"></a>Test Part</h3><p>$q=\frac{T_1-T_2}{\frac1{h_1A}+\frac{\delta}{\lambda A}+\frac1{h_2A}}$</p>]]></content>
      
      
      <categories>
          
          <category> 软件教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
